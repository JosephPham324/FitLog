//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.0.3.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import followIfLoginRedirect from './components/api-authorization/followIfLoginRedirect';

export class TodoItemsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getTodoItemsWithPagination(listId: number, pageNumber: number, pageSize: number): Promise<PaginatedListOfTodoItemBriefDto> {
        let url_ = this.baseUrl + "/api/TodoItems?";
        if (listId === undefined || listId === null)
            throw new Error("The parameter 'listId' must be defined and cannot be null.");
        else
            url_ += "ListId=" + encodeURIComponent("" + listId) + "&";
        if (pageNumber === undefined || pageNumber === null)
            throw new Error("The parameter 'pageNumber' must be defined and cannot be null.");
        else
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === undefined || pageSize === null)
            throw new Error("The parameter 'pageSize' must be defined and cannot be null.");
        else
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTodoItemsWithPagination(_response);
        });
    }

    protected processGetTodoItemsWithPagination(response: Response): Promise<PaginatedListOfTodoItemBriefDto> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfTodoItemBriefDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PaginatedListOfTodoItemBriefDto>(null as any);
    }

    createTodoItem(command: CreateTodoItemCommand): Promise<number> {
        let url_ = this.baseUrl + "/api/TodoItems";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateTodoItem(_response);
        });
    }

    protected processCreateTodoItem(response: Response): Promise<number> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(null as any);
    }

    updateTodoItem(id: number, command: UpdateTodoItemCommand): Promise<void> {
        let url_ = this.baseUrl + "/api/TodoItems/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateTodoItem(_response);
        });
    }

    protected processUpdateTodoItem(response: Response): Promise<void> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    deleteTodoItem(id: number): Promise<void> {
        let url_ = this.baseUrl + "/api/TodoItems/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteTodoItem(_response);
        });
    }

    protected processDeleteTodoItem(response: Response): Promise<void> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    updateTodoItemDetail(id: number, command: UpdateTodoItemDetailCommand): Promise<void> {
        let url_ = this.baseUrl + "/api/TodoItems/UpdateDetail/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateTodoItemDetail(_response);
        });
    }

    protected processUpdateTodoItemDetail(response: Response): Promise<void> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class TodoListsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getTodoLists(): Promise<TodosVm> {
        let url_ = this.baseUrl + "/api/TodoLists";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTodoLists(_response);
        });
    }

    protected processGetTodoLists(response: Response): Promise<TodosVm> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TodosVm.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TodosVm>(null as any);
    }

    createTodoList(command: CreateTodoListCommand): Promise<number> {
        let url_ = this.baseUrl + "/api/TodoLists";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateTodoList(_response);
        });
    }

    protected processCreateTodoList(response: Response): Promise<number> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(null as any);
    }

    updateTodoList(id: number, command: UpdateTodoListCommand): Promise<void> {
        let url_ = this.baseUrl + "/api/TodoLists/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateTodoList(_response);
        });
    }

    protected processUpdateTodoList(response: Response): Promise<void> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    deleteTodoList(id: number): Promise<void> {
        let url_ = this.baseUrl + "/api/TodoLists/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteTodoList(_response);
        });
    }

    protected processDeleteTodoList(response: Response): Promise<void> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class WeatherForecastsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getWeatherForecasts(): Promise<WeatherForecast[]> {
        let url_ = this.baseUrl + "/api/WeatherForecasts";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetWeatherForecasts(_response);
        });
    }

    protected processGetWeatherForecasts(response: Response): Promise<WeatherForecast[]> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WeatherForecast.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WeatherForecast[]>(null as any);
    }
}

export class EquipmentsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getEquipmentsWithPagination(pageNumber: number, pageSize: number): Promise<PaginatedListOfEquipmentDetailsDTO> {
        let url_ = this.baseUrl + "/api/Equipments/get-all?";
        if (pageNumber === undefined || pageNumber === null)
            throw new Error("The parameter 'pageNumber' must be defined and cannot be null.");
        else
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === undefined || pageSize === null)
            throw new Error("The parameter 'pageSize' must be defined and cannot be null.");
        else
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEquipmentsWithPagination(_response);
        });
    }

    protected processGetEquipmentsWithPagination(response: Response): Promise<PaginatedListOfEquipmentDetailsDTO> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfEquipmentDetailsDTO.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PaginatedListOfEquipmentDetailsDTO>(null as any);
    }

    searchEquipment(equipmentName: string | null | undefined, pageNumber: number, pageSize: number): Promise<PaginatedListOfEquipmentDetailsDTO> {
        let url_ = this.baseUrl + "/api/Equipments/search?";
        if (equipmentName !== undefined && equipmentName !== null)
            url_ += "EquipmentName=" + encodeURIComponent("" + equipmentName) + "&";
        if (pageNumber === undefined || pageNumber === null)
            throw new Error("The parameter 'pageNumber' must be defined and cannot be null.");
        else
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === undefined || pageSize === null)
            throw new Error("The parameter 'pageSize' must be defined and cannot be null.");
        else
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearchEquipment(_response);
        });
    }

    protected processSearchEquipment(response: Response): Promise<PaginatedListOfEquipmentDetailsDTO> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfEquipmentDetailsDTO.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PaginatedListOfEquipmentDetailsDTO>(null as any);
    }

    getEquipmentById(id: number): Promise<EquipmentDetailsDTO> {
        let url_ = this.baseUrl + "/api/Equipments/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEquipmentById(_response);
        });
    }

    protected processGetEquipmentById(response: Response): Promise<EquipmentDetailsDTO> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EquipmentDetailsDTO.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EquipmentDetailsDTO>(null as any);
    }

    updateEquipment(id: number, command: UpdateEquipmentCommand): Promise<Result> {
        let url_ = this.baseUrl + "/api/Equipments/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateEquipment(_response);
        });
    }

    protected processUpdateEquipment(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    deleteEquipment(id: number, command: DeleteEquipmentCommand): Promise<Result> {
        let url_ = this.baseUrl + "/api/Equipments/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteEquipment(_response);
        });
    }

    protected processDeleteEquipment(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    createEquipment(command: CreateEquipmentCommand): Promise<Result> {
        let url_ = this.baseUrl + "/api/Equipments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateEquipment(_response);
        });
    }

    protected processCreateEquipment(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }
}

export class ExercisesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getExercisesWithPagination(pageNumber: number, pageSize: number): Promise<PaginatedListOfExerciseDTO> {
        let url_ = this.baseUrl + "/api/Exercises/paginated-all?";
        if (pageNumber === undefined || pageNumber === null)
            throw new Error("The parameter 'pageNumber' must be defined and cannot be null.");
        else
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === undefined || pageSize === null)
            throw new Error("The parameter 'pageSize' must be defined and cannot be null.");
        else
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetExercisesWithPagination(_response);
        });
    }

    protected processGetExercisesWithPagination(response: Response): Promise<PaginatedListOfExerciseDTO> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfExerciseDTO.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PaginatedListOfExerciseDTO>(null as any);
    }

    getExerciseTypes(): Promise<string[]> {
        let url_ = this.baseUrl + "/api/Exercises/exercise-types";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetExerciseTypes(_response);
        });
    }

    protected processGetExerciseTypes(response: Response): Promise<string[]> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string[]>(null as any);
    }

    getExerciseById(id: number): Promise<void> {
        let url_ = this.baseUrl + "/api/Exercises/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetExerciseById(_response);
        });
    }

    protected processGetExerciseById(response: Response): Promise<void> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    updateExercise(id: number, command: UpdateExerciseCommand): Promise<Result> {
        let url_ = this.baseUrl + "/api/Exercises/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateExercise(_response);
        });
    }

    protected processUpdateExercise(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    searchExercises(exerciseName: string | null | undefined, equipmentId: string | null | undefined, muscleGroupIds: string | null | undefined): Promise<ExerciseDTO[]> {
        let url_ = this.baseUrl + "/api/Exercises/search?";
        if (exerciseName !== undefined && exerciseName !== null)
            url_ += "exerciseName=" + encodeURIComponent("" + exerciseName) + "&";
        if (equipmentId !== undefined && equipmentId !== null)
            url_ += "equipmentId=" + encodeURIComponent("" + equipmentId) + "&";
        if (muscleGroupIds !== undefined && muscleGroupIds !== null)
            url_ += "muscleGroupIds=" + encodeURIComponent("" + muscleGroupIds) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearchExercises(_response);
        });
    }

    protected processSearchExercises(response: Response): Promise<ExerciseDTO[]> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ExerciseDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ExerciseDTO[]>(null as any);
    }

    createExercise(command: CreateExerciseCommand): Promise<Result> {
        let url_ = this.baseUrl + "/api/Exercises";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateExercise(_response);
        });
    }

    protected processCreateExercise(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    deleteExercise(command: DeleteExerciseCommand): Promise<Result> {
        let url_ = this.baseUrl + "/api/Exercises";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteExercise(_response);
        });
    }

    protected processDeleteExercise(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    importExercises(command: ImportExercisesCommand): Promise<Result> {
        let url_ = this.baseUrl + "/api/Exercises/import-exercises";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processImportExercises(_response);
        });
    }

    protected processImportExercises(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }
}

export class MuscleGroupsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getMuscleGroupsList(pageNumber: number, pageSize: number): Promise<PaginatedListOfMuscleGroupDTO> {
        let url_ = this.baseUrl + "/api/MuscleGroups/get-list?";
        if (pageNumber === undefined || pageNumber === null)
            throw new Error("The parameter 'pageNumber' must be defined and cannot be null.");
        else
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === undefined || pageSize === null)
            throw new Error("The parameter 'pageSize' must be defined and cannot be null.");
        else
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetMuscleGroupsList(_response);
        });
    }

    protected processGetMuscleGroupsList(response: Response): Promise<PaginatedListOfMuscleGroupDTO> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfMuscleGroupDTO.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PaginatedListOfMuscleGroupDTO>(null as any);
    }

    searchMuscleGroup(muscleGroupName: string | null | undefined, pageNumber: number, pageSize: number): Promise<PaginatedListOfMuscleGroupDTO2> {
        let url_ = this.baseUrl + "/api/MuscleGroups/search?";
        if (muscleGroupName !== undefined && muscleGroupName !== null)
            url_ += "MuscleGroupName=" + encodeURIComponent("" + muscleGroupName) + "&";
        if (pageNumber === undefined || pageNumber === null)
            throw new Error("The parameter 'pageNumber' must be defined and cannot be null.");
        else
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === undefined || pageSize === null)
            throw new Error("The parameter 'pageSize' must be defined and cannot be null.");
        else
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearchMuscleGroup(_response);
        });
    }

    protected processSearchMuscleGroup(response: Response): Promise<PaginatedListOfMuscleGroupDTO2> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfMuscleGroupDTO2.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PaginatedListOfMuscleGroupDTO2>(null as any);
    }

    getMuscleGroupsById(): Promise<MuscleGroupDTO2> {
        let url_ = this.baseUrl + "/api/MuscleGroups";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetMuscleGroupsById(_response);
        });
    }

    protected processGetMuscleGroupsById(response: Response): Promise<MuscleGroupDTO2> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MuscleGroupDTO2.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MuscleGroupDTO2>(null as any);
    }

    createMuscleGroup(command: CreateMuscleGroupCommand): Promise<Result> {
        let url_ = this.baseUrl + "/api/MuscleGroups/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateMuscleGroup(_response);
        });
    }

    protected processCreateMuscleGroup(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    updateMuscleGroup(id: number, command: UpdateMuscleGroupCommand): Promise<Result> {
        let url_ = this.baseUrl + "/api/MuscleGroups/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateMuscleGroup(_response);
        });
    }

    protected processUpdateMuscleGroup(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    deleteMuscleGroup(id: number): Promise<Result> {
        let url_ = this.baseUrl + "/api/MuscleGroups/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteMuscleGroup(_response);
        });
    }

    protected processDeleteMuscleGroup(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }
}

export class StatisticsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getWorkoutLogSummary(timeFrame: string): Promise<{ [key: string]: SummaryWorkoutLogStatsDTO; }> {
        let url_ = this.baseUrl + "/api/Statistics/overall/summary?";
        if (timeFrame === undefined || timeFrame === null)
            throw new Error("The parameter 'timeFrame' must be defined and cannot be null.");
        else
            url_ += "TimeFrame=" + encodeURIComponent("" + timeFrame) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetWorkoutLogSummary(_response);
        });
    }

    protected processGetWorkoutLogSummary(response: Response): Promise<{ [key: string]: SummaryWorkoutLogStatsDTO; }> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)![key] = resultData200[key] ? SummaryWorkoutLogStatsDTO.fromJS(resultData200[key]) : new SummaryWorkoutLogStatsDTO();
                }
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<{ [key: string]: SummaryWorkoutLogStatsDTO; }>(null as any);
    }

    getMusclesEngagement(timeFrame: string): Promise<{ [key: string]: MuscleEngagementDTO[]; }> {
        let url_ = this.baseUrl + "/api/Statistics/overall/muscles-engagement?";
        if (timeFrame === undefined || timeFrame === null)
            throw new Error("The parameter 'timeFrame' must be defined and cannot be null.");
        else
            url_ += "TimeFrame=" + encodeURIComponent("" + timeFrame) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetMusclesEngagement(_response);
        });
    }

    protected processGetMusclesEngagement(response: Response): Promise<{ [key: string]: MuscleEngagementDTO[]; }> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)![key] = resultData200[key] ? resultData200[key].map((i: any) => MuscleEngagementDTO.fromJS(i)) : [];
                }
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<{ [key: string]: MuscleEngagementDTO[]; }>(null as any);
    }

    getRepsStats(timeFrame: string): Promise<{ [key: string]: number; }> {
        let url_ = this.baseUrl + "/api/Statistics/overall/total-training-reps?";
        if (timeFrame === undefined || timeFrame === null)
            throw new Error("The parameter 'timeFrame' must be defined and cannot be null.");
        else
            url_ += "TimeFrame=" + encodeURIComponent("" + timeFrame) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRepsStats(_response);
        });
    }

    protected processGetRepsStats(response: Response): Promise<{ [key: string]: number; }> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)![key] = resultData200[key] !== undefined ? resultData200[key] : <any>null;
                }
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<{ [key: string]: number; }>(null as any);
    }

    getTonnageStats(timeFrame: string): Promise<{ [key: string]: number; }> {
        let url_ = this.baseUrl + "/api/Statistics/overall/total-training-tonnage?";
        if (timeFrame === undefined || timeFrame === null)
            throw new Error("The parameter 'timeFrame' must be defined and cannot be null.");
        else
            url_ += "TimeFrame=" + encodeURIComponent("" + timeFrame) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTonnageStats(_response);
        });
    }

    protected processGetTonnageStats(response: Response): Promise<{ [key: string]: number; }> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)![key] = resultData200[key] !== undefined ? resultData200[key] : <any>null;
                }
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<{ [key: string]: number; }>(null as any);
    }

    getTrainingFrequencies(timeFrame: string): Promise<{ [key: string]: number; }> {
        let url_ = this.baseUrl + "/api/Statistics/overall/training-frequency?";
        if (timeFrame === undefined || timeFrame === null)
            throw new Error("The parameter 'timeFrame' must be defined and cannot be null.");
        else
            url_ += "TimeFrame=" + encodeURIComponent("" + timeFrame) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTrainingFrequencies(_response);
        });
    }

    protected processGetTrainingFrequencies(response: Response): Promise<{ [key: string]: number; }> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)![key] = resultData200[key] !== undefined ? resultData200[key] : <any>null;
                }
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<{ [key: string]: number; }>(null as any);
    }

    getExerciseLogHistory(exerciseId: number): Promise<ExerciseLogDTO[]> {
        let url_ = this.baseUrl + "/api/Statistics/exercise/exercise-log-history/{ExerciseId}";
        if (exerciseId === undefined || exerciseId === null)
            throw new Error("The parameter 'exerciseId' must be defined.");
        url_ = url_.replace("{ExerciseId}", encodeURIComponent("" + exerciseId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetExerciseLogHistory(_response);
        });
    }

    protected processGetExerciseLogHistory(response: Response): Promise<ExerciseLogDTO[]> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ExerciseLogDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ExerciseLogDTO[]>(null as any);
    }

    getEstimated1RM(userId: string | null, exerciseId: number): Promise<{ [key: string]: OneRepMaxRecord; }> {
        let url_ = this.baseUrl + "/api/Statistics/exercise/estimated1RM?";
        if (userId === undefined)
            throw new Error("The parameter 'userId' must be defined.");
        else if(userId !== null)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (exerciseId === undefined || exerciseId === null)
            throw new Error("The parameter 'exerciseId' must be defined and cannot be null.");
        else
            url_ += "ExerciseId=" + encodeURIComponent("" + exerciseId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEstimated1RM(_response);
        });
    }

    protected processGetEstimated1RM(response: Response): Promise<{ [key: string]: OneRepMaxRecord; }> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)![key] = resultData200[key] ? OneRepMaxRecord.fromJS(resultData200[key]) : new OneRepMaxRecord();
                }
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<{ [key: string]: OneRepMaxRecord; }>(null as any);
    }

    getExercisesWithHistory(): Promise<ExerciseHistoryEntry[]> {
        let url_ = this.baseUrl + "/api/Statistics/exercise/logged-exercises";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetExercisesWithHistory(_response);
        });
    }

    protected processGetExercisesWithHistory(response: Response): Promise<ExerciseHistoryEntry[]> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ExerciseHistoryEntry.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ExerciseHistoryEntry[]>(null as any);
    }

    getExerciseRecords(exerciseId: number): Promise<PersonalRecordDTO> {
        let url_ = this.baseUrl + "/api/Statistics/exercise/{ExerciseId}/records";
        if (exerciseId === undefined || exerciseId === null)
            throw new Error("The parameter 'exerciseId' must be defined.");
        url_ = url_.replace("{ExerciseId}", encodeURIComponent("" + exerciseId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetExerciseRecords(_response);
        });
    }

    protected processGetExerciseRecords(response: Response): Promise<PersonalRecordDTO> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PersonalRecordDTO.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PersonalRecordDTO>(null as any);
    }

    getExerciseTotalReps(exerciseId: number, timeFrame: string): Promise<{ [key: string]: number; }> {
        let url_ = this.baseUrl + "/api/Statistics/exercise/{ExerciseId}/total-reps?";
        if (exerciseId === undefined || exerciseId === null)
            throw new Error("The parameter 'exerciseId' must be defined.");
        url_ = url_.replace("{ExerciseId}", encodeURIComponent("" + exerciseId));
        if (timeFrame === undefined || timeFrame === null)
            throw new Error("The parameter 'timeFrame' must be defined and cannot be null.");
        else
            url_ += "TimeFrame=" + encodeURIComponent("" + timeFrame) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetExerciseTotalReps(_response);
        });
    }

    protected processGetExerciseTotalReps(response: Response): Promise<{ [key: string]: number; }> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)![key] = resultData200[key] !== undefined ? resultData200[key] : <any>null;
                }
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<{ [key: string]: number; }>(null as any);
    }

    getExerciseTotalTonnage(exerciseId: number, timeFrame: string): Promise<{ [key: string]: number; }> {
        let url_ = this.baseUrl + "/api/Statistics/exercise/{ExerciseId}/total-tonnage?";
        if (exerciseId === undefined || exerciseId === null)
            throw new Error("The parameter 'exerciseId' must be defined.");
        url_ = url_.replace("{ExerciseId}", encodeURIComponent("" + exerciseId));
        if (timeFrame === undefined || timeFrame === null)
            throw new Error("The parameter 'timeFrame' must be defined and cannot be null.");
        else
            url_ += "TimeFrame=" + encodeURIComponent("" + timeFrame) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetExerciseTotalTonnage(_response);
        });
    }

    protected processGetExerciseTotalTonnage(response: Response): Promise<{ [key: string]: number; }> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)![key] = resultData200[key] !== undefined ? resultData200[key] : <any>null;
                }
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<{ [key: string]: number; }>(null as any);
    }

    getExerciseActual1RMs(exerciseId: number): Promise<{ [key: string]: number; }> {
        let url_ = this.baseUrl + "/api/Statistics/exercise/{ExerciseId}/actual-1rms";
        if (exerciseId === undefined || exerciseId === null)
            throw new Error("The parameter 'exerciseId' must be defined.");
        url_ = url_.replace("{ExerciseId}", encodeURIComponent("" + exerciseId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetExerciseActual1RMs(_response);
        });
    }

    protected processGetExerciseActual1RMs(response: Response): Promise<{ [key: string]: number; }> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)![key] = resultData200[key] !== undefined ? resultData200[key] : <any>null;
                }
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<{ [key: string]: number; }>(null as any);
    }

    getUserWorkoutLogSummary(id: string, timeFrame: string): Promise<{ [key: string]: SummaryWorkoutLogStatsDTO; }> {
        let url_ = this.baseUrl + "/api/Statistics/user/{id}/overall/summary?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (timeFrame === undefined || timeFrame === null)
            throw new Error("The parameter 'timeFrame' must be defined and cannot be null.");
        else
            url_ += "TimeFrame=" + encodeURIComponent("" + timeFrame) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUserWorkoutLogSummary(_response);
        });
    }

    protected processGetUserWorkoutLogSummary(response: Response): Promise<{ [key: string]: SummaryWorkoutLogStatsDTO; }> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)![key] = resultData200[key] ? SummaryWorkoutLogStatsDTO.fromJS(resultData200[key]) : new SummaryWorkoutLogStatsDTO();
                }
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<{ [key: string]: SummaryWorkoutLogStatsDTO; }>(null as any);
    }

    getUserMusclesEngagement(id: string, timeFrame: string): Promise<{ [key: string]: MuscleEngagementDTO[]; }> {
        let url_ = this.baseUrl + "/api/Statistics/user/{id}/overall/muscles-engagement?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (timeFrame === undefined || timeFrame === null)
            throw new Error("The parameter 'timeFrame' must be defined and cannot be null.");
        else
            url_ += "TimeFrame=" + encodeURIComponent("" + timeFrame) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUserMusclesEngagement(_response);
        });
    }

    protected processGetUserMusclesEngagement(response: Response): Promise<{ [key: string]: MuscleEngagementDTO[]; }> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)![key] = resultData200[key] ? resultData200[key].map((i: any) => MuscleEngagementDTO.fromJS(i)) : [];
                }
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<{ [key: string]: MuscleEngagementDTO[]; }>(null as any);
    }

    getUserRepsStats(id: string, timeFrame: string): Promise<{ [key: string]: number; }> {
        let url_ = this.baseUrl + "/api/Statistics/user/{id}/overall/total-training-reps?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (timeFrame === undefined || timeFrame === null)
            throw new Error("The parameter 'timeFrame' must be defined and cannot be null.");
        else
            url_ += "TimeFrame=" + encodeURIComponent("" + timeFrame) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUserRepsStats(_response);
        });
    }

    protected processGetUserRepsStats(response: Response): Promise<{ [key: string]: number; }> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)![key] = resultData200[key] !== undefined ? resultData200[key] : <any>null;
                }
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<{ [key: string]: number; }>(null as any);
    }

    getUserTonnageStats(id: string, timeFrame: string): Promise<{ [key: string]: number; }> {
        let url_ = this.baseUrl + "/api/Statistics/user/{id}/overall/total-training-tonnage?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (timeFrame === undefined || timeFrame === null)
            throw new Error("The parameter 'timeFrame' must be defined and cannot be null.");
        else
            url_ += "TimeFrame=" + encodeURIComponent("" + timeFrame) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUserTonnageStats(_response);
        });
    }

    protected processGetUserTonnageStats(response: Response): Promise<{ [key: string]: number; }> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)![key] = resultData200[key] !== undefined ? resultData200[key] : <any>null;
                }
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<{ [key: string]: number; }>(null as any);
    }

    getUserTrainingFrequencies(id: string, timeFrame: string): Promise<{ [key: string]: number; }> {
        let url_ = this.baseUrl + "/api/Statistics/user/{id}/overall/training-frequency?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (timeFrame === undefined || timeFrame === null)
            throw new Error("The parameter 'timeFrame' must be defined and cannot be null.");
        else
            url_ += "TimeFrame=" + encodeURIComponent("" + timeFrame) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUserTrainingFrequencies(_response);
        });
    }

    protected processGetUserTrainingFrequencies(response: Response): Promise<{ [key: string]: number; }> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)![key] = resultData200[key] !== undefined ? resultData200[key] : <any>null;
                }
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<{ [key: string]: number; }>(null as any);
    }

    getUserExerciseLogHistory(id: string, userId: string | null, exerciseId: number): Promise<ExerciseLogDTO[]> {
        let url_ = this.baseUrl + "/api/Statistics/user/{id}/exercise/exercise-log-history?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (userId === undefined)
            throw new Error("The parameter 'userId' must be defined.");
        else if(userId !== null)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (exerciseId === undefined || exerciseId === null)
            throw new Error("The parameter 'exerciseId' must be defined and cannot be null.");
        else
            url_ += "ExerciseId=" + encodeURIComponent("" + exerciseId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUserExerciseLogHistory(_response);
        });
    }

    protected processGetUserExerciseLogHistory(response: Response): Promise<ExerciseLogDTO[]> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ExerciseLogDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ExerciseLogDTO[]>(null as any);
    }

    getUserEstimated1RM(id: string, userId: string | null, exerciseId: number): Promise<any> {
        let url_ = this.baseUrl + "/api/Statistics/user/{id}/exercise/estimated1RM?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (userId === undefined)
            throw new Error("The parameter 'userId' must be defined.");
        else if(userId !== null)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (exerciseId === undefined || exerciseId === null)
            throw new Error("The parameter 'exerciseId' must be defined and cannot be null.");
        else
            url_ += "ExerciseId=" + encodeURIComponent("" + exerciseId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUserEstimated1RM(_response);
        });
    }

    protected processGetUserEstimated1RM(response: Response): Promise<any> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }

    getUserExercisesWithHistory(id: string): Promise<ExerciseHistoryEntry[]> {
        let url_ = this.baseUrl + "/api/Statistics/user/{id}/exercise/logged-exercises";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUserExercisesWithHistory(_response);
        });
    }

    protected processGetUserExercisesWithHistory(response: Response): Promise<ExerciseHistoryEntry[]> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ExerciseHistoryEntry.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ExerciseHistoryEntry[]>(null as any);
    }
}

export class TrainingRecommendationClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getProgramRecommendations(): Promise<{ [key: string]: ProgramOverviewDto[]; }> {
        let url_ = this.baseUrl + "/api/TrainingRecommendation/programs-recommendation/user";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProgramRecommendations(_response);
        });
    }

    protected processGetProgramRecommendations(response: Response): Promise<{ [key: string]: ProgramOverviewDto[]; }> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)![key] = resultData200[key] ? resultData200[key].map((i: any) => ProgramOverviewDto.fromJS(i)) : [];
                }
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<{ [key: string]: ProgramOverviewDto[]; }>(null as any);
    }

    getWorkoutRecommendation(): Promise<ExerciseDTO[]> {
        let url_ = this.baseUrl + "/api/TrainingRecommendation/workout-recommendation/user";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetWorkoutRecommendation(_response);
        });
    }

    protected processGetWorkoutRecommendation(response: Response): Promise<ExerciseDTO[]> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ExerciseDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ExerciseDTO[]>(null as any);
    }
}

export class TrainingSurveyClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    createTrainingSurvey(command: CreateSurveyAnswerCommand): Promise<Result> {
        let url_ = this.baseUrl + "/api/TrainingSurvey/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateTrainingSurvey(_response);
        });
    }

    protected processCreateTrainingSurvey(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    updateTrainingSurvey(id: number, command: UpdateTrainingSurveyAnswersCommand): Promise<Result> {
        let url_ = this.baseUrl + "/api/TrainingSurvey/update/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateTrainingSurvey(_response);
        });
    }

    protected processUpdateTrainingSurvey(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    getUserTrainingSurveyAnswer(userId: string | null): Promise<SurveyAnswer> {
        let url_ = this.baseUrl + "/api/TrainingSurvey/user?";
        if (userId === undefined)
            throw new Error("The parameter 'userId' must be defined.");
        else if(userId !== null)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUserTrainingSurveyAnswer(_response);
        });
    }

    protected processGetUserTrainingSurveyAnswer(response: Response): Promise<SurveyAnswer> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SurveyAnswer.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SurveyAnswer>(null as any);
    }
}

export class WorkoutLogClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getWorkoutLogsWithPagination(pageNumber: number, pageSize: number): Promise<PaginatedListOfWorkoutLogDTO> {
        let url_ = this.baseUrl + "/api/WorkoutLog/get-all?";
        if (pageNumber === undefined || pageNumber === null)
            throw new Error("The parameter 'pageNumber' must be defined and cannot be null.");
        else
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === undefined || pageSize === null)
            throw new Error("The parameter 'pageSize' must be defined and cannot be null.");
        else
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetWorkoutLogsWithPagination(_response);
        });
    }

    protected processGetWorkoutLogsWithPagination(response: Response): Promise<PaginatedListOfWorkoutLogDTO> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfWorkoutLogDTO.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PaginatedListOfWorkoutLogDTO>(null as any);
    }

    getWorkoutHistory(startDate: string, endDate: string): Promise<WorkoutLogDTO[]> {
        let url_ = this.baseUrl + "/api/WorkoutLog/history?";
        if (startDate === undefined || startDate === null)
            throw new Error("The parameter 'startDate' must be defined and cannot be null.");
        else
            url_ += "StartDate=" + encodeURIComponent("" + startDate) + "&";
        if (endDate === undefined || endDate === null)
            throw new Error("The parameter 'endDate' must be defined and cannot be null.");
        else
            url_ += "EndDate=" + encodeURIComponent("" + endDate) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetWorkoutHistory(_response);
        });
    }

    protected processGetWorkoutHistory(response: Response): Promise<WorkoutLogDTO[]> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WorkoutLogDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WorkoutLogDTO[]>(null as any);
    }

    getWorkoutLogDetails(workoutLogId: number): Promise<WorkoutLogDetailsDto> {
        let url_ = this.baseUrl + "/api/WorkoutLog/{WorkoutLogId}";
        if (workoutLogId === undefined || workoutLogId === null)
            throw new Error("The parameter 'workoutLogId' must be defined.");
        url_ = url_.replace("{WorkoutLogId}", encodeURIComponent("" + workoutLogId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetWorkoutLogDetails(_response);
        });
    }

    protected processGetWorkoutLogDetails(response: Response): Promise<WorkoutLogDetailsDto> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkoutLogDetailsDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WorkoutLogDetailsDto>(null as any);
    }

    createWorkoutLog(commandDTO: CreateWorkoutLogCommandDTO): Promise<Result> {
        let url_ = this.baseUrl + "/api/WorkoutLog";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(commandDTO);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateWorkoutLog(_response);
        });
    }

    protected processCreateWorkoutLog(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    updateWorkoutLog(id: number, command: UpdateWorkoutLogCommand): Promise<Result> {
        let url_ = this.baseUrl + "/api/WorkoutLog/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateWorkoutLog(_response);
        });
    }

    protected processUpdateWorkoutLog(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    deleteWorkoutLog(id: number, command: DeleteWorkoutLogCommand): Promise<Result> {
        let url_ = this.baseUrl + "/api/WorkoutLog/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteWorkoutLog(_response);
        });
    }

    protected processDeleteWorkoutLog(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    exportWorkotuData(userId: string | null, startDate: Date | null | undefined, endDate: Date | null | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/WorkoutLog/export?";
        if (userId === undefined)
            throw new Error("The parameter 'userId' must be defined.");
        else if(userId !== null)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (startDate !== undefined && startDate !== null)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate !== undefined && endDate !== null)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processExportWorkotuData(_response);
        });
    }

    protected processExportWorkotuData(response: Response): Promise<string> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }
}

export class WorkoutProgramsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getWorkoutProgramDetails(id: number): Promise<void> {
        let url_ = this.baseUrl + "/api/WorkoutPrograms/details/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetWorkoutProgramDetails(_response);
        });
    }

    protected processGetWorkoutProgramDetails(response: Response): Promise<void> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getWorkoutProgramsList(): Promise<WorkoutProgramListDTO[]> {
        let url_ = this.baseUrl + "/api/WorkoutPrograms";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetWorkoutProgramsList(_response);
        });
    }

    protected processGetWorkoutProgramsList(response: Response): Promise<WorkoutProgramListDTO[]> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WorkoutProgramListDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WorkoutProgramListDTO[]>(null as any);
    }

    createWorkoutProgram(command: CreateWorkoutProgramCommand): Promise<Result> {
        let url_ = this.baseUrl + "/api/WorkoutPrograms";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateWorkoutProgram(_response);
        });
    }

    protected processCreateWorkoutProgram(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    getEnrollmentsByUser(): Promise<ProgramEnrollmentDTO[]> {
        let url_ = this.baseUrl + "/api/WorkoutPrograms/enrollments/user";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEnrollmentsByUser(_response);
        });
    }

    protected processGetEnrollmentsByUser(response: Response): Promise<ProgramEnrollmentDTO[]> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProgramEnrollmentDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProgramEnrollmentDTO[]>(null as any);
    }

    updateWorkoutProgram(id: number, command: UpdateWorkoutProgramCommand): Promise<void> {
        let url_ = this.baseUrl + "/api/WorkoutPrograms/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateWorkoutProgram(_response);
        });
    }

    protected processUpdateWorkoutProgram(response: Response): Promise<void> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    deleteWorkoutProgram(id: number): Promise<void> {
        let url_ = this.baseUrl + "/api/WorkoutPrograms/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteWorkoutProgram(_response);
        });
    }

    protected processDeleteWorkoutProgram(response: Response): Promise<void> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    enrollProgram(id: number, command: EnrollProgramCommand): Promise<Result> {
        let url_ = this.baseUrl + "/api/WorkoutPrograms/{id}/enrollment";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEnrollProgram(_response);
        });
    }

    protected processEnrollProgram(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    updateEnrollmentProgress(id: number, enrollmentId: string, command: UpdateEnrollmentProgressCommand): Promise<Result> {
        let url_ = this.baseUrl + "/api/WorkoutPrograms/{id}/enrollment/{enrollmentId}/progress";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (enrollmentId === undefined || enrollmentId === null)
            throw new Error("The parameter 'enrollmentId' must be defined.");
        url_ = url_.replace("{enrollmentId}", encodeURIComponent("" + enrollmentId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateEnrollmentProgress(_response);
        });
    }

    protected processUpdateEnrollmentProgress(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    updateEnrollmentCurrentWorkout(id: number, enrollmentId: string, command: UpdateEnrollmentCurrentWorkoutCommand): Promise<Result> {
        let url_ = this.baseUrl + "/api/WorkoutPrograms/{id}/enrollment/{enrollmentId}/current-workout";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (enrollmentId === undefined || enrollmentId === null)
            throw new Error("The parameter 'enrollmentId' must be defined.");
        url_ = url_.replace("{enrollmentId}", encodeURIComponent("" + enrollmentId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateEnrollmentCurrentWorkout(_response);
        });
    }

    protected processUpdateEnrollmentCurrentWorkout(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    updateEnrollmentStatus(id: number, enrollmentId: string, command: UpdateEnrollmentStatusCommand): Promise<Result> {
        let url_ = this.baseUrl + "/api/WorkoutPrograms/{id}/enrollment/{enrollmentId}/status";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (enrollmentId === undefined || enrollmentId === null)
            throw new Error("The parameter 'enrollmentId' must be defined.");
        url_ = url_.replace("{enrollmentId}", encodeURIComponent("" + enrollmentId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateEnrollmentStatus(_response);
        });
    }

    protected processUpdateEnrollmentStatus(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }
}

export class WorkoutTemplatesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    createPersonalTemplate(command: CreatePersonalTemplateCommand): Promise<Result> {
        let url_ = this.baseUrl + "/api/WorkoutTemplates/create-personal-template";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreatePersonalTemplate(_response);
        });
    }

    protected processCreatePersonalTemplate(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    createWorkoutTemplate(command: CreateWorkoutTemplateCommand): Promise<Result> {
        let url_ = this.baseUrl + "/api/WorkoutTemplates/create-workout-template";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateWorkoutTemplate(_response);
        });
    }

    protected processCreateWorkoutTemplate(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    updateWorkoutTemplate(id: number, command: UpdateWorkoutTemplateCommand): Promise<Result> {
        let url_ = this.baseUrl + "/api/WorkoutTemplates/update-workout-template/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateWorkoutTemplate(_response);
        });
    }

    protected processUpdateWorkoutTemplate(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    deleteWorkoutTemplate(id: number): Promise<Result> {
        let url_ = this.baseUrl + "/api/WorkoutTemplates/delete-workout-template/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteWorkoutTemplate(_response);
        });
    }

    protected processDeleteWorkoutTemplate(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    getPublicTemplates(pageNumber: number, pageSize: number): Promise<PaginatedListOfWorkoutTemplateListDto> {
        let url_ = this.baseUrl + "/api/WorkoutTemplates/public-templates?";
        if (pageNumber === undefined || pageNumber === null)
            throw new Error("The parameter 'pageNumber' must be defined and cannot be null.");
        else
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === undefined || pageSize === null)
            throw new Error("The parameter 'pageSize' must be defined and cannot be null.");
        else
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPublicTemplates(_response);
        });
    }

    protected processGetPublicTemplates(response: Response): Promise<PaginatedListOfWorkoutTemplateListDto> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfWorkoutTemplateListDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PaginatedListOfWorkoutTemplateListDto>(null as any);
    }

    getPersonalTemplates(pageNumber: number, pageSize: number): Promise<PaginatedListOfWorkoutTemplateListDto> {
        let url_ = this.baseUrl + "/api/WorkoutTemplates/personal-templates?";
        if (pageNumber === undefined || pageNumber === null)
            throw new Error("The parameter 'pageNumber' must be defined and cannot be null.");
        else
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === undefined || pageSize === null)
            throw new Error("The parameter 'pageSize' must be defined and cannot be null.");
        else
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPersonalTemplates(_response);
        });
    }

    protected processGetPersonalTemplates(response: Response): Promise<PaginatedListOfWorkoutTemplateListDto> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfWorkoutTemplateListDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PaginatedListOfWorkoutTemplateListDto>(null as any);
    }

    getWorkoutTemplateDetails(id: number): Promise<WorkoutTemplateDetailsDto> {
        let url_ = this.baseUrl + "/api/WorkoutTemplates/get-workout-template-details/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetWorkoutTemplateDetails(_response);
        });
    }

    protected processGetWorkoutTemplateDetails(response: Response): Promise<WorkoutTemplateDetailsDto> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkoutTemplateDetailsDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WorkoutTemplateDetailsDto>(null as any);
    }

    filterWorkoutTemplates(templateName: string | null, creatorName: string | null | undefined, minDuration: string | null | undefined, maxDuration: string | null | undefined, pageNumber: number, pageSize: number): Promise<PaginatedListOfWorkoutTemplateListDto> {
        let url_ = this.baseUrl + "/api/WorkoutTemplates/filter-workout-templates?";
        if (templateName === undefined)
            throw new Error("The parameter 'templateName' must be defined.");
        else if(templateName !== null)
            url_ += "TemplateName=" + encodeURIComponent("" + templateName) + "&";
        if (creatorName !== undefined && creatorName !== null)
            url_ += "CreatorName=" + encodeURIComponent("" + creatorName) + "&";
        if (minDuration !== undefined && minDuration !== null)
            url_ += "MinDuration=" + encodeURIComponent("" + minDuration) + "&";
        if (maxDuration !== undefined && maxDuration !== null)
            url_ += "MaxDuration=" + encodeURIComponent("" + maxDuration) + "&";
        if (pageNumber === undefined || pageNumber === null)
            throw new Error("The parameter 'pageNumber' must be defined and cannot be null.");
        else
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === undefined || pageSize === null)
            throw new Error("The parameter 'pageSize' must be defined and cannot be null.");
        else
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFilterWorkoutTemplates(_response);
        });
    }

    protected processFilterWorkoutTemplates(response: Response): Promise<PaginatedListOfWorkoutTemplateListDto> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfWorkoutTemplateListDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PaginatedListOfWorkoutTemplateListDto>(null as any);
    }
}

export class AuthenticationClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    passwordLogin(query: LoginQuery): Promise<LoginResultDTO> {
        let url_ = this.baseUrl + "/api/Authentication/password-login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPasswordLogin(_response);
        });
    }

    protected processPasswordLogin(response: Response): Promise<LoginResultDTO> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoginResultDTO.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LoginResultDTO>(null as any);
    }

    signInWithGoogle(request: GoogleLoginRequest): Promise<string> {
        let url_ = this.baseUrl + "/api/Authentication/google-login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSignInWithGoogle(_response);
        });
    }

    protected processSignInWithGoogle(response: Response): Promise<string> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    signInWithFacebook(request: FacebookLoginRequest): Promise<string> {
        let url_ = this.baseUrl + "/api/Authentication/facebook-login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSignInWithFacebook(_response);
        });
    }

    protected processSignInWithFacebook(response: Response): Promise<string> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }
}

export class RolesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getRolesList(): Promise<RoleDto[]> {
        let url_ = this.baseUrl + "/api/Roles";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRolesList(_response);
        });
    }

    protected processGetRolesList(response: Response): Promise<RoleDto[]> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RoleDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RoleDto[]>(null as any);
    }

    createRole(command: AddRoleCommand): Promise<Result> {
        let url_ = this.baseUrl + "/api/Roles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateRole(_response);
        });
    }

    protected processCreateRole(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    getRoleById(id: string): Promise<RoleDto> {
        let url_ = this.baseUrl + "/api/Roles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRoleById(_response);
        });
    }

    protected processGetRoleById(response: Response): Promise<RoleDto> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RoleDto>(null as any);
    }

    updateRole(id: string, command: UpdateRoleCommand): Promise<Result> {
        let url_ = this.baseUrl + "/api/Roles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateRole(_response);
        });
    }

    protected processUpdateRole(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    deleteRole(id: number, command: DeleteRoleCommand): Promise<Result> {
        let url_ = this.baseUrl + "/api/Roles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteRole(_response);
        });
    }

    protected processDeleteRole(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }
}

export class UsersClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    register(command: RegisterCommand): Promise<Result> {
        let url_ = this.baseUrl + "/api/Users/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRegister(_response);
        });
    }

    protected processRegister(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    confirmEmail(command: ConfirmEmailCommand): Promise<Result> {
        let url_ = this.baseUrl + "/api/Users/confirm-email";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processConfirmEmail(_response);
        });
    }

    protected processConfirmEmail(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    recoverAccount(command: RecoverAccountCommand): Promise<Result> {
        let url_ = this.baseUrl + "/api/Users/recover-account";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRecoverAccount(_response);
        });
    }

    protected processRecoverAccount(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    resetPassword(command: ResetPasswordCommand): Promise<Result> {
        let url_ = this.baseUrl + "/api/Users/reset-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processResetPassword(_response);
        });
    }

    protected processResetPassword(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    getUserProfile(): Promise<UserProfileDTO> {
        let url_ = this.baseUrl + "/api/Users/user-profile";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUserProfile(_response);
        });
    }

    protected processGetUserProfile(response: Response): Promise<UserProfileDTO> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserProfileDTO.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserProfileDTO>(null as any);
    }

    authenticatedResetPassword(command: AuthenticatedResetPasswordCommandDto): Promise<Result> {
        let url_ = this.baseUrl + "/api/Users/authenticated-reset-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAuthenticatedResetPassword(_response);
        });
    }

    protected processAuthenticatedResetPassword(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    updateUserProfile(command: UpdateUserCommand): Promise<Result> {
        let url_ = this.baseUrl + "/api/Users/update-profile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateUserProfile(_response);
        });
    }

    protected processUpdateUserProfile(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    getUserList(pageNumber: number, pageSize: number): Promise<PaginatedListOfUserListDTO> {
        let url_ = this.baseUrl + "/api/Users/all?";
        if (pageNumber === undefined || pageNumber === null)
            throw new Error("The parameter 'pageNumber' must be defined and cannot be null.");
        else
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === undefined || pageSize === null)
            throw new Error("The parameter 'pageSize' must be defined and cannot be null.");
        else
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUserList(_response);
        });
    }

    protected processGetUserList(response: Response): Promise<PaginatedListOfUserListDTO> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfUserListDTO.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PaginatedListOfUserListDTO>(null as any);
    }

    searchUsers(email: string | null | undefined, username: string | null | undefined, externalProvider: string | null | undefined, roles: string | null | undefined): Promise<PaginatedListOfUserListDTO> {
        let url_ = this.baseUrl + "/api/Users/search?";
        if (email !== undefined && email !== null)
            url_ += "email=" + encodeURIComponent("" + email) + "&";
        if (username !== undefined && username !== null)
            url_ += "username=" + encodeURIComponent("" + username) + "&";
        if (externalProvider !== undefined && externalProvider !== null)
            url_ += "externalProvider=" + encodeURIComponent("" + externalProvider) + "&";
        if (roles !== undefined && roles !== null)
            url_ += "roles=" + encodeURIComponent("" + roles) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearchUsers(_response);
        });
    }

    protected processSearchUsers(response: Response): Promise<PaginatedListOfUserListDTO> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfUserListDTO.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PaginatedListOfUserListDTO>(null as any);
    }

    searchUsersByEmail(email: string | null): Promise<(UserListDTO | undefined)[]> {
        let url_ = this.baseUrl + "/api/Users/search-by-email?";
        if (email === undefined)
            throw new Error("The parameter 'email' must be defined.");
        else if(email !== null)
            url_ += "Email=" + encodeURIComponent("" + email) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearchUsersByEmail(_response);
        });
    }

    protected processSearchUsersByEmail(response: Response): Promise<(UserListDTO | undefined)[]> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserListDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<(UserListDTO | undefined)[]>(null as any);
    }

    searchUsersByLoginProvider(provider: string | null): Promise<(UserListDTO | undefined)[]> {
        let url_ = this.baseUrl + "/api/Users/search-by-provider?";
        if (provider === undefined)
            throw new Error("The parameter 'provider' must be defined.");
        else if(provider !== null)
            url_ += "Provider=" + encodeURIComponent("" + provider) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearchUsersByLoginProvider(_response);
        });
    }

    protected processSearchUsersByLoginProvider(response: Response): Promise<(UserListDTO | undefined)[]> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserListDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<(UserListDTO | undefined)[]>(null as any);
    }

    searchUsersByUserName(username: string | null): Promise<(UserListDTO | undefined)[]> {
        let url_ = this.baseUrl + "/api/Users/search-by-username?";
        if (username === undefined)
            throw new Error("The parameter 'username' must be defined.");
        else if(username !== null)
            url_ += "Username=" + encodeURIComponent("" + username) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearchUsersByUserName(_response);
        });
    }

    protected processSearchUsersByUserName(response: Response): Promise<(UserListDTO | undefined)[]> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserListDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<(UserListDTO | undefined)[]>(null as any);
    }

    getUsersByRole(roles: string | null): Promise<UserListDTO[]> {
        let url_ = this.baseUrl + "/api/Users/get-by-roles?";
        if (roles === undefined)
            throw new Error("The parameter 'roles' must be defined.");
        else if(roles !== null)
            url_ += "Roles=" + encodeURIComponent("" + roles) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUsersByRole(_response);
        });
    }

    protected processGetUsersByRole(response: Response): Promise<UserListDTO[]> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserListDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserListDTO[]>(null as any);
    }

    createUser(command: CreateUserCommand): Promise<Result> {
        let url_ = this.baseUrl + "/api/Users/create-account";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateUser(_response);
        });
    }

    protected processCreateUser(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    deleteAccount(id: string): Promise<Result> {
        let url_ = this.baseUrl + "/api/Users/delete-account/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteAccount(_response);
        });
    }

    protected processDeleteAccount(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    getCoachesList(pageNumber: number, pageSize: number): Promise<PaginatedListOfCoachSummaryDTO> {
        let url_ = this.baseUrl + "/api/Users/coaches/coaches?";
        if (pageNumber === undefined || pageNumber === null)
            throw new Error("The parameter 'pageNumber' must be defined and cannot be null.");
        else
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === undefined || pageSize === null)
            throw new Error("The parameter 'pageSize' must be defined and cannot be null.");
        else
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCoachesList(_response);
        });
    }

    protected processGetCoachesList(response: Response): Promise<PaginatedListOfCoachSummaryDTO> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfCoachSummaryDTO.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PaginatedListOfCoachSummaryDTO>(null as any);
    }
}

export class CoachingServicesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getCoachingServiceDetails(id: number): Promise<CoachingServiceDetailsDto> {
        let url_ = this.baseUrl + "/api/CoachingServices/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCoachingServiceDetails(_response);
        });
    }

    protected processGetCoachingServiceDetails(response: Response): Promise<CoachingServiceDetailsDto> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CoachingServiceDetailsDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CoachingServiceDetailsDto>(null as any);
    }

    updateCoachingService(id: number, command: UpdateCoachingServiceCommand): Promise<Result> {
        let url_ = this.baseUrl + "/api/CoachingServices/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateCoachingService(_response);
        });
    }

    protected processUpdateCoachingService(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    deleteCoachingService(id: number): Promise<Result> {
        let url_ = this.baseUrl + "/api/CoachingServices/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteCoachingService(_response);
        });
    }

    protected processDeleteCoachingService(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    getPaginatedCoachingServices(pageNumber: number, pageSize: number): Promise<PaginatedListOfCoachingServiceDTO> {
        let url_ = this.baseUrl + "/api/CoachingServices?";
        if (pageNumber === undefined || pageNumber === null)
            throw new Error("The parameter 'pageNumber' must be defined and cannot be null.");
        else
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === undefined || pageSize === null)
            throw new Error("The parameter 'pageSize' must be defined and cannot be null.");
        else
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPaginatedCoachingServices(_response);
        });
    }

    protected processGetPaginatedCoachingServices(response: Response): Promise<PaginatedListOfCoachingServiceDTO> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfCoachingServiceDTO.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PaginatedListOfCoachingServiceDTO>(null as any);
    }

    createCoachingService(command: CreateCoachingServiceCommand): Promise<Result> {
        let url_ = this.baseUrl + "/api/CoachingServices";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateCoachingService(_response);
        });
    }

    protected processCreateCoachingService(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    getPaginatedCoachingServicesOfUser(userIdPath: string, pageNumber: number, pageSize: number): Promise<PaginatedListOfCoachingServiceDTO> {
        let url_ = this.baseUrl + "/api/CoachingServices/user/{userId}?";
        if (userIdPath === undefined || userIdPath === null)
            throw new Error("The parameter 'userIdPath' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userIdPath));
        if (pageNumber === undefined || pageNumber === null)
            throw new Error("The parameter 'pageNumber' must be defined and cannot be null.");
        else
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === undefined || pageSize === null)
            throw new Error("The parameter 'pageSize' must be defined and cannot be null.");
        else
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPaginatedCoachingServicesOfUser(_response);
        });
    }

    protected processGetPaginatedCoachingServicesOfUser(response: Response): Promise<PaginatedListOfCoachingServiceDTO> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfCoachingServiceDTO.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PaginatedListOfCoachingServiceDTO>(null as any);
    }

    updateBookingStatus(id: number, command: UpdateBookingStatusCommand): Promise<Result> {
        let url_ = this.baseUrl + "/api/CoachingServices/booking/{id}/status";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateBookingStatus(_response);
        });
    }

    protected processUpdateBookingStatus(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    bookService(id: number, command: BookServiceCommand): Promise<Result> {
        let url_ = this.baseUrl + "/api/CoachingServices/book/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBookService(_response);
        });
    }

    protected processBookService(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    getBookingDetails(id: number): Promise<any> {
        let url_ = this.baseUrl + "/api/CoachingServices/booking/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetBookingDetails(_response);
        });
    }

    protected processGetBookingDetails(response: Response): Promise<any> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }

    getServiceBookings(serviceId: number): Promise<any> {
        let url_ = this.baseUrl + "/api/CoachingServices/service/{serviceId}/bookings";
        if (serviceId === undefined || serviceId === null)
            throw new Error("The parameter 'serviceId' must be defined.");
        url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetServiceBookings(_response);
        });
    }

    protected processGetServiceBookings(response: Response): Promise<any> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }
}

export class CoachProfileClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getCertificationById(userId: string, id: number): Promise<CertificationDTO> {
        let url_ = this.baseUrl + "/api/CoachProfile/{userId}/certifications/{id}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCertificationById(_response);
        });
    }

    protected processGetCertificationById(response: Response): Promise<CertificationDTO> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CertificationDTO.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CertificationDTO>(null as any);
    }

    getCoachProfileDetails(id: string): Promise<any> {
        let url_ = this.baseUrl + "/api/CoachProfile/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCoachProfileDetails(_response);
        });
    }

    protected processGetCoachProfileDetails(response: Response): Promise<any> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }

    updateCoachProfileDetails(id: string, request: UpdateCoachProfileCommand): Promise<Result> {
        let url_ = this.baseUrl + "/api/CoachProfile/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateCoachProfileDetails(_response);
        });
    }

    protected processUpdateCoachProfileDetails(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    getCertificationsByUserId(userId: string): Promise<CertificationDTO[]> {
        let url_ = this.baseUrl + "/api/CoachProfile/certifications/user/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCertificationsByUserId(_response);
        });
    }

    protected processGetCertificationsByUserId(response: Response): Promise<CertificationDTO[]> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CertificationDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CertificationDTO[]>(null as any);
    }

    createCoachApplication(request: CreateCoachApplicationQuery): Promise<Result> {
        let url_ = this.baseUrl + "/api/CoachProfile/apply-coach";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateCoachApplication(_response);
        });
    }

    protected processCreateCoachApplication(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    updateCoachApplication(id: string, request: UpdateCoachApplicationStatusCommand): Promise<Result> {
        let url_ = this.baseUrl + "/api/CoachProfile/update-application?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateCoachApplication(_response);
        });
    }

    protected processUpdateCoachApplication(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    createCertification(command: CreateCertificationCommand): Promise<Result> {
        let url_ = this.baseUrl + "/api/CoachProfile/certifications";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateCertification(_response);
        });
    }

    protected processCreateCertification(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    updateCertification(id: number, command: UpdateCertificationCommand): Promise<Result> {
        let url_ = this.baseUrl + "/api/CoachProfile/certifications/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateCertification(_response);
        });
    }

    protected processUpdateCertification(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    deleteCertification(id: number): Promise<Result> {
        let url_ = this.baseUrl + "/api/CoachProfile/certifications/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteCertification(_response);
        });
    }

    protected processDeleteCertification(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    getApplicationsWithPagination(pageNumber: number, pageSize: number): Promise<PaginatedListOfCoachApplicationDto> {
        let url_ = this.baseUrl + "/api/CoachProfile/paginated-list?";
        if (pageNumber === undefined || pageNumber === null)
            throw new Error("The parameter 'pageNumber' must be defined and cannot be null.");
        else
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === undefined || pageSize === null)
            throw new Error("The parameter 'pageSize' must be defined and cannot be null.");
        else
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetApplicationsWithPagination(_response);
        });
    }

    protected processGetApplicationsWithPagination(response: Response): Promise<PaginatedListOfCoachApplicationDto> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfCoachApplicationDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PaginatedListOfCoachApplicationDto>(null as any);
    }
}

export class ChatsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getUserChatList(userId: string | null): Promise<Chat[]> {
        let url_ = this.baseUrl + "/api/Chats/user?";
        if (userId === undefined)
            throw new Error("The parameter 'userId' must be defined.");
        else if(userId !== null)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUserChatList(_response);
        });
    }

    protected processGetUserChatList(response: Response): Promise<Chat[]> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Chat.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Chat[]>(null as any);
    }

    createChat(command: CreateChatCommand): Promise<Result> {
        let url_ = this.baseUrl + "/api/Chats/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateChat(_response);
        });
    }

    protected processCreateChat(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }
}

export class PaginatedListOfTodoItemBriefDto implements IPaginatedListOfTodoItemBriefDto {
    items?: TodoItemBriefDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfTodoItemBriefDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TodoItemBriefDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfTodoItemBriefDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfTodoItemBriefDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfTodoItemBriefDto {
    items?: TodoItemBriefDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class TodoItemBriefDto implements ITodoItemBriefDto {
    id?: number;
    listId?: number;
    title?: string | undefined;
    done?: boolean;

    constructor(data?: ITodoItemBriefDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.listId = _data["listId"];
            this.title = _data["title"];
            this.done = _data["done"];
        }
    }

    static fromJS(data: any): TodoItemBriefDto {
        data = typeof data === 'object' ? data : {};
        let result = new TodoItemBriefDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["listId"] = this.listId;
        data["title"] = this.title;
        data["done"] = this.done;
        return data;
    }
}

export interface ITodoItemBriefDto {
    id?: number;
    listId?: number;
    title?: string | undefined;
    done?: boolean;
}

export class CreateTodoItemCommand implements ICreateTodoItemCommand {
    listId?: number;
    title?: string | undefined;

    constructor(data?: ICreateTodoItemCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.listId = _data["listId"];
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): CreateTodoItemCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTodoItemCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["listId"] = this.listId;
        data["title"] = this.title;
        return data;
    }
}

export interface ICreateTodoItemCommand {
    listId?: number;
    title?: string | undefined;
}

export class UpdateTodoItemCommand implements IUpdateTodoItemCommand {
    id?: number;
    title?: string | undefined;
    done?: boolean;

    constructor(data?: IUpdateTodoItemCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.done = _data["done"];
        }
    }

    static fromJS(data: any): UpdateTodoItemCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTodoItemCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["done"] = this.done;
        return data;
    }
}

export interface IUpdateTodoItemCommand {
    id?: number;
    title?: string | undefined;
    done?: boolean;
}

export class UpdateTodoItemDetailCommand implements IUpdateTodoItemDetailCommand {
    id?: number;
    listId?: number;
    priority?: PriorityLevel;
    note?: string | undefined;

    constructor(data?: IUpdateTodoItemDetailCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.listId = _data["listId"];
            this.priority = _data["priority"];
            this.note = _data["note"];
        }
    }

    static fromJS(data: any): UpdateTodoItemDetailCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTodoItemDetailCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["listId"] = this.listId;
        data["priority"] = this.priority;
        data["note"] = this.note;
        return data;
    }
}

export interface IUpdateTodoItemDetailCommand {
    id?: number;
    listId?: number;
    priority?: PriorityLevel;
    note?: string | undefined;
}

export enum PriorityLevel {
    None = 0,
    Low = 1,
    Medium = 2,
    High = 3,
}

export class TodosVm implements ITodosVm {
    priorityLevels?: LookupDto[];
    lists?: TodoListDto[];

    constructor(data?: ITodosVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["priorityLevels"])) {
                this.priorityLevels = [] as any;
                for (let item of _data["priorityLevels"])
                    this.priorityLevels!.push(LookupDto.fromJS(item));
            }
            if (Array.isArray(_data["lists"])) {
                this.lists = [] as any;
                for (let item of _data["lists"])
                    this.lists!.push(TodoListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TodosVm {
        data = typeof data === 'object' ? data : {};
        let result = new TodosVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.priorityLevels)) {
            data["priorityLevels"] = [];
            for (let item of this.priorityLevels)
                data["priorityLevels"].push(item.toJSON());
        }
        if (Array.isArray(this.lists)) {
            data["lists"] = [];
            for (let item of this.lists)
                data["lists"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITodosVm {
    priorityLevels?: LookupDto[];
    lists?: TodoListDto[];
}

export class LookupDto implements ILookupDto {
    id?: number;
    title?: string | undefined;

    constructor(data?: ILookupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): LookupDto {
        data = typeof data === 'object' ? data : {};
        let result = new LookupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        return data;
    }
}

export interface ILookupDto {
    id?: number;
    title?: string | undefined;
}

export class TodoListDto implements ITodoListDto {
    id?: number;
    title?: string | undefined;
    colour?: string | undefined;
    items?: TodoItemDto[];

    constructor(data?: ITodoListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.colour = _data["colour"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TodoItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TodoListDto {
        data = typeof data === 'object' ? data : {};
        let result = new TodoListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["colour"] = this.colour;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITodoListDto {
    id?: number;
    title?: string | undefined;
    colour?: string | undefined;
    items?: TodoItemDto[];
}

export class TodoItemDto implements ITodoItemDto {
    id?: number;
    listId?: number;
    title?: string | undefined;
    done?: boolean;
    priority?: number;
    note?: string | undefined;

    constructor(data?: ITodoItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.listId = _data["listId"];
            this.title = _data["title"];
            this.done = _data["done"];
            this.priority = _data["priority"];
            this.note = _data["note"];
        }
    }

    static fromJS(data: any): TodoItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new TodoItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["listId"] = this.listId;
        data["title"] = this.title;
        data["done"] = this.done;
        data["priority"] = this.priority;
        data["note"] = this.note;
        return data;
    }
}

export interface ITodoItemDto {
    id?: number;
    listId?: number;
    title?: string | undefined;
    done?: boolean;
    priority?: number;
    note?: string | undefined;
}

export class CreateTodoListCommand implements ICreateTodoListCommand {
    title?: string | undefined;

    constructor(data?: ICreateTodoListCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): CreateTodoListCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTodoListCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        return data;
    }
}

export interface ICreateTodoListCommand {
    title?: string | undefined;
}

export class UpdateTodoListCommand implements IUpdateTodoListCommand {
    id?: number;
    title?: string | undefined;

    constructor(data?: IUpdateTodoListCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): UpdateTodoListCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTodoListCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        return data;
    }
}

export interface IUpdateTodoListCommand {
    id?: number;
    title?: string | undefined;
}

export class WeatherForecast implements IWeatherForecast {
    date?: Date;
    temperatureC?: number;
    temperatureF?: number;
    summary?: string | undefined;

    constructor(data?: IWeatherForecast) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.temperatureC = _data["temperatureC"];
            this.temperatureF = _data["temperatureF"];
            this.summary = _data["summary"];
        }
    }

    static fromJS(data: any): WeatherForecast {
        data = typeof data === 'object' ? data : {};
        let result = new WeatherForecast();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["temperatureC"] = this.temperatureC;
        data["temperatureF"] = this.temperatureF;
        data["summary"] = this.summary;
        return data;
    }
}

export interface IWeatherForecast {
    date?: Date;
    temperatureC?: number;
    temperatureF?: number;
    summary?: string | undefined;
}

export class PaginatedListOfEquipmentDetailsDTO implements IPaginatedListOfEquipmentDetailsDTO {
    items?: EquipmentDetailsDTO[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfEquipmentDetailsDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(EquipmentDetailsDTO.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfEquipmentDetailsDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfEquipmentDetailsDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfEquipmentDetailsDTO {
    items?: EquipmentDetailsDTO[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class EquipmentDetailsDTO implements IEquipmentDetailsDTO {
    equipmentId?: number;
    equipmentName?: string | undefined;
    imageUrl?: string | undefined;

    constructor(data?: IEquipmentDetailsDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.equipmentId = _data["equipmentId"];
            this.equipmentName = _data["equipmentName"];
            this.imageUrl = _data["imageUrl"];
        }
    }

    static fromJS(data: any): EquipmentDetailsDTO {
        data = typeof data === 'object' ? data : {};
        let result = new EquipmentDetailsDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["equipmentId"] = this.equipmentId;
        data["equipmentName"] = this.equipmentName;
        data["imageUrl"] = this.imageUrl;
        return data;
    }
}

export interface IEquipmentDetailsDTO {
    equipmentId?: number;
    equipmentName?: string | undefined;
    imageUrl?: string | undefined;
}

export class Result implements IResult {
    success?: boolean;
    errors?: string[];

    constructor(data?: IResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): Result {
        data = typeof data === 'object' ? data : {};
        let result = new Result();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResult {
    success?: boolean;
    errors?: string[];
}

export class CreateEquipmentCommand implements ICreateEquipmentCommand {
    equipmentName?: string | undefined;
    imageUrl?: string | undefined;

    constructor(data?: ICreateEquipmentCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.equipmentName = _data["equipmentName"];
            this.imageUrl = _data["imageUrl"];
        }
    }

    static fromJS(data: any): CreateEquipmentCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateEquipmentCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["equipmentName"] = this.equipmentName;
        data["imageUrl"] = this.imageUrl;
        return data;
    }
}

export interface ICreateEquipmentCommand {
    equipmentName?: string | undefined;
    imageUrl?: string | undefined;
}

export class UpdateEquipmentCommand implements IUpdateEquipmentCommand {
    equipmentId?: number;
    equipmentName?: string | undefined;
    imageUrl?: string | undefined;

    constructor(data?: IUpdateEquipmentCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.equipmentId = _data["equipmentId"];
            this.equipmentName = _data["equipmentName"];
            this.imageUrl = _data["imageUrl"];
        }
    }

    static fromJS(data: any): UpdateEquipmentCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateEquipmentCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["equipmentId"] = this.equipmentId;
        data["equipmentName"] = this.equipmentName;
        data["imageUrl"] = this.imageUrl;
        return data;
    }
}

export interface IUpdateEquipmentCommand {
    equipmentId?: number;
    equipmentName?: string | undefined;
    imageUrl?: string | undefined;
}

export class DeleteEquipmentCommand implements IDeleteEquipmentCommand {
    equipmentId?: number;

    constructor(data?: IDeleteEquipmentCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.equipmentId = _data["equipmentId"];
        }
    }

    static fromJS(data: any): DeleteEquipmentCommand {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteEquipmentCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["equipmentId"] = this.equipmentId;
        return data;
    }
}

export interface IDeleteEquipmentCommand {
    equipmentId?: number;
}

export class PaginatedListOfExerciseDTO implements IPaginatedListOfExerciseDTO {
    items?: ExerciseDTO[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfExerciseDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ExerciseDTO.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfExerciseDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfExerciseDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfExerciseDTO {
    items?: ExerciseDTO[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class ExerciseDTO implements IExerciseDTO {
    exerciseId?: number;
    exerciseName?: string | undefined;
    type?: string;

    constructor(data?: IExerciseDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.exerciseId = _data["exerciseId"];
            this.exerciseName = _data["exerciseName"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): ExerciseDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ExerciseDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exerciseId"] = this.exerciseId;
        data["exerciseName"] = this.exerciseName;
        data["type"] = this.type;
        return data;
    }
}

export interface IExerciseDTO {
    exerciseId?: number;
    exerciseName?: string | undefined;
    type?: string;
}

export class CreateExerciseCommand implements ICreateExerciseCommand {
    muscleGroupIds?: number[];
    equipmentId?: number | undefined;
    exerciseName?: string | undefined;
    demoUrl?: string | undefined;
    type?: string;
    description?: string | undefined;
    publicVisibility?: boolean | undefined;

    constructor(data?: ICreateExerciseCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["muscleGroupIds"])) {
                this.muscleGroupIds = [] as any;
                for (let item of _data["muscleGroupIds"])
                    this.muscleGroupIds!.push(item);
            }
            this.equipmentId = _data["equipmentId"];
            this.exerciseName = _data["exerciseName"];
            this.demoUrl = _data["demoUrl"];
            this.type = _data["type"];
            this.description = _data["description"];
            this.publicVisibility = _data["publicVisibility"];
        }
    }

    static fromJS(data: any): CreateExerciseCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateExerciseCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.muscleGroupIds)) {
            data["muscleGroupIds"] = [];
            for (let item of this.muscleGroupIds)
                data["muscleGroupIds"].push(item);
        }
        data["equipmentId"] = this.equipmentId;
        data["exerciseName"] = this.exerciseName;
        data["demoUrl"] = this.demoUrl;
        data["type"] = this.type;
        data["description"] = this.description;
        data["publicVisibility"] = this.publicVisibility;
        return data;
    }
}

export interface ICreateExerciseCommand {
    muscleGroupIds?: number[];
    equipmentId?: number | undefined;
    exerciseName?: string | undefined;
    demoUrl?: string | undefined;
    type?: string;
    description?: string | undefined;
    publicVisibility?: boolean | undefined;
}

export class ImportExercisesCommand implements IImportExercisesCommand {
    exercises?: ExerciseImport[];

    constructor(data?: IImportExercisesCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["exercises"])) {
                this.exercises = [] as any;
                for (let item of _data["exercises"])
                    this.exercises!.push(ExerciseImport.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ImportExercisesCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ImportExercisesCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.exercises)) {
            data["exercises"] = [];
            for (let item of this.exercises)
                data["exercises"].push(item.toJSON());
        }
        return data;
    }
}

export interface IImportExercisesCommand {
    exercises?: ExerciseImport[];
}

export class ExerciseImport implements IExerciseImport {
    muscleGroupNames?: string[];
    equipmentName?: string | undefined;
    exerciseName?: string | undefined;
    demoUrl?: string | undefined;
    type?: string;
    description?: string | undefined;
    publicVisibility?: boolean | undefined;

    constructor(data?: IExerciseImport) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["muscleGroupNames"])) {
                this.muscleGroupNames = [] as any;
                for (let item of _data["muscleGroupNames"])
                    this.muscleGroupNames!.push(item);
            }
            this.equipmentName = _data["equipmentName"];
            this.exerciseName = _data["exerciseName"];
            this.demoUrl = _data["demoUrl"];
            this.type = _data["type"];
            this.description = _data["description"];
            this.publicVisibility = _data["publicVisibility"];
        }
    }

    static fromJS(data: any): ExerciseImport {
        data = typeof data === 'object' ? data : {};
        let result = new ExerciseImport();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.muscleGroupNames)) {
            data["muscleGroupNames"] = [];
            for (let item of this.muscleGroupNames)
                data["muscleGroupNames"].push(item);
        }
        data["equipmentName"] = this.equipmentName;
        data["exerciseName"] = this.exerciseName;
        data["demoUrl"] = this.demoUrl;
        data["type"] = this.type;
        data["description"] = this.description;
        data["publicVisibility"] = this.publicVisibility;
        return data;
    }
}

export interface IExerciseImport {
    muscleGroupNames?: string[];
    equipmentName?: string | undefined;
    exerciseName?: string | undefined;
    demoUrl?: string | undefined;
    type?: string;
    description?: string | undefined;
    publicVisibility?: boolean | undefined;
}

export class UpdateExerciseCommand implements IUpdateExerciseCommand {
    exerciseId?: number;
    createdBy?: string | undefined;
    muscleGroupIds?: number[];
    equipmentId?: number | undefined;
    exerciseName?: string | undefined;
    demoUrl?: string | undefined;
    type?: string;
    description?: string | undefined;
    publicVisibility?: boolean | undefined;

    constructor(data?: IUpdateExerciseCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.exerciseId = _data["exerciseId"];
            this.createdBy = _data["createdBy"];
            if (Array.isArray(_data["muscleGroupIds"])) {
                this.muscleGroupIds = [] as any;
                for (let item of _data["muscleGroupIds"])
                    this.muscleGroupIds!.push(item);
            }
            this.equipmentId = _data["equipmentId"];
            this.exerciseName = _data["exerciseName"];
            this.demoUrl = _data["demoUrl"];
            this.type = _data["type"];
            this.description = _data["description"];
            this.publicVisibility = _data["publicVisibility"];
        }
    }

    static fromJS(data: any): UpdateExerciseCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateExerciseCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exerciseId"] = this.exerciseId;
        data["createdBy"] = this.createdBy;
        if (Array.isArray(this.muscleGroupIds)) {
            data["muscleGroupIds"] = [];
            for (let item of this.muscleGroupIds)
                data["muscleGroupIds"].push(item);
        }
        data["equipmentId"] = this.equipmentId;
        data["exerciseName"] = this.exerciseName;
        data["demoUrl"] = this.demoUrl;
        data["type"] = this.type;
        data["description"] = this.description;
        data["publicVisibility"] = this.publicVisibility;
        return data;
    }
}

export interface IUpdateExerciseCommand {
    exerciseId?: number;
    createdBy?: string | undefined;
    muscleGroupIds?: number[];
    equipmentId?: number | undefined;
    exerciseName?: string | undefined;
    demoUrl?: string | undefined;
    type?: string;
    description?: string | undefined;
    publicVisibility?: boolean | undefined;
}

export class DeleteExerciseCommand implements IDeleteExerciseCommand {
    exerciseId?: number;

    constructor(data?: IDeleteExerciseCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.exerciseId = _data["exerciseId"];
        }
    }

    static fromJS(data: any): DeleteExerciseCommand {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteExerciseCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exerciseId"] = this.exerciseId;
        return data;
    }
}

export interface IDeleteExerciseCommand {
    exerciseId?: number;
}

export class PaginatedListOfMuscleGroupDTO implements IPaginatedListOfMuscleGroupDTO {
    items?: MuscleGroupDTO[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfMuscleGroupDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(MuscleGroupDTO.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfMuscleGroupDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfMuscleGroupDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfMuscleGroupDTO {
    items?: MuscleGroupDTO[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class MuscleGroupDTO implements IMuscleGroupDTO {
    muscleGroupId?: number;
    muscleGroupName?: string | undefined;
    imageUrl?: string | undefined;

    constructor(data?: IMuscleGroupDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.muscleGroupId = _data["muscleGroupId"];
            this.muscleGroupName = _data["muscleGroupName"];
            this.imageUrl = _data["imageUrl"];
        }
    }

    static fromJS(data: any): MuscleGroupDTO {
        data = typeof data === 'object' ? data : {};
        let result = new MuscleGroupDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["muscleGroupId"] = this.muscleGroupId;
        data["muscleGroupName"] = this.muscleGroupName;
        data["imageUrl"] = this.imageUrl;
        return data;
    }
}

export interface IMuscleGroupDTO {
    muscleGroupId?: number;
    muscleGroupName?: string | undefined;
    imageUrl?: string | undefined;
}

export class PaginatedListOfMuscleGroupDTO2 implements IPaginatedListOfMuscleGroupDTO2 {
    items?: MuscleGroupDTO2[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfMuscleGroupDTO2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(MuscleGroupDTO2.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfMuscleGroupDTO2 {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfMuscleGroupDTO2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfMuscleGroupDTO2 {
    items?: MuscleGroupDTO2[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class MuscleGroupDTO2 implements IMuscleGroupDTO2 {
    muscleGroupId?: number;
    muscleGroupName?: string | undefined;
    imageUrl?: string | undefined;

    constructor(data?: IMuscleGroupDTO2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.muscleGroupId = _data["muscleGroupId"];
            this.muscleGroupName = _data["muscleGroupName"];
            this.imageUrl = _data["imageUrl"];
        }
    }

    static fromJS(data: any): MuscleGroupDTO2 {
        data = typeof data === 'object' ? data : {};
        let result = new MuscleGroupDTO2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["muscleGroupId"] = this.muscleGroupId;
        data["muscleGroupName"] = this.muscleGroupName;
        data["imageUrl"] = this.imageUrl;
        return data;
    }
}

export interface IMuscleGroupDTO2 {
    muscleGroupId?: number;
    muscleGroupName?: string | undefined;
    imageUrl?: string | undefined;
}

export class CreateMuscleGroupCommand implements ICreateMuscleGroupCommand {
    muscleGroupName?: string | undefined;
    imageUrl?: string | undefined;

    constructor(data?: ICreateMuscleGroupCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.muscleGroupName = _data["muscleGroupName"];
            this.imageUrl = _data["imageUrl"];
        }
    }

    static fromJS(data: any): CreateMuscleGroupCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateMuscleGroupCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["muscleGroupName"] = this.muscleGroupName;
        data["imageUrl"] = this.imageUrl;
        return data;
    }
}

export interface ICreateMuscleGroupCommand {
    muscleGroupName?: string | undefined;
    imageUrl?: string | undefined;
}

export class UpdateMuscleGroupCommand implements IUpdateMuscleGroupCommand {
    id?: number;
    muscleGroupName?: string | undefined;
    imageUrl?: string | undefined;

    constructor(data?: IUpdateMuscleGroupCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.muscleGroupName = _data["muscleGroupName"];
            this.imageUrl = _data["imageUrl"];
        }
    }

    static fromJS(data: any): UpdateMuscleGroupCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateMuscleGroupCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["muscleGroupName"] = this.muscleGroupName;
        data["imageUrl"] = this.imageUrl;
        return data;
    }
}

export interface IUpdateMuscleGroupCommand {
    id?: number;
    muscleGroupName?: string | undefined;
    imageUrl?: string | undefined;
}

export class SummaryWorkoutLogStatsDTO implements ISummaryWorkoutLogStatsDTO {
    numberOfWorkouts?: number;
    hoursAtTheGym?: number;
    weightLifted?: number;
    weekStreak?: number;

    constructor(data?: ISummaryWorkoutLogStatsDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.numberOfWorkouts = _data["numberOfWorkouts"];
            this.hoursAtTheGym = _data["hoursAtTheGym"];
            this.weightLifted = _data["weightLifted"];
            this.weekStreak = _data["weekStreak"];
        }
    }

    static fromJS(data: any): SummaryWorkoutLogStatsDTO {
        data = typeof data === 'object' ? data : {};
        let result = new SummaryWorkoutLogStatsDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["numberOfWorkouts"] = this.numberOfWorkouts;
        data["hoursAtTheGym"] = this.hoursAtTheGym;
        data["weightLifted"] = this.weightLifted;
        data["weekStreak"] = this.weekStreak;
        return data;
    }
}

export interface ISummaryWorkoutLogStatsDTO {
    numberOfWorkouts?: number;
    hoursAtTheGym?: number;
    weightLifted?: number;
    weekStreak?: number;
}

export class MuscleEngagementDTO implements IMuscleEngagementDTO {
    muscle?: string;
    sets?: number;

    constructor(data?: IMuscleEngagementDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.muscle = _data["muscle"];
            this.sets = _data["sets"];
        }
    }

    static fromJS(data: any): MuscleEngagementDTO {
        data = typeof data === 'object' ? data : {};
        let result = new MuscleEngagementDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["muscle"] = this.muscle;
        data["sets"] = this.sets;
        return data;
    }
}

export interface IMuscleEngagementDTO {
    muscle?: string;
    sets?: number;
}

export class ExerciseLogDTO implements IExerciseLogDTO {
    exerciseLogId?: number;
    workoutLogId?: number | undefined;
    exerciseId?: number | undefined;
    dateCreated?: Date;
    lastModified?: Date;
    orderInSession?: number | undefined;
    orderInSuperset?: number | undefined;
    note?: string | undefined;
    numberOfSets?: number | undefined;
    weightsUsed?: string | undefined;
    numberOfReps?: string | undefined;
    footageUrls?: string | undefined;
    exerciseName?: string | undefined;

    constructor(data?: IExerciseLogDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.exerciseLogId = _data["exerciseLogId"];
            this.workoutLogId = _data["workoutLogId"];
            this.exerciseId = _data["exerciseId"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.lastModified = _data["lastModified"] ? new Date(_data["lastModified"].toString()) : <any>undefined;
            this.orderInSession = _data["orderInSession"];
            this.orderInSuperset = _data["orderInSuperset"];
            this.note = _data["note"];
            this.numberOfSets = _data["numberOfSets"];
            this.weightsUsed = _data["weightsUsed"];
            this.numberOfReps = _data["numberOfReps"];
            this.footageUrls = _data["footageUrls"];
            this.exerciseName = _data["exerciseName"];
        }
    }

    static fromJS(data: any): ExerciseLogDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ExerciseLogDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exerciseLogId"] = this.exerciseLogId;
        data["workoutLogId"] = this.workoutLogId;
        data["exerciseId"] = this.exerciseId;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>undefined;
        data["orderInSession"] = this.orderInSession;
        data["orderInSuperset"] = this.orderInSuperset;
        data["note"] = this.note;
        data["numberOfSets"] = this.numberOfSets;
        data["weightsUsed"] = this.weightsUsed;
        data["numberOfReps"] = this.numberOfReps;
        data["footageUrls"] = this.footageUrls;
        data["exerciseName"] = this.exerciseName;
        return data;
    }
}

export interface IExerciseLogDTO {
    exerciseLogId?: number;
    workoutLogId?: number | undefined;
    exerciseId?: number | undefined;
    dateCreated?: Date;
    lastModified?: Date;
    orderInSession?: number | undefined;
    orderInSuperset?: number | undefined;
    note?: string | undefined;
    numberOfSets?: number | undefined;
    weightsUsed?: string | undefined;
    numberOfReps?: string | undefined;
    footageUrls?: string | undefined;
    exerciseName?: string | undefined;
}

export class OneRepMaxRecord implements IOneRepMaxRecord {
    epley?: number;
    brzycki?: number;
    lander?: number;
    lombardi?: number;
    mayhew?: number;
    oConner?: number;
    wathan?: number;

    constructor(data?: IOneRepMaxRecord) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.epley = _data["epley"];
            this.brzycki = _data["brzycki"];
            this.lander = _data["lander"];
            this.lombardi = _data["lombardi"];
            this.mayhew = _data["mayhew"];
            this.oConner = _data["oConner"];
            this.wathan = _data["wathan"];
        }
    }

    static fromJS(data: any): OneRepMaxRecord {
        data = typeof data === 'object' ? data : {};
        let result = new OneRepMaxRecord();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["epley"] = this.epley;
        data["brzycki"] = this.brzycki;
        data["lander"] = this.lander;
        data["lombardi"] = this.lombardi;
        data["mayhew"] = this.mayhew;
        data["oConner"] = this.oConner;
        data["wathan"] = this.wathan;
        return data;
    }
}

export interface IOneRepMaxRecord {
    epley?: number;
    brzycki?: number;
    lander?: number;
    lombardi?: number;
    mayhew?: number;
    oConner?: number;
    wathan?: number;
}

export class ExerciseHistoryEntry implements IExerciseHistoryEntry {
    exerciseKey?: ExerciseHistoryKey | undefined;
    logCount?: number;

    constructor(data?: IExerciseHistoryEntry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.exerciseKey = _data["exerciseKey"] ? ExerciseHistoryKey.fromJS(_data["exerciseKey"]) : <any>undefined;
            this.logCount = _data["logCount"];
        }
    }

    static fromJS(data: any): ExerciseHistoryEntry {
        data = typeof data === 'object' ? data : {};
        let result = new ExerciseHistoryEntry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exerciseKey"] = this.exerciseKey ? this.exerciseKey.toJSON() : <any>undefined;
        data["logCount"] = this.logCount;
        return data;
    }
}

export interface IExerciseHistoryEntry {
    exerciseKey?: ExerciseHistoryKey | undefined;
    logCount?: number;
}

export class ExerciseHistoryKey implements IExerciseHistoryKey {
    exerciseId?: number;
    exerciseName?: string;

    constructor(data?: IExerciseHistoryKey) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.exerciseId = _data["exerciseId"];
            this.exerciseName = _data["exerciseName"];
        }
    }

    static fromJS(data: any): ExerciseHistoryKey {
        data = typeof data === 'object' ? data : {};
        let result = new ExerciseHistoryKey();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exerciseId"] = this.exerciseId;
        data["exerciseName"] = this.exerciseName;
        return data;
    }
}

export interface IExerciseHistoryKey {
    exerciseId?: number;
    exerciseName?: string;
}

export class PersonalRecordDTO implements IPersonalRecordDTO {
    actual1RepMax?: number;
    estimated1RepMax?: number;
    maxVolume?: number;
    bestPerformances?: { [key: string]: BestPerformanceDTO; } | undefined;

    constructor(data?: IPersonalRecordDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.actual1RepMax = _data["actual1RepMax"];
            this.estimated1RepMax = _data["estimated1RepMax"];
            this.maxVolume = _data["maxVolume"];
            if (_data["bestPerformances"]) {
                this.bestPerformances = {} as any;
                for (let key in _data["bestPerformances"]) {
                    if (_data["bestPerformances"].hasOwnProperty(key))
                        (<any>this.bestPerformances)![key] = _data["bestPerformances"][key] ? BestPerformanceDTO.fromJS(_data["bestPerformances"][key]) : new BestPerformanceDTO();
                }
            }
        }
    }

    static fromJS(data: any): PersonalRecordDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PersonalRecordDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["actual1RepMax"] = this.actual1RepMax;
        data["estimated1RepMax"] = this.estimated1RepMax;
        data["maxVolume"] = this.maxVolume;
        if (this.bestPerformances) {
            data["bestPerformances"] = {};
            for (let key in this.bestPerformances) {
                if (this.bestPerformances.hasOwnProperty(key))
                    (<any>data["bestPerformances"])[key] = this.bestPerformances[key] ? this.bestPerformances[key].toJSON() : <any>undefined;
            }
        }
        return data;
    }
}

export interface IPersonalRecordDTO {
    actual1RepMax?: number;
    estimated1RepMax?: number;
    maxVolume?: number;
    bestPerformances?: { [key: string]: BestPerformanceDTO; } | undefined;
}

export class BestPerformanceDTO implements IBestPerformanceDTO {
    weight?: number;
    date?: Date;

    constructor(data?: IBestPerformanceDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.weight = _data["weight"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): BestPerformanceDTO {
        data = typeof data === 'object' ? data : {};
        let result = new BestPerformanceDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["weight"] = this.weight;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        return data;
    }
}

export interface IBestPerformanceDTO {
    weight?: number;
    date?: Date;
}

export class ProgramOverviewDto implements IProgramOverviewDto {
    programId?: number;
    creatorName?: string;
    programName?: string;
    programThumbnail?: string | undefined;
    numberOfWeeks?: number | undefined;
    daysPerWeek?: number | undefined;
    experienceLevel?: string | undefined;
    gymType?: string | undefined;
    musclesPriority?: string | undefined;

    constructor(data?: IProgramOverviewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.programId = _data["programId"];
            this.creatorName = _data["creatorName"];
            this.programName = _data["programName"];
            this.programThumbnail = _data["programThumbnail"];
            this.numberOfWeeks = _data["numberOfWeeks"];
            this.daysPerWeek = _data["daysPerWeek"];
            this.experienceLevel = _data["experienceLevel"];
            this.gymType = _data["gymType"];
            this.musclesPriority = _data["musclesPriority"];
        }
    }

    static fromJS(data: any): ProgramOverviewDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProgramOverviewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["programId"] = this.programId;
        data["creatorName"] = this.creatorName;
        data["programName"] = this.programName;
        data["programThumbnail"] = this.programThumbnail;
        data["numberOfWeeks"] = this.numberOfWeeks;
        data["daysPerWeek"] = this.daysPerWeek;
        data["experienceLevel"] = this.experienceLevel;
        data["gymType"] = this.gymType;
        data["musclesPriority"] = this.musclesPriority;
        return data;
    }
}

export interface IProgramOverviewDto {
    programId?: number;
    creatorName?: string;
    programName?: string;
    programThumbnail?: string | undefined;
    numberOfWeeks?: number | undefined;
    daysPerWeek?: number | undefined;
    experienceLevel?: string | undefined;
    gymType?: string | undefined;
    musclesPriority?: string | undefined;
}

export class CreateSurveyAnswerCommand implements ICreateSurveyAnswerCommand {
    goal?: string | undefined;
    daysPerWeek?: number | undefined;
    experienceLevel?: string | undefined;
    gymType?: string | undefined;
    musclesPriority?: string | undefined;
    age?: number | undefined;

    constructor(data?: ICreateSurveyAnswerCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.goal = _data["goal"];
            this.daysPerWeek = _data["daysPerWeek"];
            this.experienceLevel = _data["experienceLevel"];
            this.gymType = _data["gymType"];
            this.musclesPriority = _data["musclesPriority"];
            this.age = _data["age"];
        }
    }

    static fromJS(data: any): CreateSurveyAnswerCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSurveyAnswerCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["goal"] = this.goal;
        data["daysPerWeek"] = this.daysPerWeek;
        data["experienceLevel"] = this.experienceLevel;
        data["gymType"] = this.gymType;
        data["musclesPriority"] = this.musclesPriority;
        data["age"] = this.age;
        return data;
    }
}

export interface ICreateSurveyAnswerCommand {
    goal?: string | undefined;
    daysPerWeek?: number | undefined;
    experienceLevel?: string | undefined;
    gymType?: string | undefined;
    musclesPriority?: string | undefined;
    age?: number | undefined;
}

export class UpdateTrainingSurveyAnswersCommand implements IUpdateTrainingSurveyAnswersCommand {
    surveyAnswerId?: number;
    goal?: string | undefined;
    daysPerWeek?: number | undefined;
    experienceLevel?: string | undefined;
    gymType?: string | undefined;
    musclesPriority?: string | undefined;
    age?: number | undefined;
    lastModified?: Date;

    constructor(data?: IUpdateTrainingSurveyAnswersCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.surveyAnswerId = _data["surveyAnswerId"];
            this.goal = _data["goal"];
            this.daysPerWeek = _data["daysPerWeek"];
            this.experienceLevel = _data["experienceLevel"];
            this.gymType = _data["gymType"];
            this.musclesPriority = _data["musclesPriority"];
            this.age = _data["age"];
            this.lastModified = _data["lastModified"] ? new Date(_data["lastModified"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateTrainingSurveyAnswersCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTrainingSurveyAnswersCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["surveyAnswerId"] = this.surveyAnswerId;
        data["goal"] = this.goal;
        data["daysPerWeek"] = this.daysPerWeek;
        data["experienceLevel"] = this.experienceLevel;
        data["gymType"] = this.gymType;
        data["musclesPriority"] = this.musclesPriority;
        data["age"] = this.age;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>undefined;
        return data;
    }
}

export interface IUpdateTrainingSurveyAnswersCommand {
    surveyAnswerId?: number;
    goal?: string | undefined;
    daysPerWeek?: number | undefined;
    experienceLevel?: string | undefined;
    gymType?: string | undefined;
    musclesPriority?: string | undefined;
    age?: number | undefined;
    lastModified?: Date;
}

export class SurveyAnswer implements ISurveyAnswer {
    surveyAnswerId?: number;
    userId?: string | undefined;
    goal?: string | undefined;
    daysPerWeek?: number | undefined;
    experienceLevel?: string | undefined;
    gymType?: string | undefined;
    musclesPriority?: string | undefined;
    age?: number | undefined;
    lastModified?: Date;
    user?: AspNetUser | undefined;

    constructor(data?: ISurveyAnswer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.surveyAnswerId = _data["surveyAnswerId"];
            this.userId = _data["userId"];
            this.goal = _data["goal"];
            this.daysPerWeek = _data["daysPerWeek"];
            this.experienceLevel = _data["experienceLevel"];
            this.gymType = _data["gymType"];
            this.musclesPriority = _data["musclesPriority"];
            this.age = _data["age"];
            this.lastModified = _data["lastModified"] ? new Date(_data["lastModified"].toString()) : <any>undefined;
            this.user = _data["user"] ? AspNetUser.fromJS(_data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SurveyAnswer {
        data = typeof data === 'object' ? data : {};
        let result = new SurveyAnswer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["surveyAnswerId"] = this.surveyAnswerId;
        data["userId"] = this.userId;
        data["goal"] = this.goal;
        data["daysPerWeek"] = this.daysPerWeek;
        data["experienceLevel"] = this.experienceLevel;
        data["gymType"] = this.gymType;
        data["musclesPriority"] = this.musclesPriority;
        data["age"] = this.age;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>undefined;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data;
    }
}

export interface ISurveyAnswer {
    surveyAnswerId?: number;
    userId?: string | undefined;
    goal?: string | undefined;
    daysPerWeek?: number | undefined;
    experienceLevel?: string | undefined;
    gymType?: string | undefined;
    musclesPriority?: string | undefined;
    age?: number | undefined;
    lastModified?: Date;
    user?: AspNetUser | undefined;
}

export class IdentityUserOfString implements IIdentityUserOfString {
    id?: string | undefined;
    userName?: string | undefined;
    normalizedUserName?: string | undefined;
    email?: string | undefined;
    normalizedEmail?: string | undefined;
    emailConfirmed?: boolean;
    passwordHash?: string | undefined;
    securityStamp?: string | undefined;
    concurrencyStamp?: string | undefined;
    phoneNumber?: string | undefined;
    phoneNumberConfirmed?: boolean;
    twoFactorEnabled?: boolean;
    lockoutEnd?: Date | undefined;
    lockoutEnabled?: boolean;
    accessFailedCount?: number;

    constructor(data?: IIdentityUserOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.normalizedUserName = _data["normalizedUserName"];
            this.email = _data["email"];
            this.normalizedEmail = _data["normalizedEmail"];
            this.emailConfirmed = _data["emailConfirmed"];
            this.passwordHash = _data["passwordHash"];
            this.securityStamp = _data["securityStamp"];
            this.concurrencyStamp = _data["concurrencyStamp"];
            this.phoneNumber = _data["phoneNumber"];
            this.phoneNumberConfirmed = _data["phoneNumberConfirmed"];
            this.twoFactorEnabled = _data["twoFactorEnabled"];
            this.lockoutEnd = _data["lockoutEnd"] ? new Date(_data["lockoutEnd"].toString()) : <any>undefined;
            this.lockoutEnabled = _data["lockoutEnabled"];
            this.accessFailedCount = _data["accessFailedCount"];
        }
    }

    static fromJS(data: any): IdentityUserOfString {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityUserOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["normalizedUserName"] = this.normalizedUserName;
        data["email"] = this.email;
        data["normalizedEmail"] = this.normalizedEmail;
        data["emailConfirmed"] = this.emailConfirmed;
        data["passwordHash"] = this.passwordHash;
        data["securityStamp"] = this.securityStamp;
        data["concurrencyStamp"] = this.concurrencyStamp;
        data["phoneNumber"] = this.phoneNumber;
        data["phoneNumberConfirmed"] = this.phoneNumberConfirmed;
        data["twoFactorEnabled"] = this.twoFactorEnabled;
        data["lockoutEnd"] = this.lockoutEnd ? this.lockoutEnd.toISOString() : <any>undefined;
        data["lockoutEnabled"] = this.lockoutEnabled;
        data["accessFailedCount"] = this.accessFailedCount;
        return data;
    }
}

export interface IIdentityUserOfString {
    id?: string | undefined;
    userName?: string | undefined;
    normalizedUserName?: string | undefined;
    email?: string | undefined;
    normalizedEmail?: string | undefined;
    emailConfirmed?: boolean;
    passwordHash?: string | undefined;
    securityStamp?: string | undefined;
    concurrencyStamp?: string | undefined;
    phoneNumber?: string | undefined;
    phoneNumberConfirmed?: boolean;
    twoFactorEnabled?: boolean;
    lockoutEnd?: Date | undefined;
    lockoutEnabled?: boolean;
    accessFailedCount?: number;
}

export class AspNetUser extends IdentityUserOfString implements IAspNetUser {
    googleID?: string | undefined;
    facebookID?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    dateOfBirth?: Date | undefined;
    gender?: string | undefined;
    isRestricted?: boolean | undefined;
    isDeleted?: boolean | undefined;
    aspNetUserClaims?: AspNetUserClaim[];
    aspNetUserLogins?: AspNetUserLogin[];
    aspNetUserTokens?: AspNetUserToken[];
    roles?: AspNetRole[];
    certifications?: Certification[];
    coachingBookings?: CoachingBooking[];
    coachingServices?: CoachingService[];
    exercises?: Exercise[];
    profiles?: Profile[];
    programEnrollments?: ProgramEnrollment[];
    programs?: Program[];
    surveyAnswers?: SurveyAnswer[];
    workoutLogs?: WorkoutLog[];
    workoutTemplateCreatedByNavigations?: WorkoutTemplate[];
    workoutTemplateLastModifiedByNavigations?: WorkoutTemplate[];
    coachApplications?: CoachApplication[];
    coachApplicationsUpdated?: CoachApplication[];
    chatLines?: ChatLine[];
    createdChats?: Chat[];
    invitedChats?: Chat[];

    constructor(data?: IAspNetUser) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.googleID = _data["googleID"];
            this.facebookID = _data["facebookID"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.dateOfBirth = _data["dateOfBirth"] ? new Date(_data["dateOfBirth"].toString()) : <any>undefined;
            this.gender = _data["gender"];
            this.isRestricted = _data["isRestricted"];
            this.isDeleted = _data["isDeleted"];
            if (Array.isArray(_data["aspNetUserClaims"])) {
                this.aspNetUserClaims = [] as any;
                for (let item of _data["aspNetUserClaims"])
                    this.aspNetUserClaims!.push(AspNetUserClaim.fromJS(item));
            }
            if (Array.isArray(_data["aspNetUserLogins"])) {
                this.aspNetUserLogins = [] as any;
                for (let item of _data["aspNetUserLogins"])
                    this.aspNetUserLogins!.push(AspNetUserLogin.fromJS(item));
            }
            if (Array.isArray(_data["aspNetUserTokens"])) {
                this.aspNetUserTokens = [] as any;
                for (let item of _data["aspNetUserTokens"])
                    this.aspNetUserTokens!.push(AspNetUserToken.fromJS(item));
            }
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(AspNetRole.fromJS(item));
            }
            if (Array.isArray(_data["certifications"])) {
                this.certifications = [] as any;
                for (let item of _data["certifications"])
                    this.certifications!.push(Certification.fromJS(item));
            }
            if (Array.isArray(_data["coachingBookings"])) {
                this.coachingBookings = [] as any;
                for (let item of _data["coachingBookings"])
                    this.coachingBookings!.push(CoachingBooking.fromJS(item));
            }
            if (Array.isArray(_data["coachingServices"])) {
                this.coachingServices = [] as any;
                for (let item of _data["coachingServices"])
                    this.coachingServices!.push(CoachingService.fromJS(item));
            }
            if (Array.isArray(_data["exercises"])) {
                this.exercises = [] as any;
                for (let item of _data["exercises"])
                    this.exercises!.push(Exercise.fromJS(item));
            }
            if (Array.isArray(_data["profiles"])) {
                this.profiles = [] as any;
                for (let item of _data["profiles"])
                    this.profiles!.push(Profile.fromJS(item));
            }
            if (Array.isArray(_data["programEnrollments"])) {
                this.programEnrollments = [] as any;
                for (let item of _data["programEnrollments"])
                    this.programEnrollments!.push(ProgramEnrollment.fromJS(item));
            }
            if (Array.isArray(_data["programs"])) {
                this.programs = [] as any;
                for (let item of _data["programs"])
                    this.programs!.push(Program.fromJS(item));
            }
            if (Array.isArray(_data["surveyAnswers"])) {
                this.surveyAnswers = [] as any;
                for (let item of _data["surveyAnswers"])
                    this.surveyAnswers!.push(SurveyAnswer.fromJS(item));
            }
            if (Array.isArray(_data["workoutLogs"])) {
                this.workoutLogs = [] as any;
                for (let item of _data["workoutLogs"])
                    this.workoutLogs!.push(WorkoutLog.fromJS(item));
            }
            if (Array.isArray(_data["workoutTemplateCreatedByNavigations"])) {
                this.workoutTemplateCreatedByNavigations = [] as any;
                for (let item of _data["workoutTemplateCreatedByNavigations"])
                    this.workoutTemplateCreatedByNavigations!.push(WorkoutTemplate.fromJS(item));
            }
            if (Array.isArray(_data["workoutTemplateLastModifiedByNavigations"])) {
                this.workoutTemplateLastModifiedByNavigations = [] as any;
                for (let item of _data["workoutTemplateLastModifiedByNavigations"])
                    this.workoutTemplateLastModifiedByNavigations!.push(WorkoutTemplate.fromJS(item));
            }
            if (Array.isArray(_data["coachApplications"])) {
                this.coachApplications = [] as any;
                for (let item of _data["coachApplications"])
                    this.coachApplications!.push(CoachApplication.fromJS(item));
            }
            if (Array.isArray(_data["coachApplicationsUpdated"])) {
                this.coachApplicationsUpdated = [] as any;
                for (let item of _data["coachApplicationsUpdated"])
                    this.coachApplicationsUpdated!.push(CoachApplication.fromJS(item));
            }
            if (Array.isArray(_data["chatLines"])) {
                this.chatLines = [] as any;
                for (let item of _data["chatLines"])
                    this.chatLines!.push(ChatLine.fromJS(item));
            }
            if (Array.isArray(_data["createdChats"])) {
                this.createdChats = [] as any;
                for (let item of _data["createdChats"])
                    this.createdChats!.push(Chat.fromJS(item));
            }
            if (Array.isArray(_data["invitedChats"])) {
                this.invitedChats = [] as any;
                for (let item of _data["invitedChats"])
                    this.invitedChats!.push(Chat.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): AspNetUser {
        data = typeof data === 'object' ? data : {};
        let result = new AspNetUser();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["googleID"] = this.googleID;
        data["facebookID"] = this.facebookID;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["gender"] = this.gender;
        data["isRestricted"] = this.isRestricted;
        data["isDeleted"] = this.isDeleted;
        if (Array.isArray(this.aspNetUserClaims)) {
            data["aspNetUserClaims"] = [];
            for (let item of this.aspNetUserClaims)
                data["aspNetUserClaims"].push(item.toJSON());
        }
        if (Array.isArray(this.aspNetUserLogins)) {
            data["aspNetUserLogins"] = [];
            for (let item of this.aspNetUserLogins)
                data["aspNetUserLogins"].push(item.toJSON());
        }
        if (Array.isArray(this.aspNetUserTokens)) {
            data["aspNetUserTokens"] = [];
            for (let item of this.aspNetUserTokens)
                data["aspNetUserTokens"].push(item.toJSON());
        }
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        if (Array.isArray(this.certifications)) {
            data["certifications"] = [];
            for (let item of this.certifications)
                data["certifications"].push(item.toJSON());
        }
        if (Array.isArray(this.coachingBookings)) {
            data["coachingBookings"] = [];
            for (let item of this.coachingBookings)
                data["coachingBookings"].push(item.toJSON());
        }
        if (Array.isArray(this.coachingServices)) {
            data["coachingServices"] = [];
            for (let item of this.coachingServices)
                data["coachingServices"].push(item.toJSON());
        }
        if (Array.isArray(this.exercises)) {
            data["exercises"] = [];
            for (let item of this.exercises)
                data["exercises"].push(item.toJSON());
        }
        if (Array.isArray(this.profiles)) {
            data["profiles"] = [];
            for (let item of this.profiles)
                data["profiles"].push(item.toJSON());
        }
        if (Array.isArray(this.programEnrollments)) {
            data["programEnrollments"] = [];
            for (let item of this.programEnrollments)
                data["programEnrollments"].push(item.toJSON());
        }
        if (Array.isArray(this.programs)) {
            data["programs"] = [];
            for (let item of this.programs)
                data["programs"].push(item.toJSON());
        }
        if (Array.isArray(this.surveyAnswers)) {
            data["surveyAnswers"] = [];
            for (let item of this.surveyAnswers)
                data["surveyAnswers"].push(item.toJSON());
        }
        if (Array.isArray(this.workoutLogs)) {
            data["workoutLogs"] = [];
            for (let item of this.workoutLogs)
                data["workoutLogs"].push(item.toJSON());
        }
        if (Array.isArray(this.workoutTemplateCreatedByNavigations)) {
            data["workoutTemplateCreatedByNavigations"] = [];
            for (let item of this.workoutTemplateCreatedByNavigations)
                data["workoutTemplateCreatedByNavigations"].push(item.toJSON());
        }
        if (Array.isArray(this.workoutTemplateLastModifiedByNavigations)) {
            data["workoutTemplateLastModifiedByNavigations"] = [];
            for (let item of this.workoutTemplateLastModifiedByNavigations)
                data["workoutTemplateLastModifiedByNavigations"].push(item.toJSON());
        }
        if (Array.isArray(this.coachApplications)) {
            data["coachApplications"] = [];
            for (let item of this.coachApplications)
                data["coachApplications"].push(item.toJSON());
        }
        if (Array.isArray(this.coachApplicationsUpdated)) {
            data["coachApplicationsUpdated"] = [];
            for (let item of this.coachApplicationsUpdated)
                data["coachApplicationsUpdated"].push(item.toJSON());
        }
        if (Array.isArray(this.chatLines)) {
            data["chatLines"] = [];
            for (let item of this.chatLines)
                data["chatLines"].push(item.toJSON());
        }
        if (Array.isArray(this.createdChats)) {
            data["createdChats"] = [];
            for (let item of this.createdChats)
                data["createdChats"].push(item.toJSON());
        }
        if (Array.isArray(this.invitedChats)) {
            data["invitedChats"] = [];
            for (let item of this.invitedChats)
                data["invitedChats"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IAspNetUser extends IIdentityUserOfString {
    googleID?: string | undefined;
    facebookID?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    dateOfBirth?: Date | undefined;
    gender?: string | undefined;
    isRestricted?: boolean | undefined;
    isDeleted?: boolean | undefined;
    aspNetUserClaims?: AspNetUserClaim[];
    aspNetUserLogins?: AspNetUserLogin[];
    aspNetUserTokens?: AspNetUserToken[];
    roles?: AspNetRole[];
    certifications?: Certification[];
    coachingBookings?: CoachingBooking[];
    coachingServices?: CoachingService[];
    exercises?: Exercise[];
    profiles?: Profile[];
    programEnrollments?: ProgramEnrollment[];
    programs?: Program[];
    surveyAnswers?: SurveyAnswer[];
    workoutLogs?: WorkoutLog[];
    workoutTemplateCreatedByNavigations?: WorkoutTemplate[];
    workoutTemplateLastModifiedByNavigations?: WorkoutTemplate[];
    coachApplications?: CoachApplication[];
    coachApplicationsUpdated?: CoachApplication[];
    chatLines?: ChatLine[];
    createdChats?: Chat[];
    invitedChats?: Chat[];
}

export class IdentityUserClaimOfString implements IIdentityUserClaimOfString {
    id?: number;
    userId?: string | undefined;
    claimType?: string | undefined;
    claimValue?: string | undefined;

    constructor(data?: IIdentityUserClaimOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.claimType = _data["claimType"];
            this.claimValue = _data["claimValue"];
        }
    }

    static fromJS(data: any): IdentityUserClaimOfString {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityUserClaimOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["claimType"] = this.claimType;
        data["claimValue"] = this.claimValue;
        return data;
    }
}

export interface IIdentityUserClaimOfString {
    id?: number;
    userId?: string | undefined;
    claimType?: string | undefined;
    claimValue?: string | undefined;
}

export class AspNetUserClaim extends IdentityUserClaimOfString implements IAspNetUserClaim {
    user?: AspNetUser;

    constructor(data?: IAspNetUserClaim) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.user = _data["user"] ? AspNetUser.fromJS(_data["user"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): AspNetUserClaim {
        data = typeof data === 'object' ? data : {};
        let result = new AspNetUserClaim();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IAspNetUserClaim extends IIdentityUserClaimOfString {
    user?: AspNetUser;
}

export class IdentityUserLoginOfString implements IIdentityUserLoginOfString {
    loginProvider?: string;
    providerKey?: string;
    providerDisplayName?: string | undefined;
    userId?: string | undefined;

    constructor(data?: IIdentityUserLoginOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.loginProvider = _data["loginProvider"];
            this.providerKey = _data["providerKey"];
            this.providerDisplayName = _data["providerDisplayName"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): IdentityUserLoginOfString {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityUserLoginOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["loginProvider"] = this.loginProvider;
        data["providerKey"] = this.providerKey;
        data["providerDisplayName"] = this.providerDisplayName;
        data["userId"] = this.userId;
        return data;
    }
}

export interface IIdentityUserLoginOfString {
    loginProvider?: string;
    providerKey?: string;
    providerDisplayName?: string | undefined;
    userId?: string | undefined;
}

export class AspNetUserLogin extends IdentityUserLoginOfString implements IAspNetUserLogin {

    constructor(data?: IAspNetUserLogin) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): AspNetUserLogin {
        data = typeof data === 'object' ? data : {};
        let result = new AspNetUserLogin();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IAspNetUserLogin extends IIdentityUserLoginOfString {
}

export class IdentityUserTokenOfString implements IIdentityUserTokenOfString {
    userId?: string | undefined;
    loginProvider?: string;
    name?: string;
    value?: string | undefined;

    constructor(data?: IIdentityUserTokenOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.loginProvider = _data["loginProvider"];
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): IdentityUserTokenOfString {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityUserTokenOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["loginProvider"] = this.loginProvider;
        data["name"] = this.name;
        data["value"] = this.value;
        return data;
    }
}

export interface IIdentityUserTokenOfString {
    userId?: string | undefined;
    loginProvider?: string;
    name?: string;
    value?: string | undefined;
}

export class AspNetUserToken extends IdentityUserTokenOfString implements IAspNetUserToken {
    user?: AspNetUser;

    constructor(data?: IAspNetUserToken) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.user = _data["user"] ? AspNetUser.fromJS(_data["user"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): AspNetUserToken {
        data = typeof data === 'object' ? data : {};
        let result = new AspNetUserToken();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IAspNetUserToken extends IIdentityUserTokenOfString {
    user?: AspNetUser;
}

export class IdentityRoleOfString implements IIdentityRoleOfString {
    id?: string | undefined;
    name?: string | undefined;
    normalizedName?: string | undefined;
    concurrencyStamp?: string | undefined;

    constructor(data?: IIdentityRoleOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.normalizedName = _data["normalizedName"];
            this.concurrencyStamp = _data["concurrencyStamp"];
        }
    }

    static fromJS(data: any): IdentityRoleOfString {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityRoleOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["normalizedName"] = this.normalizedName;
        data["concurrencyStamp"] = this.concurrencyStamp;
        return data;
    }
}

export interface IIdentityRoleOfString {
    id?: string | undefined;
    name?: string | undefined;
    normalizedName?: string | undefined;
    concurrencyStamp?: string | undefined;
}

export class AspNetRole extends IdentityRoleOfString implements IAspNetRole {
    roleDesc?: string | undefined;
    aspNetRoleClaims?: AspNetRoleClaim[];
    users?: AspNetUser[];

    constructor(data?: IAspNetRole) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.roleDesc = _data["roleDesc"];
            if (Array.isArray(_data["aspNetRoleClaims"])) {
                this.aspNetRoleClaims = [] as any;
                for (let item of _data["aspNetRoleClaims"])
                    this.aspNetRoleClaims!.push(AspNetRoleClaim.fromJS(item));
            }
            if (Array.isArray(_data["users"])) {
                this.users = [] as any;
                for (let item of _data["users"])
                    this.users!.push(AspNetUser.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): AspNetRole {
        data = typeof data === 'object' ? data : {};
        let result = new AspNetRole();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleDesc"] = this.roleDesc;
        if (Array.isArray(this.aspNetRoleClaims)) {
            data["aspNetRoleClaims"] = [];
            for (let item of this.aspNetRoleClaims)
                data["aspNetRoleClaims"].push(item.toJSON());
        }
        if (Array.isArray(this.users)) {
            data["users"] = [];
            for (let item of this.users)
                data["users"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IAspNetRole extends IIdentityRoleOfString {
    roleDesc?: string | undefined;
    aspNetRoleClaims?: AspNetRoleClaim[];
    users?: AspNetUser[];
}

export class IdentityRoleClaimOfString implements IIdentityRoleClaimOfString {
    id?: number;
    roleId?: string | undefined;
    claimType?: string | undefined;
    claimValue?: string | undefined;

    constructor(data?: IIdentityRoleClaimOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.roleId = _data["roleId"];
            this.claimType = _data["claimType"];
            this.claimValue = _data["claimValue"];
        }
    }

    static fromJS(data: any): IdentityRoleClaimOfString {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityRoleClaimOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["roleId"] = this.roleId;
        data["claimType"] = this.claimType;
        data["claimValue"] = this.claimValue;
        return data;
    }
}

export interface IIdentityRoleClaimOfString {
    id?: number;
    roleId?: string | undefined;
    claimType?: string | undefined;
    claimValue?: string | undefined;
}

export class AspNetRoleClaim extends IdentityRoleClaimOfString implements IAspNetRoleClaim {
    role?: AspNetRole;

    constructor(data?: IAspNetRoleClaim) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.role = _data["role"] ? AspNetRole.fromJS(_data["role"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): AspNetRoleClaim {
        data = typeof data === 'object' ? data : {};
        let result = new AspNetRoleClaim();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IAspNetRoleClaim extends IIdentityRoleClaimOfString {
    role?: AspNetRole;
}

export class Certification implements ICertification {
    certificationId?: number;
    userId?: string | undefined;
    certificationName?: string | undefined;
    certificationDateIssued?: Date | undefined;
    certificationExpirationData?: Date | undefined;
    user?: AspNetUser | undefined;

    constructor(data?: ICertification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.certificationId = _data["certificationId"];
            this.userId = _data["userId"];
            this.certificationName = _data["certificationName"];
            this.certificationDateIssued = _data["certificationDateIssued"] ? new Date(_data["certificationDateIssued"].toString()) : <any>undefined;
            this.certificationExpirationData = _data["certificationExpirationData"] ? new Date(_data["certificationExpirationData"].toString()) : <any>undefined;
            this.user = _data["user"] ? AspNetUser.fromJS(_data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Certification {
        data = typeof data === 'object' ? data : {};
        let result = new Certification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["certificationId"] = this.certificationId;
        data["userId"] = this.userId;
        data["certificationName"] = this.certificationName;
        data["certificationDateIssued"] = this.certificationDateIssued ? formatDate(this.certificationDateIssued) : <any>undefined;
        data["certificationExpirationData"] = this.certificationExpirationData ? formatDate(this.certificationExpirationData) : <any>undefined;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICertification {
    certificationId?: number;
    userId?: string | undefined;
    certificationName?: string | undefined;
    certificationDateIssued?: Date | undefined;
    certificationExpirationData?: Date | undefined;
    user?: AspNetUser | undefined;
}

export class CoachingBooking implements ICoachingBooking {
    bookingId?: number;
    userId?: string | undefined;
    coachingServiceId?: number | undefined;
    status?: string;
    createdDate?: Date;
    paymentDate?: Date | undefined;
    coachingService?: CoachingService | undefined;
    user?: AspNetUser | undefined;

    constructor(data?: ICoachingBooking) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bookingId = _data["bookingId"];
            this.userId = _data["userId"];
            this.coachingServiceId = _data["coachingServiceId"];
            this.status = _data["status"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.paymentDate = _data["paymentDate"] ? new Date(_data["paymentDate"].toString()) : <any>undefined;
            this.coachingService = _data["coachingService"] ? CoachingService.fromJS(_data["coachingService"]) : <any>undefined;
            this.user = _data["user"] ? AspNetUser.fromJS(_data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CoachingBooking {
        data = typeof data === 'object' ? data : {};
        let result = new CoachingBooking();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bookingId"] = this.bookingId;
        data["userId"] = this.userId;
        data["coachingServiceId"] = this.coachingServiceId;
        data["status"] = this.status;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["paymentDate"] = this.paymentDate ? this.paymentDate.toISOString() : <any>undefined;
        data["coachingService"] = this.coachingService ? this.coachingService.toJSON() : <any>undefined;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICoachingBooking {
    bookingId?: number;
    userId?: string | undefined;
    coachingServiceId?: number | undefined;
    status?: string;
    createdDate?: Date;
    paymentDate?: Date | undefined;
    coachingService?: CoachingService | undefined;
    user?: AspNetUser | undefined;
}

export abstract class BaseEntity implements IBaseEntity {
    id?: number;
    domainEvents?: BaseEvent[];

    constructor(data?: IBaseEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["domainEvents"])) {
                this.domainEvents = [] as any;
                for (let item of _data["domainEvents"])
                    this.domainEvents!.push(BaseEvent.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BaseEntity {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'BaseEntity' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.domainEvents)) {
            data["domainEvents"] = [];
            for (let item of this.domainEvents)
                data["domainEvents"].push(item.toJSON());
        }
        return data;
    }
}

export interface IBaseEntity {
    id?: number;
    domainEvents?: BaseEvent[];
}

export abstract class BaseAuditableEntity extends BaseEntity implements IBaseAuditableEntity {
    created?: Date;
    createdBy?: string | undefined;
    lastModified?: Date;
    lastModifiedBy?: string | undefined;

    constructor(data?: IBaseAuditableEntity) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.lastModified = _data["lastModified"] ? new Date(_data["lastModified"].toString()) : <any>undefined;
            this.lastModifiedBy = _data["lastModifiedBy"];
        }
    }

    static override fromJS(data: any): BaseAuditableEntity {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'BaseAuditableEntity' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>undefined;
        data["lastModifiedBy"] = this.lastModifiedBy;
        super.toJSON(data);
        return data;
    }
}

export interface IBaseAuditableEntity extends IBaseEntity {
    created?: Date;
    createdBy?: string | undefined;
    lastModified?: Date;
    lastModifiedBy?: string | undefined;
}

export class CoachingService extends BaseAuditableEntity implements ICoachingService {
    serviceName?: string;
    description?: string | undefined;
    duration?: number | undefined;
    price?: number | undefined;
    serviceAvailability?: boolean | undefined;
    availabilityAnnouncement?: string | undefined;
    coachingBookings?: CoachingBooking[];
    createdByNavigation?: AspNetUser | undefined;

    constructor(data?: ICoachingService) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.serviceName = _data["serviceName"];
            this.description = _data["description"];
            this.duration = _data["duration"];
            this.price = _data["price"];
            this.serviceAvailability = _data["serviceAvailability"];
            this.availabilityAnnouncement = _data["availabilityAnnouncement"];
            if (Array.isArray(_data["coachingBookings"])) {
                this.coachingBookings = [] as any;
                for (let item of _data["coachingBookings"])
                    this.coachingBookings!.push(CoachingBooking.fromJS(item));
            }
            this.createdByNavigation = _data["createdByNavigation"] ? AspNetUser.fromJS(_data["createdByNavigation"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): CoachingService {
        data = typeof data === 'object' ? data : {};
        let result = new CoachingService();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["serviceName"] = this.serviceName;
        data["description"] = this.description;
        data["duration"] = this.duration;
        data["price"] = this.price;
        data["serviceAvailability"] = this.serviceAvailability;
        data["availabilityAnnouncement"] = this.availabilityAnnouncement;
        if (Array.isArray(this.coachingBookings)) {
            data["coachingBookings"] = [];
            for (let item of this.coachingBookings)
                data["coachingBookings"].push(item.toJSON());
        }
        data["createdByNavigation"] = this.createdByNavigation ? this.createdByNavigation.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface ICoachingService extends IBaseAuditableEntity {
    serviceName?: string;
    description?: string | undefined;
    duration?: number | undefined;
    price?: number | undefined;
    serviceAvailability?: boolean | undefined;
    availabilityAnnouncement?: string | undefined;
    coachingBookings?: CoachingBooking[];
    createdByNavigation?: AspNetUser | undefined;
}

export abstract class BaseEvent implements IBaseEvent {

    constructor(data?: IBaseEvent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): BaseEvent {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'BaseEvent' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IBaseEvent {
}

export class Exercise implements IExercise {
    exerciseId?: number;
    createdBy?: string | undefined;
    equipmentId?: number | undefined;
    exerciseName?: string | undefined;
    demoUrl?: string | undefined;
    type?: string;
    description?: string | undefined;
    publicVisibility?: boolean | undefined;
    createdByNavigation?: AspNetUser;
    equipment?: Equipment | undefined;
    exerciseLogs?: ExerciseLog[];
    workoutTemplateExercises?: WorkoutTemplateExercise[];
    exerciseMuscleGroups?: ExerciseMuscleGroup[];

    constructor(data?: IExercise) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.exerciseId = _data["exerciseId"];
            this.createdBy = _data["createdBy"];
            this.equipmentId = _data["equipmentId"];
            this.exerciseName = _data["exerciseName"];
            this.demoUrl = _data["demoUrl"];
            this.type = _data["type"];
            this.description = _data["description"];
            this.publicVisibility = _data["publicVisibility"];
            this.createdByNavigation = _data["createdByNavigation"] ? AspNetUser.fromJS(_data["createdByNavigation"]) : <any>undefined;
            this.equipment = _data["equipment"] ? Equipment.fromJS(_data["equipment"]) : <any>undefined;
            if (Array.isArray(_data["exerciseLogs"])) {
                this.exerciseLogs = [] as any;
                for (let item of _data["exerciseLogs"])
                    this.exerciseLogs!.push(ExerciseLog.fromJS(item));
            }
            if (Array.isArray(_data["workoutTemplateExercises"])) {
                this.workoutTemplateExercises = [] as any;
                for (let item of _data["workoutTemplateExercises"])
                    this.workoutTemplateExercises!.push(WorkoutTemplateExercise.fromJS(item));
            }
            if (Array.isArray(_data["exerciseMuscleGroups"])) {
                this.exerciseMuscleGroups = [] as any;
                for (let item of _data["exerciseMuscleGroups"])
                    this.exerciseMuscleGroups!.push(ExerciseMuscleGroup.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Exercise {
        data = typeof data === 'object' ? data : {};
        let result = new Exercise();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exerciseId"] = this.exerciseId;
        data["createdBy"] = this.createdBy;
        data["equipmentId"] = this.equipmentId;
        data["exerciseName"] = this.exerciseName;
        data["demoUrl"] = this.demoUrl;
        data["type"] = this.type;
        data["description"] = this.description;
        data["publicVisibility"] = this.publicVisibility;
        data["createdByNavigation"] = this.createdByNavigation ? this.createdByNavigation.toJSON() : <any>undefined;
        data["equipment"] = this.equipment ? this.equipment.toJSON() : <any>undefined;
        if (Array.isArray(this.exerciseLogs)) {
            data["exerciseLogs"] = [];
            for (let item of this.exerciseLogs)
                data["exerciseLogs"].push(item.toJSON());
        }
        if (Array.isArray(this.workoutTemplateExercises)) {
            data["workoutTemplateExercises"] = [];
            for (let item of this.workoutTemplateExercises)
                data["workoutTemplateExercises"].push(item.toJSON());
        }
        if (Array.isArray(this.exerciseMuscleGroups)) {
            data["exerciseMuscleGroups"] = [];
            for (let item of this.exerciseMuscleGroups)
                data["exerciseMuscleGroups"].push(item.toJSON());
        }
        return data;
    }
}

export interface IExercise {
    exerciseId?: number;
    createdBy?: string | undefined;
    equipmentId?: number | undefined;
    exerciseName?: string | undefined;
    demoUrl?: string | undefined;
    type?: string;
    description?: string | undefined;
    publicVisibility?: boolean | undefined;
    createdByNavigation?: AspNetUser;
    equipment?: Equipment | undefined;
    exerciseLogs?: ExerciseLog[];
    workoutTemplateExercises?: WorkoutTemplateExercise[];
    exerciseMuscleGroups?: ExerciseMuscleGroup[];
}

export class Equipment implements IEquipment {
    equipmentId?: number;
    equipmentName?: string | undefined;
    imageUrl?: string | undefined;
    exercises?: Exercise[];

    constructor(data?: IEquipment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.equipmentId = _data["equipmentId"];
            this.equipmentName = _data["equipmentName"];
            this.imageUrl = _data["imageUrl"];
            if (Array.isArray(_data["exercises"])) {
                this.exercises = [] as any;
                for (let item of _data["exercises"])
                    this.exercises!.push(Exercise.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Equipment {
        data = typeof data === 'object' ? data : {};
        let result = new Equipment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["equipmentId"] = this.equipmentId;
        data["equipmentName"] = this.equipmentName;
        data["imageUrl"] = this.imageUrl;
        if (Array.isArray(this.exercises)) {
            data["exercises"] = [];
            for (let item of this.exercises)
                data["exercises"].push(item.toJSON());
        }
        return data;
    }
}

export interface IEquipment {
    equipmentId?: number;
    equipmentName?: string | undefined;
    imageUrl?: string | undefined;
    exercises?: Exercise[];
}

export class ExerciseLog implements IExerciseLog {
    exerciseLogId?: number;
    workoutLogId?: number | undefined;
    exerciseId?: number | undefined;
    dateCreated?: Date;
    lastModified?: Date;
    orderInSession?: number | undefined;
    orderInSuperset?: number | undefined;
    note?: string | undefined;
    numberOfSets?: number | undefined;
    weightsUsedValue?: number[] | undefined;
    numberOfRepsValue?: number[] | undefined;
    weightsUsed?: string | undefined;
    numberOfReps?: string | undefined;
    footageURLsList?: string[] | undefined;
    footageUrls?: string | undefined;
    exercise?: Exercise | undefined;
    workoutLog?: WorkoutLog | undefined;

    constructor(data?: IExerciseLog) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.exerciseLogId = _data["exerciseLogId"];
            this.workoutLogId = _data["workoutLogId"];
            this.exerciseId = _data["exerciseId"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.lastModified = _data["lastModified"] ? new Date(_data["lastModified"].toString()) : <any>undefined;
            this.orderInSession = _data["orderInSession"];
            this.orderInSuperset = _data["orderInSuperset"];
            this.note = _data["note"];
            this.numberOfSets = _data["numberOfSets"];
            if (Array.isArray(_data["weightsUsedValue"])) {
                this.weightsUsedValue = [] as any;
                for (let item of _data["weightsUsedValue"])
                    this.weightsUsedValue!.push(item);
            }
            if (Array.isArray(_data["numberOfRepsValue"])) {
                this.numberOfRepsValue = [] as any;
                for (let item of _data["numberOfRepsValue"])
                    this.numberOfRepsValue!.push(item);
            }
            this.weightsUsed = _data["weightsUsed"];
            this.numberOfReps = _data["numberOfReps"];
            if (Array.isArray(_data["footageURLsList"])) {
                this.footageURLsList = [] as any;
                for (let item of _data["footageURLsList"])
                    this.footageURLsList!.push(item);
            }
            this.footageUrls = _data["footageUrls"];
            this.exercise = _data["exercise"] ? Exercise.fromJS(_data["exercise"]) : <any>undefined;
            this.workoutLog = _data["workoutLog"] ? WorkoutLog.fromJS(_data["workoutLog"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ExerciseLog {
        data = typeof data === 'object' ? data : {};
        let result = new ExerciseLog();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exerciseLogId"] = this.exerciseLogId;
        data["workoutLogId"] = this.workoutLogId;
        data["exerciseId"] = this.exerciseId;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>undefined;
        data["orderInSession"] = this.orderInSession;
        data["orderInSuperset"] = this.orderInSuperset;
        data["note"] = this.note;
        data["numberOfSets"] = this.numberOfSets;
        if (Array.isArray(this.weightsUsedValue)) {
            data["weightsUsedValue"] = [];
            for (let item of this.weightsUsedValue)
                data["weightsUsedValue"].push(item);
        }
        if (Array.isArray(this.numberOfRepsValue)) {
            data["numberOfRepsValue"] = [];
            for (let item of this.numberOfRepsValue)
                data["numberOfRepsValue"].push(item);
        }
        data["weightsUsed"] = this.weightsUsed;
        data["numberOfReps"] = this.numberOfReps;
        if (Array.isArray(this.footageURLsList)) {
            data["footageURLsList"] = [];
            for (let item of this.footageURLsList)
                data["footageURLsList"].push(item);
        }
        data["footageUrls"] = this.footageUrls;
        data["exercise"] = this.exercise ? this.exercise.toJSON() : <any>undefined;
        data["workoutLog"] = this.workoutLog ? this.workoutLog.toJSON() : <any>undefined;
        return data;
    }
}

export interface IExerciseLog {
    exerciseLogId?: number;
    workoutLogId?: number | undefined;
    exerciseId?: number | undefined;
    dateCreated?: Date;
    lastModified?: Date;
    orderInSession?: number | undefined;
    orderInSuperset?: number | undefined;
    note?: string | undefined;
    numberOfSets?: number | undefined;
    weightsUsedValue?: number[] | undefined;
    numberOfRepsValue?: number[] | undefined;
    weightsUsed?: string | undefined;
    numberOfReps?: string | undefined;
    footageURLsList?: string[] | undefined;
    footageUrls?: string | undefined;
    exercise?: Exercise | undefined;
    workoutLog?: WorkoutLog | undefined;
}

export class WorkoutLog extends BaseAuditableEntity implements IWorkoutLog {
    workoutLogName?: string;
    note?: string | undefined;
    duration?: string | undefined;
    createdByNavigation?: AspNetUser | undefined;
    exerciseLogs?: ExerciseLog[];

    constructor(data?: IWorkoutLog) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.workoutLogName = _data["workoutLogName"];
            this.note = _data["note"];
            this.duration = _data["duration"];
            this.createdByNavigation = _data["createdByNavigation"] ? AspNetUser.fromJS(_data["createdByNavigation"]) : <any>undefined;
            if (Array.isArray(_data["exerciseLogs"])) {
                this.exerciseLogs = [] as any;
                for (let item of _data["exerciseLogs"])
                    this.exerciseLogs!.push(ExerciseLog.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): WorkoutLog {
        data = typeof data === 'object' ? data : {};
        let result = new WorkoutLog();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["workoutLogName"] = this.workoutLogName;
        data["note"] = this.note;
        data["duration"] = this.duration;
        data["createdByNavigation"] = this.createdByNavigation ? this.createdByNavigation.toJSON() : <any>undefined;
        if (Array.isArray(this.exerciseLogs)) {
            data["exerciseLogs"] = [];
            for (let item of this.exerciseLogs)
                data["exerciseLogs"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IWorkoutLog extends IBaseAuditableEntity {
    workoutLogName?: string;
    note?: string | undefined;
    duration?: string | undefined;
    createdByNavigation?: AspNetUser | undefined;
    exerciseLogs?: ExerciseLog[];
}

export class WorkoutTemplateExercise implements IWorkoutTemplateExercise {
    exerciseTemlateId?: number;
    workoutTemplateId?: number | undefined;
    exerciseId?: number | undefined;
    orderInSession?: number | undefined;
    orderInSuperset?: number | undefined;
    note?: string | undefined;
    setsRecommendation?: number | undefined;
    intensityPercentage?: number | undefined;
    rpeRecommendation?: number | undefined;
    weightsUsed?: string | undefined;
    numbersOfReps?: string | undefined;
    exercise?: Exercise | undefined;
    workoutTemplate?: WorkoutTemplate | undefined;

    constructor(data?: IWorkoutTemplateExercise) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.exerciseTemlateId = _data["exerciseTemlateId"];
            this.workoutTemplateId = _data["workoutTemplateId"];
            this.exerciseId = _data["exerciseId"];
            this.orderInSession = _data["orderInSession"];
            this.orderInSuperset = _data["orderInSuperset"];
            this.note = _data["note"];
            this.setsRecommendation = _data["setsRecommendation"];
            this.intensityPercentage = _data["intensityPercentage"];
            this.rpeRecommendation = _data["rpeRecommendation"];
            this.weightsUsed = _data["weightsUsed"];
            this.numbersOfReps = _data["numbersOfReps"];
            this.exercise = _data["exercise"] ? Exercise.fromJS(_data["exercise"]) : <any>undefined;
            this.workoutTemplate = _data["workoutTemplate"] ? WorkoutTemplate.fromJS(_data["workoutTemplate"]) : <any>undefined;
        }
    }

    static fromJS(data: any): WorkoutTemplateExercise {
        data = typeof data === 'object' ? data : {};
        let result = new WorkoutTemplateExercise();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exerciseTemlateId"] = this.exerciseTemlateId;
        data["workoutTemplateId"] = this.workoutTemplateId;
        data["exerciseId"] = this.exerciseId;
        data["orderInSession"] = this.orderInSession;
        data["orderInSuperset"] = this.orderInSuperset;
        data["note"] = this.note;
        data["setsRecommendation"] = this.setsRecommendation;
        data["intensityPercentage"] = this.intensityPercentage;
        data["rpeRecommendation"] = this.rpeRecommendation;
        data["weightsUsed"] = this.weightsUsed;
        data["numbersOfReps"] = this.numbersOfReps;
        data["exercise"] = this.exercise ? this.exercise.toJSON() : <any>undefined;
        data["workoutTemplate"] = this.workoutTemplate ? this.workoutTemplate.toJSON() : <any>undefined;
        return data;
    }
}

export interface IWorkoutTemplateExercise {
    exerciseTemlateId?: number;
    workoutTemplateId?: number | undefined;
    exerciseId?: number | undefined;
    orderInSession?: number | undefined;
    orderInSuperset?: number | undefined;
    note?: string | undefined;
    setsRecommendation?: number | undefined;
    intensityPercentage?: number | undefined;
    rpeRecommendation?: number | undefined;
    weightsUsed?: string | undefined;
    numbersOfReps?: string | undefined;
    exercise?: Exercise | undefined;
    workoutTemplate?: WorkoutTemplate | undefined;
}

export class WorkoutTemplate extends BaseAuditableEntity implements IWorkoutTemplate {
    templateName?: string | undefined;
    duration?: string | undefined;
    isPublic?: boolean;
    createdByNavigation?: AspNetUser;
    lastModifiedByNavigation?: AspNetUser;
    programWorkouts?: ProgramWorkout[] | undefined;
    workoutTemplateExercises?: WorkoutTemplateExercise[];

    constructor(data?: IWorkoutTemplate) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.templateName = _data["templateName"];
            this.duration = _data["duration"];
            this.isPublic = _data["isPublic"];
            this.createdByNavigation = _data["createdByNavigation"] ? AspNetUser.fromJS(_data["createdByNavigation"]) : <any>undefined;
            this.lastModifiedByNavigation = _data["lastModifiedByNavigation"] ? AspNetUser.fromJS(_data["lastModifiedByNavigation"]) : <any>undefined;
            if (Array.isArray(_data["programWorkouts"])) {
                this.programWorkouts = [] as any;
                for (let item of _data["programWorkouts"])
                    this.programWorkouts!.push(ProgramWorkout.fromJS(item));
            }
            if (Array.isArray(_data["workoutTemplateExercises"])) {
                this.workoutTemplateExercises = [] as any;
                for (let item of _data["workoutTemplateExercises"])
                    this.workoutTemplateExercises!.push(WorkoutTemplateExercise.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): WorkoutTemplate {
        data = typeof data === 'object' ? data : {};
        let result = new WorkoutTemplate();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["templateName"] = this.templateName;
        data["duration"] = this.duration;
        data["isPublic"] = this.isPublic;
        data["createdByNavigation"] = this.createdByNavigation ? this.createdByNavigation.toJSON() : <any>undefined;
        data["lastModifiedByNavigation"] = this.lastModifiedByNavigation ? this.lastModifiedByNavigation.toJSON() : <any>undefined;
        if (Array.isArray(this.programWorkouts)) {
            data["programWorkouts"] = [];
            for (let item of this.programWorkouts)
                data["programWorkouts"].push(item.toJSON());
        }
        if (Array.isArray(this.workoutTemplateExercises)) {
            data["workoutTemplateExercises"] = [];
            for (let item of this.workoutTemplateExercises)
                data["workoutTemplateExercises"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IWorkoutTemplate extends IBaseAuditableEntity {
    templateName?: string | undefined;
    duration?: string | undefined;
    isPublic?: boolean;
    createdByNavigation?: AspNetUser;
    lastModifiedByNavigation?: AspNetUser;
    programWorkouts?: ProgramWorkout[] | undefined;
    workoutTemplateExercises?: WorkoutTemplateExercise[];
}

export class ProgramWorkout implements IProgramWorkout {
    programWorkoutId?: number;
    programId?: number | undefined;
    workoutTemplateId?: number | undefined;
    weekNumber?: number | undefined;
    orderInWeek?: number | undefined;
    program?: Program | undefined;
    workoutTemplate?: WorkoutTemplate | undefined;

    constructor(data?: IProgramWorkout) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.programWorkoutId = _data["programWorkoutId"];
            this.programId = _data["programId"];
            this.workoutTemplateId = _data["workoutTemplateId"];
            this.weekNumber = _data["weekNumber"];
            this.orderInWeek = _data["orderInWeek"];
            this.program = _data["program"] ? Program.fromJS(_data["program"]) : <any>undefined;
            this.workoutTemplate = _data["workoutTemplate"] ? WorkoutTemplate.fromJS(_data["workoutTemplate"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProgramWorkout {
        data = typeof data === 'object' ? data : {};
        let result = new ProgramWorkout();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["programWorkoutId"] = this.programWorkoutId;
        data["programId"] = this.programId;
        data["workoutTemplateId"] = this.workoutTemplateId;
        data["weekNumber"] = this.weekNumber;
        data["orderInWeek"] = this.orderInWeek;
        data["program"] = this.program ? this.program.toJSON() : <any>undefined;
        data["workoutTemplate"] = this.workoutTemplate ? this.workoutTemplate.toJSON() : <any>undefined;
        return data;
    }
}

export interface IProgramWorkout {
    programWorkoutId?: number;
    programId?: number | undefined;
    workoutTemplateId?: number | undefined;
    weekNumber?: number | undefined;
    orderInWeek?: number | undefined;
    program?: Program | undefined;
    workoutTemplate?: WorkoutTemplate | undefined;
}

export class Program implements IProgram {
    programId?: number;
    userId?: string | undefined;
    programName?: string;
    programThumbnail?: string | undefined;
    numberOfWeeks?: number | undefined;
    daysPerWeek?: number | undefined;
    dateCreated?: Date;
    lastModified?: Date;
    goal?: string | undefined;
    experienceLevel?: string | undefined;
    gymType?: string | undefined;
    musclesPriority?: string | undefined;
    ageGroup?: string | undefined;
    publicProgram?: boolean | undefined;
    programEnrollments?: ProgramEnrollment[];
    programWorkouts?: ProgramWorkout[];
    user?: AspNetUser | undefined;

    constructor(data?: IProgram) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.programId = _data["programId"];
            this.userId = _data["userId"];
            this.programName = _data["programName"];
            this.programThumbnail = _data["programThumbnail"];
            this.numberOfWeeks = _data["numberOfWeeks"];
            this.daysPerWeek = _data["daysPerWeek"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.lastModified = _data["lastModified"] ? new Date(_data["lastModified"].toString()) : <any>undefined;
            this.goal = _data["goal"];
            this.experienceLevel = _data["experienceLevel"];
            this.gymType = _data["gymType"];
            this.musclesPriority = _data["musclesPriority"];
            this.ageGroup = _data["ageGroup"];
            this.publicProgram = _data["publicProgram"];
            if (Array.isArray(_data["programEnrollments"])) {
                this.programEnrollments = [] as any;
                for (let item of _data["programEnrollments"])
                    this.programEnrollments!.push(ProgramEnrollment.fromJS(item));
            }
            if (Array.isArray(_data["programWorkouts"])) {
                this.programWorkouts = [] as any;
                for (let item of _data["programWorkouts"])
                    this.programWorkouts!.push(ProgramWorkout.fromJS(item));
            }
            this.user = _data["user"] ? AspNetUser.fromJS(_data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Program {
        data = typeof data === 'object' ? data : {};
        let result = new Program();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["programId"] = this.programId;
        data["userId"] = this.userId;
        data["programName"] = this.programName;
        data["programThumbnail"] = this.programThumbnail;
        data["numberOfWeeks"] = this.numberOfWeeks;
        data["daysPerWeek"] = this.daysPerWeek;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>undefined;
        data["goal"] = this.goal;
        data["experienceLevel"] = this.experienceLevel;
        data["gymType"] = this.gymType;
        data["musclesPriority"] = this.musclesPriority;
        data["ageGroup"] = this.ageGroup;
        data["publicProgram"] = this.publicProgram;
        if (Array.isArray(this.programEnrollments)) {
            data["programEnrollments"] = [];
            for (let item of this.programEnrollments)
                data["programEnrollments"].push(item.toJSON());
        }
        if (Array.isArray(this.programWorkouts)) {
            data["programWorkouts"] = [];
            for (let item of this.programWorkouts)
                data["programWorkouts"].push(item.toJSON());
        }
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data;
    }
}

export interface IProgram {
    programId?: number;
    userId?: string | undefined;
    programName?: string;
    programThumbnail?: string | undefined;
    numberOfWeeks?: number | undefined;
    daysPerWeek?: number | undefined;
    dateCreated?: Date;
    lastModified?: Date;
    goal?: string | undefined;
    experienceLevel?: string | undefined;
    gymType?: string | undefined;
    musclesPriority?: string | undefined;
    ageGroup?: string | undefined;
    publicProgram?: boolean | undefined;
    programEnrollments?: ProgramEnrollment[];
    programWorkouts?: ProgramWorkout[];
    user?: AspNetUser | undefined;
}

export class ProgramEnrollment implements IProgramEnrollment {
    enrollmentId?: number;
    userId?: string | undefined;
    programId?: number | undefined;
    enrolledDate?: Date;
    endDate?: Date | undefined;
    status?: string;
    currentWeekNo?: number | undefined;
    currentWorkoutOrder?: number | undefined;
    program?: Program | undefined;
    user?: AspNetUser | undefined;
    workoutsProgress?: { [key: string]: WorkoutProgress; };

    constructor(data?: IProgramEnrollment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.enrollmentId = _data["enrollmentId"];
            this.userId = _data["userId"];
            this.programId = _data["programId"];
            this.enrolledDate = _data["enrolledDate"] ? new Date(_data["enrolledDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.currentWeekNo = _data["currentWeekNo"];
            this.currentWorkoutOrder = _data["currentWorkoutOrder"];
            this.program = _data["program"] ? Program.fromJS(_data["program"]) : <any>undefined;
            this.user = _data["user"] ? AspNetUser.fromJS(_data["user"]) : <any>undefined;
            if (_data["workoutsProgress"]) {
                this.workoutsProgress = {} as any;
                for (let key in _data["workoutsProgress"]) {
                    if (_data["workoutsProgress"].hasOwnProperty(key))
                        (<any>this.workoutsProgress)![key] = _data["workoutsProgress"][key] ? WorkoutProgress.fromJS(_data["workoutsProgress"][key]) : new WorkoutProgress();
                }
            }
        }
    }

    static fromJS(data: any): ProgramEnrollment {
        data = typeof data === 'object' ? data : {};
        let result = new ProgramEnrollment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["enrollmentId"] = this.enrollmentId;
        data["userId"] = this.userId;
        data["programId"] = this.programId;
        data["enrolledDate"] = this.enrolledDate ? this.enrolledDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["currentWeekNo"] = this.currentWeekNo;
        data["currentWorkoutOrder"] = this.currentWorkoutOrder;
        data["program"] = this.program ? this.program.toJSON() : <any>undefined;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        if (this.workoutsProgress) {
            data["workoutsProgress"] = {};
            for (let key in this.workoutsProgress) {
                if (this.workoutsProgress.hasOwnProperty(key))
                    (<any>data["workoutsProgress"])[key] = this.workoutsProgress[key] ? this.workoutsProgress[key].toJSON() : <any>undefined;
            }
        }
        return data;
    }
}

export interface IProgramEnrollment {
    enrollmentId?: number;
    userId?: string | undefined;
    programId?: number | undefined;
    enrolledDate?: Date;
    endDate?: Date | undefined;
    status?: string;
    currentWeekNo?: number | undefined;
    currentWorkoutOrder?: number | undefined;
    program?: Program | undefined;
    user?: AspNetUser | undefined;
    workoutsProgress?: { [key: string]: WorkoutProgress; };
}

export class WorkoutProgress implements IWorkoutProgress {
    dateCompleted?: Date;
    status?: string;
    notes?: string;

    constructor(data?: IWorkoutProgress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dateCompleted = _data["dateCompleted"] ? new Date(_data["dateCompleted"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.notes = _data["notes"];
        }
    }

    static fromJS(data: any): WorkoutProgress {
        data = typeof data === 'object' ? data : {};
        let result = new WorkoutProgress();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dateCompleted"] = this.dateCompleted ? this.dateCompleted.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["notes"] = this.notes;
        return data;
    }
}

export interface IWorkoutProgress {
    dateCompleted?: Date;
    status?: string;
    notes?: string;
}

export class ExerciseMuscleGroup implements IExerciseMuscleGroup {
    exerciseId?: number;
    muscleGroupId?: number;
    exercise?: Exercise;
    muscleGroup?: MuscleGroup;

    constructor(data?: IExerciseMuscleGroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.exerciseId = _data["exerciseId"];
            this.muscleGroupId = _data["muscleGroupId"];
            this.exercise = _data["exercise"] ? Exercise.fromJS(_data["exercise"]) : <any>undefined;
            this.muscleGroup = _data["muscleGroup"] ? MuscleGroup.fromJS(_data["muscleGroup"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ExerciseMuscleGroup {
        data = typeof data === 'object' ? data : {};
        let result = new ExerciseMuscleGroup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exerciseId"] = this.exerciseId;
        data["muscleGroupId"] = this.muscleGroupId;
        data["exercise"] = this.exercise ? this.exercise.toJSON() : <any>undefined;
        data["muscleGroup"] = this.muscleGroup ? this.muscleGroup.toJSON() : <any>undefined;
        return data;
    }
}

export interface IExerciseMuscleGroup {
    exerciseId?: number;
    muscleGroupId?: number;
    exercise?: Exercise;
    muscleGroup?: MuscleGroup;
}

export class MuscleGroup implements IMuscleGroup {
    muscleGroupId?: number;
    muscleGroupName?: string | undefined;
    imageUrl?: string | undefined;
    exerciseMuscleGroups?: ExerciseMuscleGroup[];

    constructor(data?: IMuscleGroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.muscleGroupId = _data["muscleGroupId"];
            this.muscleGroupName = _data["muscleGroupName"];
            this.imageUrl = _data["imageUrl"];
            if (Array.isArray(_data["exerciseMuscleGroups"])) {
                this.exerciseMuscleGroups = [] as any;
                for (let item of _data["exerciseMuscleGroups"])
                    this.exerciseMuscleGroups!.push(ExerciseMuscleGroup.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MuscleGroup {
        data = typeof data === 'object' ? data : {};
        let result = new MuscleGroup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["muscleGroupId"] = this.muscleGroupId;
        data["muscleGroupName"] = this.muscleGroupName;
        data["imageUrl"] = this.imageUrl;
        if (Array.isArray(this.exerciseMuscleGroups)) {
            data["exerciseMuscleGroups"] = [];
            for (let item of this.exerciseMuscleGroups)
                data["exerciseMuscleGroups"].push(item.toJSON());
        }
        return data;
    }
}

export interface IMuscleGroup {
    muscleGroupId?: number;
    muscleGroupName?: string | undefined;
    imageUrl?: string | undefined;
    exerciseMuscleGroups?: ExerciseMuscleGroup[];
}

export class Profile implements IProfile {
    profileId?: number;
    userId?: string | undefined;
    overview?: string | undefined;
    profilePicture?: string | undefined;
    user?: AspNetUser | undefined;
    majorAchievements?: string[] | undefined;
    galleryImageLinks?: string[] | undefined;
    instagram?: string | undefined;
    youtube?: string | undefined;
    patreon?: string | undefined;
    galleryImageLinksJson?: string;

    constructor(data?: IProfile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.profileId = _data["profileId"];
            this.userId = _data["userId"];
            this.overview = _data["overview"];
            this.profilePicture = _data["profilePicture"];
            this.user = _data["user"] ? AspNetUser.fromJS(_data["user"]) : <any>undefined;
            if (Array.isArray(_data["majorAchievements"])) {
                this.majorAchievements = [] as any;
                for (let item of _data["majorAchievements"])
                    this.majorAchievements!.push(item);
            }
            if (Array.isArray(_data["galleryImageLinks"])) {
                this.galleryImageLinks = [] as any;
                for (let item of _data["galleryImageLinks"])
                    this.galleryImageLinks!.push(item);
            }
            this.instagram = _data["instagram"];
            this.youtube = _data["youtube"];
            this.patreon = _data["patreon"];
            this.galleryImageLinksJson = _data["galleryImageLinksJson"];
        }
    }

    static fromJS(data: any): Profile {
        data = typeof data === 'object' ? data : {};
        let result = new Profile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["profileId"] = this.profileId;
        data["userId"] = this.userId;
        data["overview"] = this.overview;
        data["profilePicture"] = this.profilePicture;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        if (Array.isArray(this.majorAchievements)) {
            data["majorAchievements"] = [];
            for (let item of this.majorAchievements)
                data["majorAchievements"].push(item);
        }
        if (Array.isArray(this.galleryImageLinks)) {
            data["galleryImageLinks"] = [];
            for (let item of this.galleryImageLinks)
                data["galleryImageLinks"].push(item);
        }
        data["instagram"] = this.instagram;
        data["youtube"] = this.youtube;
        data["patreon"] = this.patreon;
        data["galleryImageLinksJson"] = this.galleryImageLinksJson;
        return data;
    }
}

export interface IProfile {
    profileId?: number;
    userId?: string | undefined;
    overview?: string | undefined;
    profilePicture?: string | undefined;
    user?: AspNetUser | undefined;
    majorAchievements?: string[] | undefined;
    galleryImageLinks?: string[] | undefined;
    instagram?: string | undefined;
    youtube?: string | undefined;
    patreon?: string | undefined;
    galleryImageLinksJson?: string;
}

export class CoachApplication extends BaseAuditableEntity implements ICoachApplication {
    applicantId?: string;
    applicant?: AspNetUser;
    status?: string;
    statusReason?: string | undefined;
    statusUpdatedBy?: AspNetUser | undefined;

    constructor(data?: ICoachApplication) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.applicantId = _data["applicantId"];
            this.applicant = _data["applicant"] ? AspNetUser.fromJS(_data["applicant"]) : <any>undefined;
            this.status = _data["status"];
            this.statusReason = _data["statusReason"];
            this.statusUpdatedBy = _data["statusUpdatedBy"] ? AspNetUser.fromJS(_data["statusUpdatedBy"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): CoachApplication {
        data = typeof data === 'object' ? data : {};
        let result = new CoachApplication();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["applicantId"] = this.applicantId;
        data["applicant"] = this.applicant ? this.applicant.toJSON() : <any>undefined;
        data["status"] = this.status;
        data["statusReason"] = this.statusReason;
        data["statusUpdatedBy"] = this.statusUpdatedBy ? this.statusUpdatedBy.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface ICoachApplication extends IBaseAuditableEntity {
    applicantId?: string;
    applicant?: AspNetUser;
    status?: string;
    statusReason?: string | undefined;
    statusUpdatedBy?: AspNetUser | undefined;
}

export class ChatLine implements IChatLine {
    chatLineId?: number;
    createdBy?: string;
    chatId?: number | undefined;
    chatLineText?: string | undefined;
    linkUrl?: string | undefined;
    attachmentPath?: string | undefined;
    createdAt?: Date;
    chat?: Chat | undefined;
    createdByNavigation?: AspNetUser | undefined;

    constructor(data?: IChatLine) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.chatLineId = _data["chatLineId"];
            this.createdBy = _data["createdBy"];
            this.chatId = _data["chatId"];
            this.chatLineText = _data["chatLineText"];
            this.linkUrl = _data["linkUrl"];
            this.attachmentPath = _data["attachmentPath"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.chat = _data["chat"] ? Chat.fromJS(_data["chat"]) : <any>undefined;
            this.createdByNavigation = _data["createdByNavigation"] ? AspNetUser.fromJS(_data["createdByNavigation"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ChatLine {
        data = typeof data === 'object' ? data : {};
        let result = new ChatLine();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["chatLineId"] = this.chatLineId;
        data["createdBy"] = this.createdBy;
        data["chatId"] = this.chatId;
        data["chatLineText"] = this.chatLineText;
        data["linkUrl"] = this.linkUrl;
        data["attachmentPath"] = this.attachmentPath;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["chat"] = this.chat ? this.chat.toJSON() : <any>undefined;
        data["createdByNavigation"] = this.createdByNavigation ? this.createdByNavigation.toJSON() : <any>undefined;
        return data;
    }
}

export interface IChatLine {
    chatLineId?: number;
    createdBy?: string;
    chatId?: number | undefined;
    chatLineText?: string | undefined;
    linkUrl?: string | undefined;
    attachmentPath?: string | undefined;
    createdAt?: Date;
    chat?: Chat | undefined;
    createdByNavigation?: AspNetUser | undefined;
}

export class Chat implements IChat {
    chatId?: number;
    createdBy?: string;
    targetUserId?: string;
    createdAt?: Date;
    chatLines?: ChatLine[];

    constructor(data?: IChat) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.chatId = _data["chatId"];
            this.createdBy = _data["createdBy"];
            this.targetUserId = _data["targetUserId"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            if (Array.isArray(_data["chatLines"])) {
                this.chatLines = [] as any;
                for (let item of _data["chatLines"])
                    this.chatLines!.push(ChatLine.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Chat {
        data = typeof data === 'object' ? data : {};
        let result = new Chat();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["chatId"] = this.chatId;
        data["createdBy"] = this.createdBy;
        data["targetUserId"] = this.targetUserId;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        if (Array.isArray(this.chatLines)) {
            data["chatLines"] = [];
            for (let item of this.chatLines)
                data["chatLines"].push(item.toJSON());
        }
        return data;
    }
}

export interface IChat {
    chatId?: number;
    createdBy?: string;
    targetUserId?: string;
    createdAt?: Date;
    chatLines?: ChatLine[];
}

export class PaginatedListOfWorkoutLogDTO implements IPaginatedListOfWorkoutLogDTO {
    items?: WorkoutLogDTO[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfWorkoutLogDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(WorkoutLogDTO.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfWorkoutLogDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfWorkoutLogDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfWorkoutLogDTO {
    items?: WorkoutLogDTO[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class WorkoutLogDTO implements IWorkoutLogDTO {
    id?: number;
    createdBy?: string | undefined;
    note?: string | undefined;
    duration?: string | undefined;
    created?: Date;
    lastModified?: Date | undefined;
    exerciseLogs?: ExerciseLogDTO[];

    constructor(data?: IWorkoutLogDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdBy = _data["createdBy"];
            this.note = _data["note"];
            this.duration = _data["duration"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.lastModified = _data["lastModified"] ? new Date(_data["lastModified"].toString()) : <any>undefined;
            if (Array.isArray(_data["exerciseLogs"])) {
                this.exerciseLogs = [] as any;
                for (let item of _data["exerciseLogs"])
                    this.exerciseLogs!.push(ExerciseLogDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WorkoutLogDTO {
        data = typeof data === 'object' ? data : {};
        let result = new WorkoutLogDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdBy"] = this.createdBy;
        data["note"] = this.note;
        data["duration"] = this.duration;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>undefined;
        if (Array.isArray(this.exerciseLogs)) {
            data["exerciseLogs"] = [];
            for (let item of this.exerciseLogs)
                data["exerciseLogs"].push(item.toJSON());
        }
        return data;
    }
}

export interface IWorkoutLogDTO {
    id?: number;
    createdBy?: string | undefined;
    note?: string | undefined;
    duration?: string | undefined;
    created?: Date;
    lastModified?: Date | undefined;
    exerciseLogs?: ExerciseLogDTO[];
}

export class WorkoutLogDetailsDto implements IWorkoutLogDetailsDto {
    id?: number;
    workoutLogName?: string;
    note?: string | undefined;
    duration?: string | undefined;
    createdBy?: string | undefined;
    created?: Date;
    lastModified?: Date;
    exerciseLogs?: ExerciseLogDTO[];

    constructor(data?: IWorkoutLogDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.workoutLogName = _data["workoutLogName"];
            this.note = _data["note"];
            this.duration = _data["duration"];
            this.createdBy = _data["createdBy"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.lastModified = _data["lastModified"] ? new Date(_data["lastModified"].toString()) : <any>undefined;
            if (Array.isArray(_data["exerciseLogs"])) {
                this.exerciseLogs = [] as any;
                for (let item of _data["exerciseLogs"])
                    this.exerciseLogs!.push(ExerciseLogDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WorkoutLogDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkoutLogDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["workoutLogName"] = this.workoutLogName;
        data["note"] = this.note;
        data["duration"] = this.duration;
        data["createdBy"] = this.createdBy;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>undefined;
        if (Array.isArray(this.exerciseLogs)) {
            data["exerciseLogs"] = [];
            for (let item of this.exerciseLogs)
                data["exerciseLogs"].push(item.toJSON());
        }
        return data;
    }
}

export interface IWorkoutLogDetailsDto {
    id?: number;
    workoutLogName?: string;
    note?: string | undefined;
    duration?: string | undefined;
    createdBy?: string | undefined;
    created?: Date;
    lastModified?: Date;
    exerciseLogs?: ExerciseLogDTO[];
}

export class CreateWorkoutLogCommandDTO implements ICreateWorkoutLogCommandDTO {
    workoutLogName?: string | undefined;
    note?: string | undefined;
    duration?: string | undefined;
    exerciseLogs?: CreateExerciseLogCommand[] | undefined;

    constructor(data?: ICreateWorkoutLogCommandDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.workoutLogName = _data["workoutLogName"];
            this.note = _data["note"];
            this.duration = _data["duration"];
            if (Array.isArray(_data["exerciseLogs"])) {
                this.exerciseLogs = [] as any;
                for (let item of _data["exerciseLogs"])
                    this.exerciseLogs!.push(CreateExerciseLogCommand.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateWorkoutLogCommandDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CreateWorkoutLogCommandDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["workoutLogName"] = this.workoutLogName;
        data["note"] = this.note;
        data["duration"] = this.duration;
        if (Array.isArray(this.exerciseLogs)) {
            data["exerciseLogs"] = [];
            for (let item of this.exerciseLogs)
                data["exerciseLogs"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICreateWorkoutLogCommandDTO {
    workoutLogName?: string | undefined;
    note?: string | undefined;
    duration?: string | undefined;
    exerciseLogs?: CreateExerciseLogCommand[] | undefined;
}

export class CreateExerciseLogCommand implements ICreateExerciseLogCommand {
    exerciseId?: number | undefined;
    orderInSession?: number | undefined;
    orderInSuperset?: number | undefined;
    note?: string | undefined;
    numberOfSets?: number | undefined;
    weightsUsed?: string | undefined;
    numberOfReps?: string | undefined;
    footageUrls?: string | undefined;

    constructor(data?: ICreateExerciseLogCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.exerciseId = _data["exerciseId"];
            this.orderInSession = _data["orderInSession"];
            this.orderInSuperset = _data["orderInSuperset"];
            this.note = _data["note"];
            this.numberOfSets = _data["numberOfSets"];
            this.weightsUsed = _data["weightsUsed"];
            this.numberOfReps = _data["numberOfReps"];
            this.footageUrls = _data["footageUrls"];
        }
    }

    static fromJS(data: any): CreateExerciseLogCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateExerciseLogCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exerciseId"] = this.exerciseId;
        data["orderInSession"] = this.orderInSession;
        data["orderInSuperset"] = this.orderInSuperset;
        data["note"] = this.note;
        data["numberOfSets"] = this.numberOfSets;
        data["weightsUsed"] = this.weightsUsed;
        data["numberOfReps"] = this.numberOfReps;
        data["footageUrls"] = this.footageUrls;
        return data;
    }
}

export interface ICreateExerciseLogCommand {
    exerciseId?: number | undefined;
    orderInSession?: number | undefined;
    orderInSuperset?: number | undefined;
    note?: string | undefined;
    numberOfSets?: number | undefined;
    weightsUsed?: string | undefined;
    numberOfReps?: string | undefined;
    footageUrls?: string | undefined;
}

export class UpdateWorkoutLogCommand implements IUpdateWorkoutLogCommand {
    workoutLogId?: number;
    note?: string | undefined;
    duration?: string | undefined;
    exerciseLogs?: UpdateExerciseLogCommand[] | undefined;

    constructor(data?: IUpdateWorkoutLogCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.workoutLogId = _data["workoutLogId"];
            this.note = _data["note"];
            this.duration = _data["duration"];
            if (Array.isArray(_data["exerciseLogs"])) {
                this.exerciseLogs = [] as any;
                for (let item of _data["exerciseLogs"])
                    this.exerciseLogs!.push(UpdateExerciseLogCommand.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateWorkoutLogCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateWorkoutLogCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["workoutLogId"] = this.workoutLogId;
        data["note"] = this.note;
        data["duration"] = this.duration;
        if (Array.isArray(this.exerciseLogs)) {
            data["exerciseLogs"] = [];
            for (let item of this.exerciseLogs)
                data["exerciseLogs"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUpdateWorkoutLogCommand {
    workoutLogId?: number;
    note?: string | undefined;
    duration?: string | undefined;
    exerciseLogs?: UpdateExerciseLogCommand[] | undefined;
}

export class UpdateExerciseLogCommand implements IUpdateExerciseLogCommand {
    exerciseLogId?: number | undefined;
    exerciseId?: number | undefined;
    orderInSession?: number | undefined;
    orderInSuperset?: number | undefined;
    note?: string | undefined;
    numberOfSets?: number | undefined;
    weightsUsed?: string | undefined;
    numberOfReps?: string | undefined;
    footageUrls?: string | undefined;
    isDeleted?: boolean;

    constructor(data?: IUpdateExerciseLogCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.exerciseLogId = _data["exerciseLogId"];
            this.exerciseId = _data["exerciseId"];
            this.orderInSession = _data["orderInSession"];
            this.orderInSuperset = _data["orderInSuperset"];
            this.note = _data["note"];
            this.numberOfSets = _data["numberOfSets"];
            this.weightsUsed = _data["weightsUsed"];
            this.numberOfReps = _data["numberOfReps"];
            this.footageUrls = _data["footageUrls"];
            this.isDeleted = _data["isDeleted"];
        }
    }

    static fromJS(data: any): UpdateExerciseLogCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateExerciseLogCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exerciseLogId"] = this.exerciseLogId;
        data["exerciseId"] = this.exerciseId;
        data["orderInSession"] = this.orderInSession;
        data["orderInSuperset"] = this.orderInSuperset;
        data["note"] = this.note;
        data["numberOfSets"] = this.numberOfSets;
        data["weightsUsed"] = this.weightsUsed;
        data["numberOfReps"] = this.numberOfReps;
        data["footageUrls"] = this.footageUrls;
        data["isDeleted"] = this.isDeleted;
        return data;
    }
}

export interface IUpdateExerciseLogCommand {
    exerciseLogId?: number | undefined;
    exerciseId?: number | undefined;
    orderInSession?: number | undefined;
    orderInSuperset?: number | undefined;
    note?: string | undefined;
    numberOfSets?: number | undefined;
    weightsUsed?: string | undefined;
    numberOfReps?: string | undefined;
    footageUrls?: string | undefined;
    isDeleted?: boolean;
}

export class DeleteWorkoutLogCommand implements IDeleteWorkoutLogCommand {
    workoutLogId?: number;

    constructor(data?: IDeleteWorkoutLogCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.workoutLogId = _data["workoutLogId"];
        }
    }

    static fromJS(data: any): DeleteWorkoutLogCommand {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteWorkoutLogCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["workoutLogId"] = this.workoutLogId;
        return data;
    }
}

export interface IDeleteWorkoutLogCommand {
    workoutLogId?: number;
}

export class WorkoutProgramListDTO implements IWorkoutProgramListDTO {
    programId?: number;
    programName?: string;
    programThumbnail?: string | undefined;
    numberOfWeeks?: number | undefined;
    daysPerWeek?: number | undefined;
    goal?: string | undefined;
    experienceLevel?: string | undefined;
    gymType?: string | undefined;
    musclesPriority?: string | undefined;
    ageGroup?: string | undefined;
    publicProgram?: boolean | undefined;
    userId?: string | undefined;
    userName?: string | undefined;
    creatorFullName?: string | undefined;

    constructor(data?: IWorkoutProgramListDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.programId = _data["programId"];
            this.programName = _data["programName"];
            this.programThumbnail = _data["programThumbnail"];
            this.numberOfWeeks = _data["numberOfWeeks"];
            this.daysPerWeek = _data["daysPerWeek"];
            this.goal = _data["goal"];
            this.experienceLevel = _data["experienceLevel"];
            this.gymType = _data["gymType"];
            this.musclesPriority = _data["musclesPriority"];
            this.ageGroup = _data["ageGroup"];
            this.publicProgram = _data["publicProgram"];
            this.userId = _data["userId"];
            this.userName = _data["userName"];
            this.creatorFullName = _data["creatorFullName"];
        }
    }

    static fromJS(data: any): WorkoutProgramListDTO {
        data = typeof data === 'object' ? data : {};
        let result = new WorkoutProgramListDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["programId"] = this.programId;
        data["programName"] = this.programName;
        data["programThumbnail"] = this.programThumbnail;
        data["numberOfWeeks"] = this.numberOfWeeks;
        data["daysPerWeek"] = this.daysPerWeek;
        data["goal"] = this.goal;
        data["experienceLevel"] = this.experienceLevel;
        data["gymType"] = this.gymType;
        data["musclesPriority"] = this.musclesPriority;
        data["ageGroup"] = this.ageGroup;
        data["publicProgram"] = this.publicProgram;
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["creatorFullName"] = this.creatorFullName;
        return data;
    }
}

export interface IWorkoutProgramListDTO {
    programId?: number;
    programName?: string;
    programThumbnail?: string | undefined;
    numberOfWeeks?: number | undefined;
    daysPerWeek?: number | undefined;
    goal?: string | undefined;
    experienceLevel?: string | undefined;
    gymType?: string | undefined;
    musclesPriority?: string | undefined;
    ageGroup?: string | undefined;
    publicProgram?: boolean | undefined;
    userId?: string | undefined;
    userName?: string | undefined;
    creatorFullName?: string | undefined;
}

export class CreateWorkoutProgramCommand implements ICreateWorkoutProgramCommand {
    programName?: string;
    programThumbnail?: string | undefined;
    numberOfWeeks?: number | undefined;
    daysPerWeek?: number | undefined;
    goal?: string | undefined;
    experienceLevel?: string | undefined;
    gymType?: string | undefined;
    musclesPriority?: string | undefined;
    ageGroup?: string | undefined;
    publicProgram?: boolean | undefined;
    programWorkouts?: CreateProgramWorkoutCommand[];

    constructor(data?: ICreateWorkoutProgramCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.programName = _data["programName"];
            this.programThumbnail = _data["programThumbnail"];
            this.numberOfWeeks = _data["numberOfWeeks"];
            this.daysPerWeek = _data["daysPerWeek"];
            this.goal = _data["goal"];
            this.experienceLevel = _data["experienceLevel"];
            this.gymType = _data["gymType"];
            this.musclesPriority = _data["musclesPriority"];
            this.ageGroup = _data["ageGroup"];
            this.publicProgram = _data["publicProgram"];
            if (Array.isArray(_data["programWorkouts"])) {
                this.programWorkouts = [] as any;
                for (let item of _data["programWorkouts"])
                    this.programWorkouts!.push(CreateProgramWorkoutCommand.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateWorkoutProgramCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateWorkoutProgramCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["programName"] = this.programName;
        data["programThumbnail"] = this.programThumbnail;
        data["numberOfWeeks"] = this.numberOfWeeks;
        data["daysPerWeek"] = this.daysPerWeek;
        data["goal"] = this.goal;
        data["experienceLevel"] = this.experienceLevel;
        data["gymType"] = this.gymType;
        data["musclesPriority"] = this.musclesPriority;
        data["ageGroup"] = this.ageGroup;
        data["publicProgram"] = this.publicProgram;
        if (Array.isArray(this.programWorkouts)) {
            data["programWorkouts"] = [];
            for (let item of this.programWorkouts)
                data["programWorkouts"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICreateWorkoutProgramCommand {
    programName?: string;
    programThumbnail?: string | undefined;
    numberOfWeeks?: number | undefined;
    daysPerWeek?: number | undefined;
    goal?: string | undefined;
    experienceLevel?: string | undefined;
    gymType?: string | undefined;
    musclesPriority?: string | undefined;
    ageGroup?: string | undefined;
    publicProgram?: boolean | undefined;
    programWorkouts?: CreateProgramWorkoutCommand[];
}

export class CreateProgramWorkoutCommand implements ICreateProgramWorkoutCommand {
    weekNumber?: number | undefined;
    orderInWeek?: number | undefined;
    workoutTemplate?: CreateWorkoutTemplateCommand | undefined;

    constructor(data?: ICreateProgramWorkoutCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.weekNumber = _data["weekNumber"];
            this.orderInWeek = _data["orderInWeek"];
            this.workoutTemplate = _data["workoutTemplate"] ? CreateWorkoutTemplateCommand.fromJS(_data["workoutTemplate"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateProgramWorkoutCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProgramWorkoutCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["weekNumber"] = this.weekNumber;
        data["orderInWeek"] = this.orderInWeek;
        data["workoutTemplate"] = this.workoutTemplate ? this.workoutTemplate.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICreateProgramWorkoutCommand {
    weekNumber?: number | undefined;
    orderInWeek?: number | undefined;
    workoutTemplate?: CreateWorkoutTemplateCommand | undefined;
}

export class CreateWorkoutTemplateCommand implements ICreateWorkoutTemplateCommand {
    templateName?: string | undefined;
    duration?: string | undefined;
    isPublic?: boolean;
    workoutTemplateExercises?: WorkoutTemplateExerciseDto[];

    constructor(data?: ICreateWorkoutTemplateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.templateName = _data["templateName"];
            this.duration = _data["duration"];
            this.isPublic = _data["isPublic"];
            if (Array.isArray(_data["workoutTemplateExercises"])) {
                this.workoutTemplateExercises = [] as any;
                for (let item of _data["workoutTemplateExercises"])
                    this.workoutTemplateExercises!.push(WorkoutTemplateExerciseDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateWorkoutTemplateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateWorkoutTemplateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["templateName"] = this.templateName;
        data["duration"] = this.duration;
        data["isPublic"] = this.isPublic;
        if (Array.isArray(this.workoutTemplateExercises)) {
            data["workoutTemplateExercises"] = [];
            for (let item of this.workoutTemplateExercises)
                data["workoutTemplateExercises"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICreateWorkoutTemplateCommand {
    templateName?: string | undefined;
    duration?: string | undefined;
    isPublic?: boolean;
    workoutTemplateExercises?: WorkoutTemplateExerciseDto[];
}

export class WorkoutTemplateExerciseDto implements IWorkoutTemplateExerciseDto {
    exerciseId?: number | undefined;
    orderInSession?: number | undefined;
    orderInSuperset?: number | undefined;
    note?: string | undefined;
    setsRecommendation?: number | undefined;
    intensityPercentage?: number | undefined;
    rpeRecommendation?: number | undefined;
    weightsUsed?: string | undefined;
    numbersOfReps?: string | undefined;

    constructor(data?: IWorkoutTemplateExerciseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.exerciseId = _data["exerciseId"];
            this.orderInSession = _data["orderInSession"];
            this.orderInSuperset = _data["orderInSuperset"];
            this.note = _data["note"];
            this.setsRecommendation = _data["setsRecommendation"];
            this.intensityPercentage = _data["intensityPercentage"];
            this.rpeRecommendation = _data["rpeRecommendation"];
            this.weightsUsed = _data["weightsUsed"];
            this.numbersOfReps = _data["numbersOfReps"];
        }
    }

    static fromJS(data: any): WorkoutTemplateExerciseDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkoutTemplateExerciseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exerciseId"] = this.exerciseId;
        data["orderInSession"] = this.orderInSession;
        data["orderInSuperset"] = this.orderInSuperset;
        data["note"] = this.note;
        data["setsRecommendation"] = this.setsRecommendation;
        data["intensityPercentage"] = this.intensityPercentage;
        data["rpeRecommendation"] = this.rpeRecommendation;
        data["weightsUsed"] = this.weightsUsed;
        data["numbersOfReps"] = this.numbersOfReps;
        return data;
    }
}

export interface IWorkoutTemplateExerciseDto {
    exerciseId?: number | undefined;
    orderInSession?: number | undefined;
    orderInSuperset?: number | undefined;
    note?: string | undefined;
    setsRecommendation?: number | undefined;
    intensityPercentage?: number | undefined;
    rpeRecommendation?: number | undefined;
    weightsUsed?: string | undefined;
    numbersOfReps?: string | undefined;
}

export class ProgramEnrollmentDTO implements IProgramEnrollmentDTO {
    enrollmentId?: number;
    userId?: string;
    programId?: number;
    enrolledDate?: Date;
    endDate?: Date | undefined;
    status?: string;
    currentWeekNo?: number | undefined;
    currentWorkoutOrder?: number | undefined;
    programName?: string;
    userName?: string;

    constructor(data?: IProgramEnrollmentDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.enrollmentId = _data["enrollmentId"];
            this.userId = _data["userId"];
            this.programId = _data["programId"];
            this.enrolledDate = _data["enrolledDate"] ? new Date(_data["enrolledDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.currentWeekNo = _data["currentWeekNo"];
            this.currentWorkoutOrder = _data["currentWorkoutOrder"];
            this.programName = _data["programName"];
            this.userName = _data["userName"];
        }
    }

    static fromJS(data: any): ProgramEnrollmentDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ProgramEnrollmentDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["enrollmentId"] = this.enrollmentId;
        data["userId"] = this.userId;
        data["programId"] = this.programId;
        data["enrolledDate"] = this.enrolledDate ? this.enrolledDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["currentWeekNo"] = this.currentWeekNo;
        data["currentWorkoutOrder"] = this.currentWorkoutOrder;
        data["programName"] = this.programName;
        data["userName"] = this.userName;
        return data;
    }
}

export interface IProgramEnrollmentDTO {
    enrollmentId?: number;
    userId?: string;
    programId?: number;
    enrolledDate?: Date;
    endDate?: Date | undefined;
    status?: string;
    currentWeekNo?: number | undefined;
    currentWorkoutOrder?: number | undefined;
    programName?: string;
    userName?: string;
}

export class UpdateWorkoutProgramCommand implements IUpdateWorkoutProgramCommand {
    id?: number;
    programName?: string;
    programThumbnail?: string | undefined;
    numberOfWeeks?: number | undefined;
    daysPerWeek?: number | undefined;
    goal?: string | undefined;
    experienceLevel?: string | undefined;
    gymType?: string | undefined;
    musclesPriority?: string | undefined;
    ageGroup?: string | undefined;
    publicProgram?: boolean | undefined;

    constructor(data?: IUpdateWorkoutProgramCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.programName = _data["programName"];
            this.programThumbnail = _data["programThumbnail"];
            this.numberOfWeeks = _data["numberOfWeeks"];
            this.daysPerWeek = _data["daysPerWeek"];
            this.goal = _data["goal"];
            this.experienceLevel = _data["experienceLevel"];
            this.gymType = _data["gymType"];
            this.musclesPriority = _data["musclesPriority"];
            this.ageGroup = _data["ageGroup"];
            this.publicProgram = _data["publicProgram"];
        }
    }

    static fromJS(data: any): UpdateWorkoutProgramCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateWorkoutProgramCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["programName"] = this.programName;
        data["programThumbnail"] = this.programThumbnail;
        data["numberOfWeeks"] = this.numberOfWeeks;
        data["daysPerWeek"] = this.daysPerWeek;
        data["goal"] = this.goal;
        data["experienceLevel"] = this.experienceLevel;
        data["gymType"] = this.gymType;
        data["musclesPriority"] = this.musclesPriority;
        data["ageGroup"] = this.ageGroup;
        data["publicProgram"] = this.publicProgram;
        return data;
    }
}

export interface IUpdateWorkoutProgramCommand {
    id?: number;
    programName?: string;
    programThumbnail?: string | undefined;
    numberOfWeeks?: number | undefined;
    daysPerWeek?: number | undefined;
    goal?: string | undefined;
    experienceLevel?: string | undefined;
    gymType?: string | undefined;
    musclesPriority?: string | undefined;
    ageGroup?: string | undefined;
    publicProgram?: boolean | undefined;
}

export class EnrollProgramCommand implements IEnrollProgramCommand {
    programId?: number;

    constructor(data?: IEnrollProgramCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.programId = _data["programId"];
        }
    }

    static fromJS(data: any): EnrollProgramCommand {
        data = typeof data === 'object' ? data : {};
        let result = new EnrollProgramCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["programId"] = this.programId;
        return data;
    }
}

export interface IEnrollProgramCommand {
    programId?: number;
}

export class UpdateEnrollmentProgressCommand implements IUpdateEnrollmentProgressCommand {
    enrollmentId?: number;
    workoutsProgress?: { [key: string]: WorkoutProgress; };

    constructor(data?: IUpdateEnrollmentProgressCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.enrollmentId = _data["enrollmentId"];
            if (_data["workoutsProgress"]) {
                this.workoutsProgress = {} as any;
                for (let key in _data["workoutsProgress"]) {
                    if (_data["workoutsProgress"].hasOwnProperty(key))
                        (<any>this.workoutsProgress)![key] = _data["workoutsProgress"][key] ? WorkoutProgress.fromJS(_data["workoutsProgress"][key]) : new WorkoutProgress();
                }
            }
        }
    }

    static fromJS(data: any): UpdateEnrollmentProgressCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateEnrollmentProgressCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["enrollmentId"] = this.enrollmentId;
        if (this.workoutsProgress) {
            data["workoutsProgress"] = {};
            for (let key in this.workoutsProgress) {
                if (this.workoutsProgress.hasOwnProperty(key))
                    (<any>data["workoutsProgress"])[key] = this.workoutsProgress[key] ? this.workoutsProgress[key].toJSON() : <any>undefined;
            }
        }
        return data;
    }
}

export interface IUpdateEnrollmentProgressCommand {
    enrollmentId?: number;
    workoutsProgress?: { [key: string]: WorkoutProgress; };
}

export class UpdateEnrollmentCurrentWorkoutCommand implements IUpdateEnrollmentCurrentWorkoutCommand {
    enrollmentId?: number;
    currentWeekNo?: number;
    currentWorkoutOrder?: number;

    constructor(data?: IUpdateEnrollmentCurrentWorkoutCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.enrollmentId = _data["enrollmentId"];
            this.currentWeekNo = _data["currentWeekNo"];
            this.currentWorkoutOrder = _data["currentWorkoutOrder"];
        }
    }

    static fromJS(data: any): UpdateEnrollmentCurrentWorkoutCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateEnrollmentCurrentWorkoutCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["enrollmentId"] = this.enrollmentId;
        data["currentWeekNo"] = this.currentWeekNo;
        data["currentWorkoutOrder"] = this.currentWorkoutOrder;
        return data;
    }
}

export interface IUpdateEnrollmentCurrentWorkoutCommand {
    enrollmentId?: number;
    currentWeekNo?: number;
    currentWorkoutOrder?: number;
}

export class UpdateEnrollmentStatusCommand implements IUpdateEnrollmentStatusCommand {
    enrollmentId?: number;
    newStatus?: string;

    constructor(data?: IUpdateEnrollmentStatusCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.enrollmentId = _data["enrollmentId"];
            this.newStatus = _data["newStatus"];
        }
    }

    static fromJS(data: any): UpdateEnrollmentStatusCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateEnrollmentStatusCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["enrollmentId"] = this.enrollmentId;
        data["newStatus"] = this.newStatus;
        return data;
    }
}

export interface IUpdateEnrollmentStatusCommand {
    enrollmentId?: number;
    newStatus?: string;
}

export class CreatePersonalTemplateCommand implements ICreatePersonalTemplateCommand {
    templateName?: string | undefined;
    duration?: string | undefined;
    workoutTemplateExercises?: PersonalTemplateExerciseDto[];

    constructor(data?: ICreatePersonalTemplateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.templateName = _data["templateName"];
            this.duration = _data["duration"];
            if (Array.isArray(_data["workoutTemplateExercises"])) {
                this.workoutTemplateExercises = [] as any;
                for (let item of _data["workoutTemplateExercises"])
                    this.workoutTemplateExercises!.push(PersonalTemplateExerciseDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreatePersonalTemplateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePersonalTemplateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["templateName"] = this.templateName;
        data["duration"] = this.duration;
        if (Array.isArray(this.workoutTemplateExercises)) {
            data["workoutTemplateExercises"] = [];
            for (let item of this.workoutTemplateExercises)
                data["workoutTemplateExercises"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICreatePersonalTemplateCommand {
    templateName?: string | undefined;
    duration?: string | undefined;
    workoutTemplateExercises?: PersonalTemplateExerciseDto[];
}

export class PersonalTemplateExerciseDto implements IPersonalTemplateExerciseDto {
    exerciseId?: number | undefined;
    orderInSession?: number | undefined;
    orderInSuperset?: number | undefined;
    note?: string | undefined;
    setsRecommendation?: number | undefined;
    intensityPercentage?: number | undefined;
    rpeRecommendation?: number | undefined;
    weightsUsed?: string | undefined;
    numbersOfReps?: string | undefined;

    constructor(data?: IPersonalTemplateExerciseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.exerciseId = _data["exerciseId"];
            this.orderInSession = _data["orderInSession"];
            this.orderInSuperset = _data["orderInSuperset"];
            this.note = _data["note"];
            this.setsRecommendation = _data["setsRecommendation"];
            this.intensityPercentage = _data["intensityPercentage"];
            this.rpeRecommendation = _data["rpeRecommendation"];
            this.weightsUsed = _data["weightsUsed"];
            this.numbersOfReps = _data["numbersOfReps"];
        }
    }

    static fromJS(data: any): PersonalTemplateExerciseDto {
        data = typeof data === 'object' ? data : {};
        let result = new PersonalTemplateExerciseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exerciseId"] = this.exerciseId;
        data["orderInSession"] = this.orderInSession;
        data["orderInSuperset"] = this.orderInSuperset;
        data["note"] = this.note;
        data["setsRecommendation"] = this.setsRecommendation;
        data["intensityPercentage"] = this.intensityPercentage;
        data["rpeRecommendation"] = this.rpeRecommendation;
        data["weightsUsed"] = this.weightsUsed;
        data["numbersOfReps"] = this.numbersOfReps;
        return data;
    }
}

export interface IPersonalTemplateExerciseDto {
    exerciseId?: number | undefined;
    orderInSession?: number | undefined;
    orderInSuperset?: number | undefined;
    note?: string | undefined;
    setsRecommendation?: number | undefined;
    intensityPercentage?: number | undefined;
    rpeRecommendation?: number | undefined;
    weightsUsed?: string | undefined;
    numbersOfReps?: string | undefined;
}

export class UpdateWorkoutTemplateCommand implements IUpdateWorkoutTemplateCommand {
    id?: number;
    templateName?: string | undefined;
    duration?: string | undefined;
    isPublic?: boolean;
    workoutTemplateExercises?: WorkoutTemplateExerciseDto2[];

    constructor(data?: IUpdateWorkoutTemplateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.templateName = _data["templateName"];
            this.duration = _data["duration"];
            this.isPublic = _data["isPublic"];
            if (Array.isArray(_data["workoutTemplateExercises"])) {
                this.workoutTemplateExercises = [] as any;
                for (let item of _data["workoutTemplateExercises"])
                    this.workoutTemplateExercises!.push(WorkoutTemplateExerciseDto2.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateWorkoutTemplateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateWorkoutTemplateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["templateName"] = this.templateName;
        data["duration"] = this.duration;
        data["isPublic"] = this.isPublic;
        if (Array.isArray(this.workoutTemplateExercises)) {
            data["workoutTemplateExercises"] = [];
            for (let item of this.workoutTemplateExercises)
                data["workoutTemplateExercises"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUpdateWorkoutTemplateCommand {
    id?: number;
    templateName?: string | undefined;
    duration?: string | undefined;
    isPublic?: boolean;
    workoutTemplateExercises?: WorkoutTemplateExerciseDto2[];
}

export class WorkoutTemplateExerciseDto2 implements IWorkoutTemplateExerciseDto2 {
    exerciseId?: number | undefined;
    orderInSession?: number | undefined;
    orderInSuperset?: number | undefined;
    note?: string | undefined;
    setsRecommendation?: number | undefined;
    intensityPercentage?: number | undefined;
    rpeRecommendation?: number | undefined;
    weightsUsed?: string | undefined;
    numbersOfReps?: string | undefined;
    isDeleted?: boolean;

    constructor(data?: IWorkoutTemplateExerciseDto2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.exerciseId = _data["exerciseId"];
            this.orderInSession = _data["orderInSession"];
            this.orderInSuperset = _data["orderInSuperset"];
            this.note = _data["note"];
            this.setsRecommendation = _data["setsRecommendation"];
            this.intensityPercentage = _data["intensityPercentage"];
            this.rpeRecommendation = _data["rpeRecommendation"];
            this.weightsUsed = _data["weightsUsed"];
            this.numbersOfReps = _data["numbersOfReps"];
            this.isDeleted = _data["isDeleted"];
        }
    }

    static fromJS(data: any): WorkoutTemplateExerciseDto2 {
        data = typeof data === 'object' ? data : {};
        let result = new WorkoutTemplateExerciseDto2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exerciseId"] = this.exerciseId;
        data["orderInSession"] = this.orderInSession;
        data["orderInSuperset"] = this.orderInSuperset;
        data["note"] = this.note;
        data["setsRecommendation"] = this.setsRecommendation;
        data["intensityPercentage"] = this.intensityPercentage;
        data["rpeRecommendation"] = this.rpeRecommendation;
        data["weightsUsed"] = this.weightsUsed;
        data["numbersOfReps"] = this.numbersOfReps;
        data["isDeleted"] = this.isDeleted;
        return data;
    }
}

export interface IWorkoutTemplateExerciseDto2 {
    exerciseId?: number | undefined;
    orderInSession?: number | undefined;
    orderInSuperset?: number | undefined;
    note?: string | undefined;
    setsRecommendation?: number | undefined;
    intensityPercentage?: number | undefined;
    rpeRecommendation?: number | undefined;
    weightsUsed?: string | undefined;
    numbersOfReps?: string | undefined;
    isDeleted?: boolean;
}

export class PaginatedListOfWorkoutTemplateListDto implements IPaginatedListOfWorkoutTemplateListDto {
    items?: WorkoutTemplateListDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfWorkoutTemplateListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(WorkoutTemplateListDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfWorkoutTemplateListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfWorkoutTemplateListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfWorkoutTemplateListDto {
    items?: WorkoutTemplateListDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class WorkoutTemplateListDto implements IWorkoutTemplateListDto {
    id?: number;
    templateName?: string | undefined;
    duration?: string | undefined;
    creatorName?: string;

    constructor(data?: IWorkoutTemplateListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.templateName = _data["templateName"];
            this.duration = _data["duration"];
            this.creatorName = _data["creatorName"];
        }
    }

    static fromJS(data: any): WorkoutTemplateListDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkoutTemplateListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["templateName"] = this.templateName;
        data["duration"] = this.duration;
        data["creatorName"] = this.creatorName;
        return data;
    }
}

export interface IWorkoutTemplateListDto {
    id?: number;
    templateName?: string | undefined;
    duration?: string | undefined;
    creatorName?: string;
}

export class WorkoutTemplateDetailsDto implements IWorkoutTemplateDetailsDto {
    id?: number;
    templateName?: string | undefined;
    duration?: string | undefined;
    creatorName?: string;
    createdBy?: string;
    workoutTemplateExercises?: WorkoutTemplateExerciseDTO[];

    constructor(data?: IWorkoutTemplateDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.templateName = _data["templateName"];
            this.duration = _data["duration"];
            this.creatorName = _data["creatorName"];
            this.createdBy = _data["createdBy"];
            if (Array.isArray(_data["workoutTemplateExercises"])) {
                this.workoutTemplateExercises = [] as any;
                for (let item of _data["workoutTemplateExercises"])
                    this.workoutTemplateExercises!.push(WorkoutTemplateExerciseDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WorkoutTemplateDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkoutTemplateDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["templateName"] = this.templateName;
        data["duration"] = this.duration;
        data["creatorName"] = this.creatorName;
        data["createdBy"] = this.createdBy;
        if (Array.isArray(this.workoutTemplateExercises)) {
            data["workoutTemplateExercises"] = [];
            for (let item of this.workoutTemplateExercises)
                data["workoutTemplateExercises"].push(item.toJSON());
        }
        return data;
    }
}

export interface IWorkoutTemplateDetailsDto {
    id?: number;
    templateName?: string | undefined;
    duration?: string | undefined;
    creatorName?: string;
    createdBy?: string;
    workoutTemplateExercises?: WorkoutTemplateExerciseDTO[];
}

export class WorkoutTemplateExerciseDTO implements IWorkoutTemplateExerciseDTO {
    exerciseTemlateId?: number;
    orderInSession?: number | undefined;
    orderInSuperset?: number | undefined;
    note?: string | undefined;
    setsRecommendation?: number | undefined;
    intensityPercentage?: number | undefined;
    rpeRecommendation?: number | undefined;
    weightsUsed?: string | undefined;
    numbersOfReps?: string | undefined;
    exercise?: ExerciseDTO | undefined;

    constructor(data?: IWorkoutTemplateExerciseDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.exerciseTemlateId = _data["exerciseTemlateId"];
            this.orderInSession = _data["orderInSession"];
            this.orderInSuperset = _data["orderInSuperset"];
            this.note = _data["note"];
            this.setsRecommendation = _data["setsRecommendation"];
            this.intensityPercentage = _data["intensityPercentage"];
            this.rpeRecommendation = _data["rpeRecommendation"];
            this.weightsUsed = _data["weightsUsed"];
            this.numbersOfReps = _data["numbersOfReps"];
            this.exercise = _data["exercise"] ? ExerciseDTO.fromJS(_data["exercise"]) : <any>undefined;
        }
    }

    static fromJS(data: any): WorkoutTemplateExerciseDTO {
        data = typeof data === 'object' ? data : {};
        let result = new WorkoutTemplateExerciseDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exerciseTemlateId"] = this.exerciseTemlateId;
        data["orderInSession"] = this.orderInSession;
        data["orderInSuperset"] = this.orderInSuperset;
        data["note"] = this.note;
        data["setsRecommendation"] = this.setsRecommendation;
        data["intensityPercentage"] = this.intensityPercentage;
        data["rpeRecommendation"] = this.rpeRecommendation;
        data["weightsUsed"] = this.weightsUsed;
        data["numbersOfReps"] = this.numbersOfReps;
        data["exercise"] = this.exercise ? this.exercise.toJSON() : <any>undefined;
        return data;
    }
}

export interface IWorkoutTemplateExerciseDTO {
    exerciseTemlateId?: number;
    orderInSession?: number | undefined;
    orderInSuperset?: number | undefined;
    note?: string | undefined;
    setsRecommendation?: number | undefined;
    intensityPercentage?: number | undefined;
    rpeRecommendation?: number | undefined;
    weightsUsed?: string | undefined;
    numbersOfReps?: string | undefined;
    exercise?: ExerciseDTO | undefined;
}

export class LoginResultDTO implements ILoginResultDTO {
    success?: boolean;
    token?: string;

    constructor(data?: ILoginResultDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): LoginResultDTO {
        data = typeof data === 'object' ? data : {};
        let result = new LoginResultDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["token"] = this.token;
        return data;
    }
}

export interface ILoginResultDTO {
    success?: boolean;
    token?: string;
}

export class LoginQuery implements ILoginQuery {
    username?: string;
    password?: string;

    constructor(data?: ILoginQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.username = _data["username"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): LoginQuery {
        data = typeof data === 'object' ? data : {};
        let result = new LoginQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username;
        data["password"] = this.password;
        return data;
    }
}

export interface ILoginQuery {
    username?: string;
    password?: string;
}

export class GoogleLoginRequest implements IGoogleLoginRequest {
    token?: string;

    constructor(data?: IGoogleLoginRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): GoogleLoginRequest {
        data = typeof data === 'object' ? data : {};
        let result = new GoogleLoginRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        return data;
    }
}

export interface IGoogleLoginRequest {
    token?: string;
}

export class FacebookLoginRequest implements IFacebookLoginRequest {
    userId?: string;
    name?: string;
    email?: string;

    constructor(data?: IFacebookLoginRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.name = _data["name"];
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): FacebookLoginRequest {
        data = typeof data === 'object' ? data : {};
        let result = new FacebookLoginRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["name"] = this.name;
        data["email"] = this.email;
        return data;
    }
}

export interface IFacebookLoginRequest {
    userId?: string;
    name?: string;
    email?: string;
}

export class RoleDto implements IRoleDto {
    id?: string;
    name?: string;
    roleDesc?: string | undefined;

    constructor(data?: IRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.roleDesc = _data["roleDesc"];
        }
    }

    static fromJS(data: any): RoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["roleDesc"] = this.roleDesc;
        return data;
    }
}

export interface IRoleDto {
    id?: string;
    name?: string;
    roleDesc?: string | undefined;
}

export class AddRoleCommand implements IAddRoleCommand {
    roleName?: string;
    roleDesc?: string;

    constructor(data?: IAddRoleCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.roleName = _data["roleName"];
            this.roleDesc = _data["roleDesc"];
        }
    }

    static fromJS(data: any): AddRoleCommand {
        data = typeof data === 'object' ? data : {};
        let result = new AddRoleCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleName"] = this.roleName;
        data["roleDesc"] = this.roleDesc;
        return data;
    }
}

export interface IAddRoleCommand {
    roleName?: string;
    roleDesc?: string;
}

export class UpdateRoleCommand implements IUpdateRoleCommand {
    roleId?: string;
    roleDescription?: string;

    constructor(data?: IUpdateRoleCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.roleId = _data["roleId"];
            this.roleDescription = _data["roleDescription"];
        }
    }

    static fromJS(data: any): UpdateRoleCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateRoleCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        data["roleDescription"] = this.roleDescription;
        return data;
    }
}

export interface IUpdateRoleCommand {
    roleId?: string;
    roleDescription?: string;
}

export class DeleteRoleCommand implements IDeleteRoleCommand {
    roleId?: number;

    constructor(data?: IDeleteRoleCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.roleId = _data["roleId"];
        }
    }

    static fromJS(data: any): DeleteRoleCommand {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteRoleCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        return data;
    }
}

export interface IDeleteRoleCommand {
    roleId?: number;
}

export class RegisterCommand implements IRegisterCommand {
    email?: string;
    password?: string;
    userName?: string;
    phoneNumber?: string;

    constructor(data?: IRegisterCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
            this.userName = _data["userName"];
            this.phoneNumber = _data["phoneNumber"];
        }
    }

    static fromJS(data: any): RegisterCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        data["userName"] = this.userName;
        data["phoneNumber"] = this.phoneNumber;
        return data;
    }
}

export interface IRegisterCommand {
    email?: string;
    password?: string;
    userName?: string;
    phoneNumber?: string;
}

export class ConfirmEmailCommand implements IConfirmEmailCommand {
    token?: string;
    email?: string;

    constructor(data?: IConfirmEmailCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): ConfirmEmailCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ConfirmEmailCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        data["email"] = this.email;
        return data;
    }
}

export interface IConfirmEmailCommand {
    token?: string;
    email?: string;
}

export class RecoverAccountCommand implements IRecoverAccountCommand {
    email?: string;

    constructor(data?: IRecoverAccountCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): RecoverAccountCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RecoverAccountCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        return data;
    }
}

export interface IRecoverAccountCommand {
    email?: string;
}

export class ResetPasswordCommand implements IResetPasswordCommand {
    token!: string;
    email!: string;
    password!: string;

    constructor(data?: IResetPasswordCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): ResetPasswordCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        data["email"] = this.email;
        data["password"] = this.password;
        return data;
    }
}

export interface IResetPasswordCommand {
    token: string;
    email: string;
    password: string;
}

export class UserProfileDTO implements IUserProfileDTO {
    id?: string | undefined;
    userName?: string | undefined;
    email?: string | undefined;
    phoneNumber?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    dateOfBirth?: Date | undefined;
    gender?: string | undefined;
    roles?: string;
    programs?: ProgramDTO[];
    certifications?: CertificationDTO[];
    coachingServices?: CoachingServiceDTO[];

    constructor(data?: IUserProfileDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.dateOfBirth = _data["dateOfBirth"] ? new Date(_data["dateOfBirth"].toString()) : <any>undefined;
            this.gender = _data["gender"];
            this.roles = _data["roles"];
            if (Array.isArray(_data["programs"])) {
                this.programs = [] as any;
                for (let item of _data["programs"])
                    this.programs!.push(ProgramDTO.fromJS(item));
            }
            if (Array.isArray(_data["certifications"])) {
                this.certifications = [] as any;
                for (let item of _data["certifications"])
                    this.certifications!.push(CertificationDTO.fromJS(item));
            }
            if (Array.isArray(_data["coachingServices"])) {
                this.coachingServices = [] as any;
                for (let item of _data["coachingServices"])
                    this.coachingServices!.push(CoachingServiceDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserProfileDTO {
        data = typeof data === 'object' ? data : {};
        let result = new UserProfileDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["gender"] = this.gender;
        data["roles"] = this.roles;
        if (Array.isArray(this.programs)) {
            data["programs"] = [];
            for (let item of this.programs)
                data["programs"].push(item.toJSON());
        }
        if (Array.isArray(this.certifications)) {
            data["certifications"] = [];
            for (let item of this.certifications)
                data["certifications"].push(item.toJSON());
        }
        if (Array.isArray(this.coachingServices)) {
            data["coachingServices"] = [];
            for (let item of this.coachingServices)
                data["coachingServices"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUserProfileDTO {
    id?: string | undefined;
    userName?: string | undefined;
    email?: string | undefined;
    phoneNumber?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    dateOfBirth?: Date | undefined;
    gender?: string | undefined;
    roles?: string;
    programs?: ProgramDTO[];
    certifications?: CertificationDTO[];
    coachingServices?: CoachingServiceDTO[];
}

export class ProgramDTO implements IProgramDTO {
    programId?: number;
    programName?: string | undefined;
    numberOfWeeks?: number | undefined;
    daysPerWeek?: number | undefined;
    dateCreated?: Date;
    lastModified?: Date;
    goal?: string | undefined;
    experienceLevel?: string | undefined;
    gymType?: string | undefined;
    musclesPriority?: string | undefined;
    ageGroup?: string | undefined;
    publicProgram?: boolean | undefined;

    constructor(data?: IProgramDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.programId = _data["programId"];
            this.programName = _data["programName"];
            this.numberOfWeeks = _data["numberOfWeeks"];
            this.daysPerWeek = _data["daysPerWeek"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.lastModified = _data["lastModified"] ? new Date(_data["lastModified"].toString()) : <any>undefined;
            this.goal = _data["goal"];
            this.experienceLevel = _data["experienceLevel"];
            this.gymType = _data["gymType"];
            this.musclesPriority = _data["musclesPriority"];
            this.ageGroup = _data["ageGroup"];
            this.publicProgram = _data["publicProgram"];
        }
    }

    static fromJS(data: any): ProgramDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ProgramDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["programId"] = this.programId;
        data["programName"] = this.programName;
        data["numberOfWeeks"] = this.numberOfWeeks;
        data["daysPerWeek"] = this.daysPerWeek;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>undefined;
        data["goal"] = this.goal;
        data["experienceLevel"] = this.experienceLevel;
        data["gymType"] = this.gymType;
        data["musclesPriority"] = this.musclesPriority;
        data["ageGroup"] = this.ageGroup;
        data["publicProgram"] = this.publicProgram;
        return data;
    }
}

export interface IProgramDTO {
    programId?: number;
    programName?: string | undefined;
    numberOfWeeks?: number | undefined;
    daysPerWeek?: number | undefined;
    dateCreated?: Date;
    lastModified?: Date;
    goal?: string | undefined;
    experienceLevel?: string | undefined;
    gymType?: string | undefined;
    musclesPriority?: string | undefined;
    ageGroup?: string | undefined;
    publicProgram?: boolean | undefined;
}

export class CertificationDTO implements ICertificationDTO {
    certificationId?: number;
    certificationName?: string | undefined;
    certificationDateIssued?: Date | undefined;
    certificationExpirationData?: Date | undefined;

    constructor(data?: ICertificationDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.certificationId = _data["certificationId"];
            this.certificationName = _data["certificationName"];
            this.certificationDateIssued = _data["certificationDateIssued"] ? new Date(_data["certificationDateIssued"].toString()) : <any>undefined;
            this.certificationExpirationData = _data["certificationExpirationData"] ? new Date(_data["certificationExpirationData"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CertificationDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CertificationDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["certificationId"] = this.certificationId;
        data["certificationName"] = this.certificationName;
        data["certificationDateIssued"] = this.certificationDateIssued ? formatDate(this.certificationDateIssued) : <any>undefined;
        data["certificationExpirationData"] = this.certificationExpirationData ? formatDate(this.certificationExpirationData) : <any>undefined;
        return data;
    }
}

export interface ICertificationDTO {
    certificationId?: number;
    certificationName?: string | undefined;
    certificationDateIssued?: Date | undefined;
    certificationExpirationData?: Date | undefined;
}

export class CoachingServiceDTO implements ICoachingServiceDTO {
    id?: number;
    serviceName?: string | undefined;
    description?: string | undefined;
    duration?: number | undefined;
    price?: number | undefined;
    serviceAvailability?: boolean | undefined;
    availabilityAnnouncement?: string | undefined;

    constructor(data?: ICoachingServiceDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.serviceName = _data["serviceName"];
            this.description = _data["description"];
            this.duration = _data["duration"];
            this.price = _data["price"];
            this.serviceAvailability = _data["serviceAvailability"];
            this.availabilityAnnouncement = _data["availabilityAnnouncement"];
        }
    }

    static fromJS(data: any): CoachingServiceDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CoachingServiceDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["serviceName"] = this.serviceName;
        data["description"] = this.description;
        data["duration"] = this.duration;
        data["price"] = this.price;
        data["serviceAvailability"] = this.serviceAvailability;
        data["availabilityAnnouncement"] = this.availabilityAnnouncement;
        return data;
    }
}

export interface ICoachingServiceDTO {
    id?: number;
    serviceName?: string | undefined;
    description?: string | undefined;
    duration?: number | undefined;
    price?: number | undefined;
    serviceAvailability?: boolean | undefined;
    availabilityAnnouncement?: string | undefined;
}

export class AuthenticatedResetPasswordCommandDto implements IAuthenticatedResetPasswordCommandDto {
    oldPassword?: string;
    newPassword?: string;

    constructor(data?: IAuthenticatedResetPasswordCommandDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.oldPassword = _data["oldPassword"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): AuthenticatedResetPasswordCommandDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticatedResetPasswordCommandDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["oldPassword"] = this.oldPassword;
        data["newPassword"] = this.newPassword;
        return data;
    }
}

export interface IAuthenticatedResetPasswordCommandDto {
    oldPassword?: string;
    newPassword?: string;
}

export class UpdateUserCommand implements IUpdateUserCommand {
    userId?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    dateOfBirth?: Date | undefined;
    gender?: string | undefined;
    email?: string | undefined;
    phoneNumber?: string | undefined;
    userName?: string | undefined;

    constructor(data?: IUpdateUserCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.dateOfBirth = _data["dateOfBirth"] ? new Date(_data["dateOfBirth"].toString()) : <any>undefined;
            this.gender = _data["gender"];
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
            this.userName = _data["userName"];
        }
    }

    static fromJS(data: any): UpdateUserCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["gender"] = this.gender;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["userName"] = this.userName;
        return data;
    }
}

export interface IUpdateUserCommand {
    userId?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    dateOfBirth?: Date | undefined;
    gender?: string | undefined;
    email?: string | undefined;
    phoneNumber?: string | undefined;
    userName?: string | undefined;
}

export class PaginatedListOfUserListDTO implements IPaginatedListOfUserListDTO {
    items?: UserListDTO[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfUserListDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserListDTO.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfUserListDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfUserListDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfUserListDTO {
    items?: UserListDTO[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class UserListDTO implements IUserListDTO {
    id!: string;
    userName?: string | undefined;
    email?: string | undefined;
    emailConfirmed?: boolean;
    phoneNumber?: string | undefined;
    isRestricted?: boolean | undefined;
    roles?: string[];

    constructor(data?: IUserListDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.email = _data["email"];
            this.emailConfirmed = _data["emailConfirmed"];
            this.phoneNumber = _data["phoneNumber"];
            this.isRestricted = _data["IsRestricted"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
        }
    }

    static fromJS(data: any): UserListDTO {
        data = typeof data === 'object' ? data : {};
        let result = new UserListDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["email"] = this.email;
        data["emailConfirmed"] = this.emailConfirmed;
        data["phoneNumber"] = this.phoneNumber;
        data["IsRestricted"] = this.isRestricted;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        return data;
    }
}

export interface IUserListDTO {
    id: string;
    userName?: string | undefined;
    email?: string | undefined;
    emailConfirmed?: boolean;
    phoneNumber?: string | undefined;
    isRestricted?: boolean | undefined;
    roles?: string[];
}

export class CreateUserCommand implements ICreateUserCommand {
    email?: string;
    password?: string;
    userName?: string;
    role?: string;

    constructor(data?: ICreateUserCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
            this.userName = _data["userName"];
            this.role = _data["role"];
        }
    }

    static fromJS(data: any): CreateUserCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        data["userName"] = this.userName;
        data["role"] = this.role;
        return data;
    }
}

export interface ICreateUserCommand {
    email?: string;
    password?: string;
    userName?: string;
    role?: string;
}

export class PaginatedListOfCoachSummaryDTO implements IPaginatedListOfCoachSummaryDTO {
    items?: CoachSummaryDTO[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfCoachSummaryDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CoachSummaryDTO.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfCoachSummaryDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfCoachSummaryDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfCoachSummaryDTO {
    items?: CoachSummaryDTO[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class CoachSummaryDTO implements ICoachSummaryDTO {
    fullName?: string;
    profilePicture?: string | undefined;
    bio?: string | undefined;
    majorAchievement?: string | undefined;
    instagramLink?: string | undefined;
    youTubeLink?: string | undefined;
    patreonLink?: string | undefined;
    programsCount?: string | undefined;

    constructor(data?: ICoachSummaryDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fullName = _data["fullName"];
            this.profilePicture = _data["profilePicture"];
            this.bio = _data["bio"];
            this.majorAchievement = _data["majorAchievement"];
            this.instagramLink = _data["instagramLink"];
            this.youTubeLink = _data["youTubeLink"];
            this.patreonLink = _data["patreonLink"];
            this.programsCount = _data["programsCount"];
        }
    }

    static fromJS(data: any): CoachSummaryDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CoachSummaryDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fullName"] = this.fullName;
        data["profilePicture"] = this.profilePicture;
        data["bio"] = this.bio;
        data["majorAchievement"] = this.majorAchievement;
        data["instagramLink"] = this.instagramLink;
        data["youTubeLink"] = this.youTubeLink;
        data["patreonLink"] = this.patreonLink;
        data["programsCount"] = this.programsCount;
        return data;
    }
}

export interface ICoachSummaryDTO {
    fullName?: string;
    profilePicture?: string | undefined;
    bio?: string | undefined;
    majorAchievement?: string | undefined;
    instagramLink?: string | undefined;
    youTubeLink?: string | undefined;
    patreonLink?: string | undefined;
    programsCount?: string | undefined;
}

export class CoachingServiceDetailsDto implements ICoachingServiceDetailsDto {
    id?: number;
    serviceName?: string;
    description?: string | undefined;
    duration?: number | undefined;
    price?: number | undefined;
    serviceAvailability?: boolean | undefined;
    availabilityAnnouncement?: string | undefined;
    created?: Date;
    createdBy?: string | undefined;
    lastModified?: Date;
    lastModifiedBy?: string | undefined;
    createdByUserName?: string | undefined;
    lastModifiedByUserName?: string | undefined;

    constructor(data?: ICoachingServiceDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.serviceName = _data["serviceName"];
            this.description = _data["description"];
            this.duration = _data["duration"];
            this.price = _data["price"];
            this.serviceAvailability = _data["serviceAvailability"];
            this.availabilityAnnouncement = _data["availabilityAnnouncement"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.lastModified = _data["lastModified"] ? new Date(_data["lastModified"].toString()) : <any>undefined;
            this.lastModifiedBy = _data["lastModifiedBy"];
            this.createdByUserName = _data["createdByUserName"];
            this.lastModifiedByUserName = _data["lastModifiedByUserName"];
        }
    }

    static fromJS(data: any): CoachingServiceDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new CoachingServiceDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["serviceName"] = this.serviceName;
        data["description"] = this.description;
        data["duration"] = this.duration;
        data["price"] = this.price;
        data["serviceAvailability"] = this.serviceAvailability;
        data["availabilityAnnouncement"] = this.availabilityAnnouncement;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>undefined;
        data["lastModifiedBy"] = this.lastModifiedBy;
        data["createdByUserName"] = this.createdByUserName;
        data["lastModifiedByUserName"] = this.lastModifiedByUserName;
        return data;
    }
}

export interface ICoachingServiceDetailsDto {
    id?: number;
    serviceName?: string;
    description?: string | undefined;
    duration?: number | undefined;
    price?: number | undefined;
    serviceAvailability?: boolean | undefined;
    availabilityAnnouncement?: string | undefined;
    created?: Date;
    createdBy?: string | undefined;
    lastModified?: Date;
    lastModifiedBy?: string | undefined;
    createdByUserName?: string | undefined;
    lastModifiedByUserName?: string | undefined;
}

export class PaginatedListOfCoachingServiceDTO implements IPaginatedListOfCoachingServiceDTO {
    items?: CoachingServiceDTO[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfCoachingServiceDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CoachingServiceDTO.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfCoachingServiceDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfCoachingServiceDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfCoachingServiceDTO {
    items?: CoachingServiceDTO[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class CreateCoachingServiceCommand implements ICreateCoachingServiceCommand {
    serviceName?: string;
    description?: string | undefined;
    duration?: number | undefined;
    price?: number | undefined;
    serviceAvailability?: boolean | undefined;
    availabilityAnnouncement?: string | undefined;

    constructor(data?: ICreateCoachingServiceCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.serviceName = _data["serviceName"];
            this.description = _data["description"];
            this.duration = _data["duration"];
            this.price = _data["price"];
            this.serviceAvailability = _data["serviceAvailability"];
            this.availabilityAnnouncement = _data["availabilityAnnouncement"];
        }
    }

    static fromJS(data: any): CreateCoachingServiceCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCoachingServiceCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["serviceName"] = this.serviceName;
        data["description"] = this.description;
        data["duration"] = this.duration;
        data["price"] = this.price;
        data["serviceAvailability"] = this.serviceAvailability;
        data["availabilityAnnouncement"] = this.availabilityAnnouncement;
        return data;
    }
}

export interface ICreateCoachingServiceCommand {
    serviceName?: string;
    description?: string | undefined;
    duration?: number | undefined;
    price?: number | undefined;
    serviceAvailability?: boolean | undefined;
    availabilityAnnouncement?: string | undefined;
}

export class UpdateCoachingServiceCommand implements IUpdateCoachingServiceCommand {
    id?: number;
    serviceName?: string;
    description?: string | undefined;
    duration?: number | undefined;
    price?: number | undefined;
    serviceAvailability?: boolean | undefined;
    availabilityAnnouncement?: string | undefined;

    constructor(data?: IUpdateCoachingServiceCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.serviceName = _data["serviceName"];
            this.description = _data["description"];
            this.duration = _data["duration"];
            this.price = _data["price"];
            this.serviceAvailability = _data["serviceAvailability"];
            this.availabilityAnnouncement = _data["availabilityAnnouncement"];
        }
    }

    static fromJS(data: any): UpdateCoachingServiceCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCoachingServiceCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["serviceName"] = this.serviceName;
        data["description"] = this.description;
        data["duration"] = this.duration;
        data["price"] = this.price;
        data["serviceAvailability"] = this.serviceAvailability;
        data["availabilityAnnouncement"] = this.availabilityAnnouncement;
        return data;
    }
}

export interface IUpdateCoachingServiceCommand {
    id?: number;
    serviceName?: string;
    description?: string | undefined;
    duration?: number | undefined;
    price?: number | undefined;
    serviceAvailability?: boolean | undefined;
    availabilityAnnouncement?: string | undefined;
}

export class UpdateBookingStatusCommand implements IUpdateBookingStatusCommand {
    bookingId?: number;
    newStatus?: string;
    paymentDate?: Date | undefined;

    constructor(data?: IUpdateBookingStatusCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bookingId = _data["bookingId"];
            this.newStatus = _data["newStatus"];
            this.paymentDate = _data["paymentDate"] ? new Date(_data["paymentDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateBookingStatusCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateBookingStatusCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bookingId"] = this.bookingId;
        data["newStatus"] = this.newStatus;
        data["paymentDate"] = this.paymentDate ? this.paymentDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface IUpdateBookingStatusCommand {
    bookingId?: number;
    newStatus?: string;
    paymentDate?: Date | undefined;
}

export class BookServiceCommand implements IBookServiceCommand {
    coachingServiceId?: number;

    constructor(data?: IBookServiceCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.coachingServiceId = _data["coachingServiceId"];
        }
    }

    static fromJS(data: any): BookServiceCommand {
        data = typeof data === 'object' ? data : {};
        let result = new BookServiceCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["coachingServiceId"] = this.coachingServiceId;
        return data;
    }
}

export interface IBookServiceCommand {
    coachingServiceId?: number;
}

export class UpdateCoachProfileCommand implements IUpdateCoachProfileCommand {
    userId?: string;
    bio?: string | undefined;
    profilePicture?: string | undefined;
    majorAchievements?: string[] | undefined;
    galleryImageLinks?: string[] | undefined;

    constructor(data?: IUpdateCoachProfileCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.bio = _data["bio"];
            this.profilePicture = _data["profilePicture"];
            if (Array.isArray(_data["majorAchievements"])) {
                this.majorAchievements = [] as any;
                for (let item of _data["majorAchievements"])
                    this.majorAchievements!.push(item);
            }
            if (Array.isArray(_data["galleryImageLinks"])) {
                this.galleryImageLinks = [] as any;
                for (let item of _data["galleryImageLinks"])
                    this.galleryImageLinks!.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateCoachProfileCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCoachProfileCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["bio"] = this.bio;
        data["profilePicture"] = this.profilePicture;
        if (Array.isArray(this.majorAchievements)) {
            data["majorAchievements"] = [];
            for (let item of this.majorAchievements)
                data["majorAchievements"].push(item);
        }
        if (Array.isArray(this.galleryImageLinks)) {
            data["galleryImageLinks"] = [];
            for (let item of this.galleryImageLinks)
                data["galleryImageLinks"].push(item);
        }
        return data;
    }
}

export interface IUpdateCoachProfileCommand {
    userId?: string;
    bio?: string | undefined;
    profilePicture?: string | undefined;
    majorAchievements?: string[] | undefined;
    galleryImageLinks?: string[] | undefined;
}

export class CreateCoachApplicationQuery implements ICreateCoachApplicationQuery {
    token?: string | undefined;

    constructor(data?: ICreateCoachApplicationQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): CreateCoachApplicationQuery {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCoachApplicationQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        return data;
    }
}

export interface ICreateCoachApplicationQuery {
    token?: string | undefined;
}

export class UpdateCoachApplicationStatusCommand implements IUpdateCoachApplicationStatusCommand {
    applicationId?: number;
    status?: string;
    statusReason?: string | undefined;
    updatedById?: string;

    constructor(data?: IUpdateCoachApplicationStatusCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.applicationId = _data["applicationId"];
            this.status = _data["status"];
            this.statusReason = _data["statusReason"];
            this.updatedById = _data["updatedById"];
        }
    }

    static fromJS(data: any): UpdateCoachApplicationStatusCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCoachApplicationStatusCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["applicationId"] = this.applicationId;
        data["status"] = this.status;
        data["statusReason"] = this.statusReason;
        data["updatedById"] = this.updatedById;
        return data;
    }
}

export interface IUpdateCoachApplicationStatusCommand {
    applicationId?: number;
    status?: string;
    statusReason?: string | undefined;
    updatedById?: string;
}

export class CreateCertificationCommand implements ICreateCertificationCommand {
    userId?: string | undefined;
    certificationName?: string | undefined;
    certificationDateIssued?: Date | undefined;
    certificationExpirationData?: Date | undefined;

    constructor(data?: ICreateCertificationCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.certificationName = _data["certificationName"];
            this.certificationDateIssued = _data["certificationDateIssued"] ? new Date(_data["certificationDateIssued"].toString()) : <any>undefined;
            this.certificationExpirationData = _data["certificationExpirationData"] ? new Date(_data["certificationExpirationData"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateCertificationCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCertificationCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["certificationName"] = this.certificationName;
        data["certificationDateIssued"] = this.certificationDateIssued ? formatDate(this.certificationDateIssued) : <any>undefined;
        data["certificationExpirationData"] = this.certificationExpirationData ? formatDate(this.certificationExpirationData) : <any>undefined;
        return data;
    }
}

export interface ICreateCertificationCommand {
    userId?: string | undefined;
    certificationName?: string | undefined;
    certificationDateIssued?: Date | undefined;
    certificationExpirationData?: Date | undefined;
}

export class UpdateCertificationCommand implements IUpdateCertificationCommand {
    certificationId?: number;
    userId?: string | undefined;
    certificationName?: string | undefined;
    certificationDateIssued?: Date | undefined;
    certificationExpirationData?: Date | undefined;

    constructor(data?: IUpdateCertificationCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.certificationId = _data["certificationId"];
            this.userId = _data["userId"];
            this.certificationName = _data["certificationName"];
            this.certificationDateIssued = _data["certificationDateIssued"] ? new Date(_data["certificationDateIssued"].toString()) : <any>undefined;
            this.certificationExpirationData = _data["certificationExpirationData"] ? new Date(_data["certificationExpirationData"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateCertificationCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCertificationCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["certificationId"] = this.certificationId;
        data["userId"] = this.userId;
        data["certificationName"] = this.certificationName;
        data["certificationDateIssued"] = this.certificationDateIssued ? formatDate(this.certificationDateIssued) : <any>undefined;
        data["certificationExpirationData"] = this.certificationExpirationData ? formatDate(this.certificationExpirationData) : <any>undefined;
        return data;
    }
}

export interface IUpdateCertificationCommand {
    certificationId?: number;
    userId?: string | undefined;
    certificationName?: string | undefined;
    certificationDateIssued?: Date | undefined;
    certificationExpirationData?: Date | undefined;
}

export class PaginatedListOfCoachApplicationDto implements IPaginatedListOfCoachApplicationDto {
    items?: CoachApplicationDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfCoachApplicationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CoachApplicationDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfCoachApplicationDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfCoachApplicationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfCoachApplicationDto {
    items?: CoachApplicationDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class CoachApplicationDto implements ICoachApplicationDto {
    id?: number;
    applicantId?: string;
    status?: string;
    statusReason?: string | undefined;
    created?: Date;
    lastModified?: Date;
    applicantName?: string;
    applicantEmail?: string;

    constructor(data?: ICoachApplicationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.applicantId = _data["applicantId"];
            this.status = _data["status"];
            this.statusReason = _data["statusReason"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.lastModified = _data["lastModified"] ? new Date(_data["lastModified"].toString()) : <any>undefined;
            this.applicantName = _data["applicantName"];
            this.applicantEmail = _data["applicantEmail"];
        }
    }

    static fromJS(data: any): CoachApplicationDto {
        data = typeof data === 'object' ? data : {};
        let result = new CoachApplicationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["applicantId"] = this.applicantId;
        data["status"] = this.status;
        data["statusReason"] = this.statusReason;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>undefined;
        data["applicantName"] = this.applicantName;
        data["applicantEmail"] = this.applicantEmail;
        return data;
    }
}

export interface ICoachApplicationDto {
    id?: number;
    applicantId?: string;
    status?: string;
    statusReason?: string | undefined;
    created?: Date;
    lastModified?: Date;
    applicantName?: string;
    applicantEmail?: string;
}

export class CreateChatCommand implements ICreateChatCommand {
    userId?: string;
    targetUserId?: string;

    constructor(data?: ICreateChatCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.targetUserId = _data["targetUserId"];
        }
    }

    static fromJS(data: any): CreateChatCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateChatCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["targetUserId"] = this.targetUserId;
        return data;
    }
}

export interface ICreateChatCommand {
    userId?: string;
    targetUserId?: string;
}

function formatDate(d: Date) {
    return d.getFullYear() + '-' + 
        (d.getMonth() < 9 ? ('0' + (d.getMonth()+1)) : (d.getMonth()+1)) + '-' +
        (d.getDate() < 10 ? ('0' + d.getDate()) : d.getDate());
}

export class SwaggerException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new SwaggerException(message, status, response, headers, null);
}