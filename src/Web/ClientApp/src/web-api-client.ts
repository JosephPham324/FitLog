//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.0.3.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import followIfLoginRedirect from './components/api-authorization/followIfLoginRedirect';

export class TodoItemsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getTodoItemsWithPagination(listId: number, pageNumber: number, pageSize: number): Promise<PaginatedListOfTodoItemBriefDto> {
        let url_ = this.baseUrl + "/api/TodoItems?";
        if (listId === undefined || listId === null)
            throw new Error("The parameter 'listId' must be defined and cannot be null.");
        else
            url_ += "ListId=" + encodeURIComponent("" + listId) + "&";
        if (pageNumber === undefined || pageNumber === null)
            throw new Error("The parameter 'pageNumber' must be defined and cannot be null.");
        else
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === undefined || pageSize === null)
            throw new Error("The parameter 'pageSize' must be defined and cannot be null.");
        else
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTodoItemsWithPagination(_response);
        });
    }

    protected processGetTodoItemsWithPagination(response: Response): Promise<PaginatedListOfTodoItemBriefDto> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfTodoItemBriefDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PaginatedListOfTodoItemBriefDto>(null as any);
    }

    createTodoItem(command: CreateTodoItemCommand): Promise<number> {
        let url_ = this.baseUrl + "/api/TodoItems";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateTodoItem(_response);
        });
    }

    protected processCreateTodoItem(response: Response): Promise<number> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(null as any);
    }

    updateTodoItem(id: number, command: UpdateTodoItemCommand): Promise<void> {
        let url_ = this.baseUrl + "/api/TodoItems/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateTodoItem(_response);
        });
    }

    protected processUpdateTodoItem(response: Response): Promise<void> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    deleteTodoItem(id: number): Promise<void> {
        let url_ = this.baseUrl + "/api/TodoItems/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteTodoItem(_response);
        });
    }

    protected processDeleteTodoItem(response: Response): Promise<void> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    updateTodoItemDetail(id: number, command: UpdateTodoItemDetailCommand): Promise<void> {
        let url_ = this.baseUrl + "/api/TodoItems/UpdateDetail/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateTodoItemDetail(_response);
        });
    }

    protected processUpdateTodoItemDetail(response: Response): Promise<void> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class TodoListsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getTodoLists(): Promise<TodosVm> {
        let url_ = this.baseUrl + "/api/TodoLists";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTodoLists(_response);
        });
    }

    protected processGetTodoLists(response: Response): Promise<TodosVm> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TodosVm.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TodosVm>(null as any);
    }

    createTodoList(command: CreateTodoListCommand): Promise<number> {
        let url_ = this.baseUrl + "/api/TodoLists";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateTodoList(_response);
        });
    }

    protected processCreateTodoList(response: Response): Promise<number> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(null as any);
    }

    updateTodoList(id: number, command: UpdateTodoListCommand): Promise<void> {
        let url_ = this.baseUrl + "/api/TodoLists/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateTodoList(_response);
        });
    }

    protected processUpdateTodoList(response: Response): Promise<void> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    deleteTodoList(id: number): Promise<void> {
        let url_ = this.baseUrl + "/api/TodoLists/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteTodoList(_response);
        });
    }

    protected processDeleteTodoList(response: Response): Promise<void> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class WeatherForecastsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getWeatherForecasts(): Promise<WeatherForecast[]> {
        let url_ = this.baseUrl + "/api/WeatherForecasts";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetWeatherForecasts(_response);
        });
    }

    protected processGetWeatherForecasts(response: Response): Promise<WeatherForecast[]> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WeatherForecast.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WeatherForecast[]>(null as any);
    }
}

export class EquipmentsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getEquipmentsWithPagination(pageNumber: number, pageSize: number): Promise<PaginatedListOfEquipmentDTO> {
        let url_ = this.baseUrl + "/api/Equipments/get-all?";
        if (pageNumber === undefined || pageNumber === null)
            throw new Error("The parameter 'pageNumber' must be defined and cannot be null.");
        else
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === undefined || pageSize === null)
            throw new Error("The parameter 'pageSize' must be defined and cannot be null.");
        else
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEquipmentsWithPagination(_response);
        });
    }

    protected processGetEquipmentsWithPagination(response: Response): Promise<PaginatedListOfEquipmentDTO> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfEquipmentDTO.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PaginatedListOfEquipmentDTO>(null as any);
    }

    getEquipmentById(id: number): Promise<any> {
        let url_ = this.baseUrl + "/api/Equipments/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEquipmentById(_response);
        });
    }

    protected processGetEquipmentById(response: Response): Promise<any> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }

    updateEquipment(id: number, command: UpdateEquipmentCommand): Promise<Result> {
        let url_ = this.baseUrl + "/api/Equipments/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateEquipment(_response);
        });
    }

    protected processUpdateEquipment(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    deleteEquipment(id: number, command: DeleteEquipmentCommand): Promise<Result> {
        let url_ = this.baseUrl + "/api/Equipments/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteEquipment(_response);
        });
    }

    protected processDeleteEquipment(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    createEquipment(command: CreateEquipmentCommand): Promise<Result> {
        let url_ = this.baseUrl + "/api/Equipments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateEquipment(_response);
        });
    }

    protected processCreateEquipment(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }
}

export class ExercisesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getExercisesWithPagination(pageNumber: number, pageSize: number): Promise<PaginatedListOfExerciseDTO> {
        let url_ = this.baseUrl + "/api/Exercises/paginated-all?";
        if (pageNumber === undefined || pageNumber === null)
            throw new Error("The parameter 'pageNumber' must be defined and cannot be null.");
        else
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === undefined || pageSize === null)
            throw new Error("The parameter 'pageSize' must be defined and cannot be null.");
        else
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetExercisesWithPagination(_response);
        });
    }

    protected processGetExercisesWithPagination(response: Response): Promise<PaginatedListOfExerciseDTO> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfExerciseDTO.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PaginatedListOfExerciseDTO>(null as any);
    }

    getExerciseTypes(): Promise<string[]> {
        let url_ = this.baseUrl + "/api/Exercises/exercise-types";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetExerciseTypes(_response);
        });
    }

    protected processGetExerciseTypes(response: Response): Promise<string[]> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string[]>(null as any);
    }

    getExerciseById(id: number): Promise<void> {
        let url_ = this.baseUrl + "/api/Exercises/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetExerciseById(_response);
        });
    }

    protected processGetExerciseById(response: Response): Promise<void> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    updateExercise(id: number, command: UpdateExerciseCommand): Promise<Result> {
        let url_ = this.baseUrl + "/api/Exercises/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateExercise(_response);
        });
    }

    protected processUpdateExercise(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    createExercise(command: CreateExerciseCommand): Promise<Result> {
        let url_ = this.baseUrl + "/api/Exercises";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateExercise(_response);
        });
    }

    protected processCreateExercise(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    deleteExercise(command: DeleteExerciseCommand): Promise<Result> {
        let url_ = this.baseUrl + "/api/Exercises";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteExercise(_response);
        });
    }

    protected processDeleteExercise(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    importExercises(command: ImportExercisesCommand): Promise<Result> {
        let url_ = this.baseUrl + "/api/Exercises/import-exercises";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processImportExercises(_response);
        });
    }

    protected processImportExercises(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }
}

export class MuscleGroupsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    createMuscleGroup(command: CreateMuscleGroupCommand): Promise<Result> {
        let url_ = this.baseUrl + "/api/MuscleGroups/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateMuscleGroup(_response);
        });
    }

    protected processCreateMuscleGroup(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    getMuscleGroupsList(pageNumber: number, pageSize: number): Promise<PaginatedListOfMuscleGroupDTO> {
        let url_ = this.baseUrl + "/api/MuscleGroups/get-list?";
        if (pageNumber === undefined || pageNumber === null)
            throw new Error("The parameter 'pageNumber' must be defined and cannot be null.");
        else
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === undefined || pageSize === null)
            throw new Error("The parameter 'pageSize' must be defined and cannot be null.");
        else
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetMuscleGroupsList(_response);
        });
    }

    protected processGetMuscleGroupsList(response: Response): Promise<PaginatedListOfMuscleGroupDTO> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfMuscleGroupDTO.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PaginatedListOfMuscleGroupDTO>(null as any);
    }

    getMuscleGroupsById(): Promise<MuscleGroupDTO2> {
        let url_ = this.baseUrl + "/api/MuscleGroups";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetMuscleGroupsById(_response);
        });
    }

    protected processGetMuscleGroupsById(response: Response): Promise<MuscleGroupDTO2> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MuscleGroupDTO2.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MuscleGroupDTO2>(null as any);
    }

    deleteMuscleGroup(command: DeleteMuscleGroupCommand): Promise<Result> {
        let url_ = this.baseUrl + "/api/MuscleGroups";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteMuscleGroup(_response);
        });
    }

    protected processDeleteMuscleGroup(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    updateMuscleGroup(id: number, command: UpdateMuscleGroupCommand): Promise<Result> {
        let url_ = this.baseUrl + "/api/MuscleGroups/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateMuscleGroup(_response);
        });
    }

    protected processUpdateMuscleGroup(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }
}

export class StatisticsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getWorkoutLogSummary(userId: string | null, timeFrame: string | null): Promise<SummaryWorkoutLogStatsDTO> {
        let url_ = this.baseUrl + "/api/Statistics/summary?";
        if (userId === undefined)
            throw new Error("The parameter 'userId' must be defined.");
        else if(userId !== null)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (timeFrame === undefined)
            throw new Error("The parameter 'timeFrame' must be defined.");
        else if(timeFrame !== null)
            url_ += "TimeFrame=" + encodeURIComponent("" + timeFrame) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetWorkoutLogSummary(_response);
        });
    }

    protected processGetWorkoutLogSummary(response: Response): Promise<SummaryWorkoutLogStatsDTO> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SummaryWorkoutLogStatsDTO.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SummaryWorkoutLogStatsDTO>(null as any);
    }

    getMusclesEngagement(userId: string | null, timeFrame: string | null): Promise<any> {
        let url_ = this.baseUrl + "/api/Statistics/muscles-engagement?";
        if (userId === undefined)
            throw new Error("The parameter 'userId' must be defined.");
        else if(userId !== null)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (timeFrame === undefined)
            throw new Error("The parameter 'timeFrame' must be defined.");
        else if(timeFrame !== null)
            url_ += "TimeFrame=" + encodeURIComponent("" + timeFrame) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetMusclesEngagement(_response);
        });
    }

    protected processGetMusclesEngagement(response: Response): Promise<any> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }

    getRepsStats(userId: string | null, timeFrame: string | null): Promise<any> {
        let url_ = this.baseUrl + "/api/Statistics/total-training-reps?";
        if (userId === undefined)
            throw new Error("The parameter 'userId' must be defined.");
        else if(userId !== null)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (timeFrame === undefined)
            throw new Error("The parameter 'timeFrame' must be defined.");
        else if(timeFrame !== null)
            url_ += "TimeFrame=" + encodeURIComponent("" + timeFrame) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRepsStats(_response);
        });
    }

    protected processGetRepsStats(response: Response): Promise<any> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }

    getTonnageStats(userId: string | null, timeFrame: string | null): Promise<any> {
        let url_ = this.baseUrl + "/api/Statistics/total-training-tonnage?";
        if (userId === undefined)
            throw new Error("The parameter 'userId' must be defined.");
        else if(userId !== null)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (timeFrame === undefined)
            throw new Error("The parameter 'timeFrame' must be defined.");
        else if(timeFrame !== null)
            url_ += "TimeFrame=" + encodeURIComponent("" + timeFrame) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTonnageStats(_response);
        });
    }

    protected processGetTonnageStats(response: Response): Promise<any> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }

    getTrainingFrequencies(userId: string | null, timeFrame: string | null): Promise<any> {
        let url_ = this.baseUrl + "/api/Statistics/training-frequency?";
        if (userId === undefined)
            throw new Error("The parameter 'userId' must be defined.");
        else if(userId !== null)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (timeFrame === undefined)
            throw new Error("The parameter 'timeFrame' must be defined.");
        else if(timeFrame !== null)
            url_ += "TimeFrame=" + encodeURIComponent("" + timeFrame) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTrainingFrequencies(_response);
        });
    }

    protected processGetTrainingFrequencies(response: Response): Promise<any> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }

    getExerciseLogHistory(userId: string | null, exerciseId: number): Promise<any> {
        let url_ = this.baseUrl + "/api/Statistics/exercise-log-history?";
        if (userId === undefined)
            throw new Error("The parameter 'userId' must be defined.");
        else if(userId !== null)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (exerciseId === undefined || exerciseId === null)
            throw new Error("The parameter 'exerciseId' must be defined and cannot be null.");
        else
            url_ += "ExerciseId=" + encodeURIComponent("" + exerciseId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetExerciseLogHistory(_response);
        });
    }

    protected processGetExerciseLogHistory(response: Response): Promise<any> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }
}

export class TrainingSurveyClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    createTrainingSurvey(command: CreateSurveyAnswerCommand): Promise<Result> {
        let url_ = this.baseUrl + "/api/TrainingSurvey/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateTrainingSurvey(_response);
        });
    }

    protected processCreateTrainingSurvey(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    updateTrainingSurvey(command: UpdateTrainingSurveyAnswersCommand): Promise<Result> {
        let url_ = this.baseUrl + "/api/TrainingSurvey/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateTrainingSurvey(_response);
        });
    }

    protected processUpdateTrainingSurvey(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }
}

export class WorkoutLogClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getWorkoutLogsWithPagination(pageNumber: number, pageSize: number): Promise<PaginatedListOfWorkoutLogDTO> {
        let url_ = this.baseUrl + "/api/WorkoutLog/get-all?";
        if (pageNumber === undefined || pageNumber === null)
            throw new Error("The parameter 'pageNumber' must be defined and cannot be null.");
        else
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === undefined || pageSize === null)
            throw new Error("The parameter 'pageSize' must be defined and cannot be null.");
        else
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetWorkoutLogsWithPagination(_response);
        });
    }

    protected processGetWorkoutLogsWithPagination(response: Response): Promise<PaginatedListOfWorkoutLogDTO> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfWorkoutLogDTO.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PaginatedListOfWorkoutLogDTO>(null as any);
    }

    getWorkoutHistory(startDate: Date | null | undefined, endDate: Date | null | undefined): Promise<any> {
        let url_ = this.baseUrl + "/api/WorkoutLog/history?";
        if (startDate !== undefined && startDate !== null)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate !== undefined && endDate !== null)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetWorkoutHistory(_response);
        });
    }

    protected processGetWorkoutHistory(response: Response): Promise<any> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }

    createExerciseLog(command: CreateWorkoutLogCommand): Promise<Result> {
        let url_ = this.baseUrl + "/api/WorkoutLog";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateExerciseLog(_response);
        });
    }

    protected processCreateExerciseLog(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    updateWorkoutLog(id: number, command: UpdateWorkoutLogCommand): Promise<Result> {
        let url_ = this.baseUrl + "/api/WorkoutLog/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateWorkoutLog(_response);
        });
    }

    protected processUpdateWorkoutLog(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    deleteWorkoutLog(id: number, command: DeleteWorkoutLogCommand): Promise<Result> {
        let url_ = this.baseUrl + "/api/WorkoutLog/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteWorkoutLog(_response);
        });
    }

    protected processDeleteWorkoutLog(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }
}

export class WorkoutProgramsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getWorkoutProgramsList(): Promise<WorkoutProgramListDTO[]> {
        let url_ = this.baseUrl + "/api/WorkoutPrograms";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetWorkoutProgramsList(_response);
        });
    }

    protected processGetWorkoutProgramsList(response: Response): Promise<WorkoutProgramListDTO[]> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WorkoutProgramListDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WorkoutProgramListDTO[]>(null as any);
    }

    createWorkoutProgram(command: CreateWorkoutProgramCommand): Promise<Result> {
        let url_ = this.baseUrl + "/api/WorkoutPrograms";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateWorkoutProgram(_response);
        });
    }

    protected processCreateWorkoutProgram(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    updateWorkoutProgram(id: number, command: UpdateWorkoutProgramCommand): Promise<void> {
        let url_ = this.baseUrl + "/api/WorkoutPrograms/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateWorkoutProgram(_response);
        });
    }

    protected processUpdateWorkoutProgram(response: Response): Promise<void> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    deleteWorkoutProgram(id: number): Promise<void> {
        let url_ = this.baseUrl + "/api/WorkoutPrograms/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteWorkoutProgram(_response);
        });
    }

    protected processDeleteWorkoutProgram(response: Response): Promise<void> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getWorkoutProgramDetails(id: number): Promise<void> {
        let url_ = this.baseUrl + "/api/WorkoutPrograms/Details/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetWorkoutProgramDetails(_response);
        });
    }

    protected processGetWorkoutProgramDetails(response: Response): Promise<void> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getEnrollmentsByUser(userId: string | null): Promise<ProgramEnrollmentDTO[]> {
        let url_ = this.baseUrl + "/api/WorkoutPrograms/enrollments/user?";
        if (userId === undefined)
            throw new Error("The parameter 'userId' must be defined.");
        else if(userId !== null)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEnrollmentsByUser(_response);
        });
    }

    protected processGetEnrollmentsByUser(response: Response): Promise<ProgramEnrollmentDTO[]> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProgramEnrollmentDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProgramEnrollmentDTO[]>(null as any);
    }

    enrollProgram(command: EnrollProgramCommand): Promise<Result> {
        let url_ = this.baseUrl + "/api/WorkoutPrograms/enrollments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEnrollProgram(_response);
        });
    }

    protected processEnrollProgram(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }
}

export class WorkoutTemplatesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    createPersonalTemplate(command: CreatePersonalTemplateCommand): Promise<number> {
        let url_ = this.baseUrl + "/api/WorkoutTemplates/create-personal-template";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreatePersonalTemplate(_response);
        });
    }

    protected processCreatePersonalTemplate(response: Response): Promise<number> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(null as any);
    }

    createWorkoutTemplate(command: CreateWorkoutTemplateCommand): Promise<number> {
        let url_ = this.baseUrl + "/api/WorkoutTemplates/create-workout-template";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateWorkoutTemplate(_response);
        });
    }

    protected processCreateWorkoutTemplate(response: Response): Promise<number> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(null as any);
    }

    updateWorkoutTemplate(id: number, command: UpdateWorkoutTemplateCommand): Promise<boolean> {
        let url_ = this.baseUrl + "/api/WorkoutTemplates/update-workout-template/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateWorkoutTemplate(_response);
        });
    }

    protected processUpdateWorkoutTemplate(response: Response): Promise<boolean> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    deleteWorkoutTemplate(id: number): Promise<boolean> {
        let url_ = this.baseUrl + "/api/WorkoutTemplates/delete-workout-template/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteWorkoutTemplate(_response);
        });
    }

    protected processDeleteWorkoutTemplate(response: Response): Promise<boolean> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    getPublicTemplates(pageNumber: number, pageSize: number): Promise<PaginatedListOfWorkoutTemplateListDto> {
        let url_ = this.baseUrl + "/api/WorkoutTemplates/get-public-templates?";
        if (pageNumber === undefined || pageNumber === null)
            throw new Error("The parameter 'pageNumber' must be defined and cannot be null.");
        else
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === undefined || pageSize === null)
            throw new Error("The parameter 'pageSize' must be defined and cannot be null.");
        else
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPublicTemplates(_response);
        });
    }

    protected processGetPublicTemplates(response: Response): Promise<PaginatedListOfWorkoutTemplateListDto> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfWorkoutTemplateListDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PaginatedListOfWorkoutTemplateListDto>(null as any);
    }

    getWorkoutTemplateDetails(id: number): Promise<void> {
        let url_ = this.baseUrl + "/api/WorkoutTemplates/get-workout-template-details/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetWorkoutTemplateDetails(_response);
        });
    }

    protected processGetWorkoutTemplateDetails(response: Response): Promise<void> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    filterWorkoutTemplates(templateName: string | null, creatorName: string | null | undefined, minDuration: string | null | undefined, maxDuration: string | null | undefined, pageNumber: number, pageSize: number): Promise<PaginatedListOfWorkoutTemplateListDto> {
        let url_ = this.baseUrl + "/api/WorkoutTemplates/filter-workout-templates?";
        if (templateName === undefined)
            throw new Error("The parameter 'templateName' must be defined.");
        else if(templateName !== null)
            url_ += "TemplateName=" + encodeURIComponent("" + templateName) + "&";
        if (creatorName !== undefined && creatorName !== null)
            url_ += "CreatorName=" + encodeURIComponent("" + creatorName) + "&";
        if (minDuration !== undefined && minDuration !== null)
            url_ += "MinDuration=" + encodeURIComponent("" + minDuration) + "&";
        if (maxDuration !== undefined && maxDuration !== null)
            url_ += "MaxDuration=" + encodeURIComponent("" + maxDuration) + "&";
        if (pageNumber === undefined || pageNumber === null)
            throw new Error("The parameter 'pageNumber' must be defined and cannot be null.");
        else
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === undefined || pageSize === null)
            throw new Error("The parameter 'pageSize' must be defined and cannot be null.");
        else
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFilterWorkoutTemplates(_response);
        });
    }

    protected processFilterWorkoutTemplates(response: Response): Promise<PaginatedListOfWorkoutTemplateListDto> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfWorkoutTemplateListDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PaginatedListOfWorkoutTemplateListDto>(null as any);
    }
}

export class AuthenticationClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    passwordLogin(query: LoginQuery): Promise<LoginResultDTO> {
        let url_ = this.baseUrl + "/api/Authentication/password-login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPasswordLogin(_response);
        });
    }

    protected processPasswordLogin(response: Response): Promise<LoginResultDTO> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoginResultDTO.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LoginResultDTO>(null as any);
    }

    signInWithGoogle(request: GoogleLoginRequest): Promise<string> {
        let url_ = this.baseUrl + "/api/Authentication/google-login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSignInWithGoogle(_response);
        });
    }

    protected processSignInWithGoogle(response: Response): Promise<string> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    signInWithFacebook(request: FacebookLoginRequest): Promise<string> {
        let url_ = this.baseUrl + "/api/Authentication/facebook-login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSignInWithFacebook(_response);
        });
    }

    protected processSignInWithFacebook(response: Response): Promise<string> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }
}

export class RolesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getRolesList(): Promise<RoleDto[]> {
        let url_ = this.baseUrl + "/api/Roles";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRolesList(_response);
        });
    }

    protected processGetRolesList(response: Response): Promise<RoleDto[]> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RoleDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RoleDto[]>(null as any);
    }

    createRole(command: AddRoleCommand): Promise<Result> {
        let url_ = this.baseUrl + "/api/Roles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateRole(_response);
        });
    }

    protected processCreateRole(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    getRoleById(id: string): Promise<RoleDto> {
        let url_ = this.baseUrl + "/api/Roles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRoleById(_response);
        });
    }

    protected processGetRoleById(response: Response): Promise<RoleDto> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RoleDto>(null as any);
    }

    updateRole(id: number, command: UpdateRoleCommand): Promise<Result> {
        let url_ = this.baseUrl + "/api/Roles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateRole(_response);
        });
    }

    protected processUpdateRole(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    deleteRole(id: number, command: DeleteRoleCommand): Promise<Result> {
        let url_ = this.baseUrl + "/api/Roles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteRole(_response);
        });
    }

    protected processDeleteRole(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }
}

export class UsersClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    login(username: string | null, password: string | null): Promise<LoginResultDTO> {
        let url_ = this.baseUrl + "/api/Users/login?";
        if (username === undefined)
            throw new Error("The parameter 'username' must be defined.");
        else if(username !== null)
            url_ += "Username=" + encodeURIComponent("" + username) + "&";
        if (password === undefined)
            throw new Error("The parameter 'password' must be defined.");
        else if(password !== null)
            url_ += "Password=" + encodeURIComponent("" + password) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLogin(_response);
        });
    }

    protected processLogin(response: Response): Promise<LoginResultDTO> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoginResultDTO.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LoginResultDTO>(null as any);
    }

    register(command: RegisterCommand): Promise<Result> {
        let url_ = this.baseUrl + "/api/Users/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRegister(_response);
        });
    }

    protected processRegister(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    getUserList(pageNumber: number, pageSize: number): Promise<PaginatedListOfAspNetUserListDTO> {
        let url_ = this.baseUrl + "/api/Users/all?";
        if (pageNumber === undefined || pageNumber === null)
            throw new Error("The parameter 'pageNumber' must be defined and cannot be null.");
        else
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === undefined || pageSize === null)
            throw new Error("The parameter 'pageSize' must be defined and cannot be null.");
        else
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUserList(_response);
        });
    }

    protected processGetUserList(response: Response): Promise<PaginatedListOfAspNetUserListDTO> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfAspNetUserListDTO.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PaginatedListOfAspNetUserListDTO>(null as any);
    }

    searchUsersByEmail(email: string | null): Promise<(AspNetUserListDTO | undefined)[]> {
        let url_ = this.baseUrl + "/api/Users/search-by-email?";
        if (email === undefined)
            throw new Error("The parameter 'email' must be defined.");
        else if(email !== null)
            url_ += "Email=" + encodeURIComponent("" + email) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearchUsersByEmail(_response);
        });
    }

    protected processSearchUsersByEmail(response: Response): Promise<(AspNetUserListDTO | undefined)[]> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AspNetUserListDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<(AspNetUserListDTO | undefined)[]>(null as any);
    }

    searchUsersByLoginProvider(provider: string | null): Promise<(AspNetUserListDTO | undefined)[]> {
        let url_ = this.baseUrl + "/api/Users/search-by-provider?";
        if (provider === undefined)
            throw new Error("The parameter 'provider' must be defined.");
        else if(provider !== null)
            url_ += "Provider=" + encodeURIComponent("" + provider) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearchUsersByLoginProvider(_response);
        });
    }

    protected processSearchUsersByLoginProvider(response: Response): Promise<(AspNetUserListDTO | undefined)[]> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AspNetUserListDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<(AspNetUserListDTO | undefined)[]>(null as any);
    }

    searchUsersByUserName(username: string | null): Promise<(AspNetUserListDTO | undefined)[]> {
        let url_ = this.baseUrl + "/api/Users/search-by-username?";
        if (username === undefined)
            throw new Error("The parameter 'username' must be defined.");
        else if(username !== null)
            url_ += "Username=" + encodeURIComponent("" + username) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearchUsersByUserName(_response);
        });
    }

    protected processSearchUsersByUserName(response: Response): Promise<(AspNetUserListDTO | undefined)[]> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AspNetUserListDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<(AspNetUserListDTO | undefined)[]>(null as any);
    }

    getUserProfile(userId: string | null): Promise<UserProfileDTO> {
        let url_ = this.baseUrl + "/api/Users/profile?";
        if (userId === undefined)
            throw new Error("The parameter 'userId' must be defined.");
        else if(userId !== null)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUserProfile(_response);
        });
    }

    protected processGetUserProfile(response: Response): Promise<UserProfileDTO> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserProfileDTO.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserProfileDTO>(null as any);
    }

    createUser(command: CreateUserCommand): Promise<Result> {
        let url_ = this.baseUrl + "/api/Users/create-account";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateUser(_response);
        });
    }

    protected processCreateUser(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    deleteAccount(id: string): Promise<Result> {
        let url_ = this.baseUrl + "/api/Users/delete-account/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteAccount(_response);
        });
    }

    protected processDeleteAccount(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    recoverAccount(command: RecoverAccountCommand): Promise<Result> {
        let url_ = this.baseUrl + "/api/Users/recover-account";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRecoverAccount(_response);
        });
    }

    protected processRecoverAccount(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }
}

export class CoachingServicesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getCoachingServiceDetails(id: number): Promise<CoachingServiceDetailsDto> {
        let url_ = this.baseUrl + "/api/CoachingServices/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCoachingServiceDetails(_response);
        });
    }

    protected processGetCoachingServiceDetails(response: Response): Promise<CoachingServiceDetailsDto> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CoachingServiceDetailsDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CoachingServiceDetailsDto>(null as any);
    }

    updateCoachingService(id: number, command: UpdateCoachingServiceCommand): Promise<Result> {
        let url_ = this.baseUrl + "/api/CoachingServices/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateCoachingService(_response);
        });
    }

    protected processUpdateCoachingService(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    deleteCoachingService(id: number): Promise<Result> {
        let url_ = this.baseUrl + "/api/CoachingServices/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteCoachingService(_response);
        });
    }

    protected processDeleteCoachingService(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    getPaginatedCoachingServices(pageNumber: number, pageSize: number): Promise<PaginatedListOfCoachingServiceDTO> {
        let url_ = this.baseUrl + "/api/CoachingServices?";
        if (pageNumber === undefined || pageNumber === null)
            throw new Error("The parameter 'pageNumber' must be defined and cannot be null.");
        else
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === undefined || pageSize === null)
            throw new Error("The parameter 'pageSize' must be defined and cannot be null.");
        else
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPaginatedCoachingServices(_response);
        });
    }

    protected processGetPaginatedCoachingServices(response: Response): Promise<PaginatedListOfCoachingServiceDTO> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfCoachingServiceDTO.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PaginatedListOfCoachingServiceDTO>(null as any);
    }

    createCoachingService(command: CreateCoachingServiceCommand): Promise<Result> {
        let url_ = this.baseUrl + "/api/CoachingServices";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateCoachingService(_response);
        });
    }

    protected processCreateCoachingService(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    getPaginatedCoachingServicesOfUser(userIdPath: string, pageNumber: number, pageSize: number): Promise<PaginatedListOfCoachingServiceDTO> {
        let url_ = this.baseUrl + "/api/CoachingServices/user/{userId}?";
        if (userIdPath === undefined || userIdPath === null)
            throw new Error("The parameter 'userIdPath' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userIdPath));
        if (pageNumber === undefined || pageNumber === null)
            throw new Error("The parameter 'pageNumber' must be defined and cannot be null.");
        else
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === undefined || pageSize === null)
            throw new Error("The parameter 'pageSize' must be defined and cannot be null.");
        else
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPaginatedCoachingServicesOfUser(_response);
        });
    }

    protected processGetPaginatedCoachingServicesOfUser(response: Response): Promise<PaginatedListOfCoachingServiceDTO> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfCoachingServiceDTO.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PaginatedListOfCoachingServiceDTO>(null as any);
    }
}

export class CoachProfileClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getCoachProfileDetails(id: string): Promise<any> {
        let url_ = this.baseUrl + "/api/CoachProfile/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCoachProfileDetails(_response);
        });
    }

    protected processGetCoachProfileDetails(response: Response): Promise<any> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }

    updateCoachProfileDetails(id: string, request: UpdateCoachProfileCommand): Promise<Result> {
        let url_ = this.baseUrl + "/api/CoachProfile/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateCoachProfileDetails(_response);
        });
    }

    protected processUpdateCoachProfileDetails(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    createCoachApplication(request: CreateCoachApplicationQuery): Promise<Result> {
        let url_ = this.baseUrl + "/api/CoachProfile/apply-coach";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateCoachApplication(_response);
        });
    }

    protected processCreateCoachApplication(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    updateCoachApplication(id: string, request: UpdateCoachApplicationStatusCommand): Promise<Result> {
        let url_ = this.baseUrl + "/api/CoachProfile/update-application?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateCoachApplication(_response);
        });
    }

    protected processUpdateCoachApplication(response: Response): Promise<Result> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Result.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Result>(null as any);
    }

    getApplicationsWithPagination(pageNumber: number, pageSize: number): Promise<PaginatedListOfCoachApplicationDto> {
        let url_ = this.baseUrl + "/api/CoachProfile/paginated-list?";
        if (pageNumber === undefined || pageNumber === null)
            throw new Error("The parameter 'pageNumber' must be defined and cannot be null.");
        else
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === undefined || pageSize === null)
            throw new Error("The parameter 'pageSize' must be defined and cannot be null.");
        else
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetApplicationsWithPagination(_response);
        });
    }

    protected processGetApplicationsWithPagination(response: Response): Promise<PaginatedListOfCoachApplicationDto> {
        followIfLoginRedirect(response);
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfCoachApplicationDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PaginatedListOfCoachApplicationDto>(null as any);
    }
}

export class PaginatedListOfTodoItemBriefDto implements IPaginatedListOfTodoItemBriefDto {
    items?: TodoItemBriefDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfTodoItemBriefDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TodoItemBriefDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfTodoItemBriefDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfTodoItemBriefDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfTodoItemBriefDto {
    items?: TodoItemBriefDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class TodoItemBriefDto implements ITodoItemBriefDto {
    id?: number;
    listId?: number;
    title?: string | undefined;
    done?: boolean;

    constructor(data?: ITodoItemBriefDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.listId = _data["listId"];
            this.title = _data["title"];
            this.done = _data["done"];
        }
    }

    static fromJS(data: any): TodoItemBriefDto {
        data = typeof data === 'object' ? data : {};
        let result = new TodoItemBriefDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["listId"] = this.listId;
        data["title"] = this.title;
        data["done"] = this.done;
        return data;
    }
}

export interface ITodoItemBriefDto {
    id?: number;
    listId?: number;
    title?: string | undefined;
    done?: boolean;
}

export class CreateTodoItemCommand implements ICreateTodoItemCommand {
    listId?: number;
    title?: string | undefined;

    constructor(data?: ICreateTodoItemCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.listId = _data["listId"];
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): CreateTodoItemCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTodoItemCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["listId"] = this.listId;
        data["title"] = this.title;
        return data;
    }
}

export interface ICreateTodoItemCommand {
    listId?: number;
    title?: string | undefined;
}

export class UpdateTodoItemCommand implements IUpdateTodoItemCommand {
    id?: number;
    title?: string | undefined;
    done?: boolean;

    constructor(data?: IUpdateTodoItemCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.done = _data["done"];
        }
    }

    static fromJS(data: any): UpdateTodoItemCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTodoItemCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["done"] = this.done;
        return data;
    }
}

export interface IUpdateTodoItemCommand {
    id?: number;
    title?: string | undefined;
    done?: boolean;
}

export class UpdateTodoItemDetailCommand implements IUpdateTodoItemDetailCommand {
    id?: number;
    listId?: number;
    priority?: PriorityLevel;
    note?: string | undefined;

    constructor(data?: IUpdateTodoItemDetailCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.listId = _data["listId"];
            this.priority = _data["priority"];
            this.note = _data["note"];
        }
    }

    static fromJS(data: any): UpdateTodoItemDetailCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTodoItemDetailCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["listId"] = this.listId;
        data["priority"] = this.priority;
        data["note"] = this.note;
        return data;
    }
}

export interface IUpdateTodoItemDetailCommand {
    id?: number;
    listId?: number;
    priority?: PriorityLevel;
    note?: string | undefined;
}

export enum PriorityLevel {
    None = 0,
    Low = 1,
    Medium = 2,
    High = 3,
}

export class TodosVm implements ITodosVm {
    priorityLevels?: LookupDto[];
    lists?: TodoListDto[];

    constructor(data?: ITodosVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["priorityLevels"])) {
                this.priorityLevels = [] as any;
                for (let item of _data["priorityLevels"])
                    this.priorityLevels!.push(LookupDto.fromJS(item));
            }
            if (Array.isArray(_data["lists"])) {
                this.lists = [] as any;
                for (let item of _data["lists"])
                    this.lists!.push(TodoListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TodosVm {
        data = typeof data === 'object' ? data : {};
        let result = new TodosVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.priorityLevels)) {
            data["priorityLevels"] = [];
            for (let item of this.priorityLevels)
                data["priorityLevels"].push(item.toJSON());
        }
        if (Array.isArray(this.lists)) {
            data["lists"] = [];
            for (let item of this.lists)
                data["lists"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITodosVm {
    priorityLevels?: LookupDto[];
    lists?: TodoListDto[];
}

export class LookupDto implements ILookupDto {
    id?: number;
    title?: string | undefined;

    constructor(data?: ILookupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): LookupDto {
        data = typeof data === 'object' ? data : {};
        let result = new LookupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        return data;
    }
}

export interface ILookupDto {
    id?: number;
    title?: string | undefined;
}

export class TodoListDto implements ITodoListDto {
    id?: number;
    title?: string | undefined;
    colour?: string | undefined;
    items?: TodoItemDto[];

    constructor(data?: ITodoListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.colour = _data["colour"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TodoItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TodoListDto {
        data = typeof data === 'object' ? data : {};
        let result = new TodoListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["colour"] = this.colour;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITodoListDto {
    id?: number;
    title?: string | undefined;
    colour?: string | undefined;
    items?: TodoItemDto[];
}

export class TodoItemDto implements ITodoItemDto {
    id?: number;
    listId?: number;
    title?: string | undefined;
    done?: boolean;
    priority?: number;
    note?: string | undefined;

    constructor(data?: ITodoItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.listId = _data["listId"];
            this.title = _data["title"];
            this.done = _data["done"];
            this.priority = _data["priority"];
            this.note = _data["note"];
        }
    }

    static fromJS(data: any): TodoItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new TodoItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["listId"] = this.listId;
        data["title"] = this.title;
        data["done"] = this.done;
        data["priority"] = this.priority;
        data["note"] = this.note;
        return data;
    }
}

export interface ITodoItemDto {
    id?: number;
    listId?: number;
    title?: string | undefined;
    done?: boolean;
    priority?: number;
    note?: string | undefined;
}

export class CreateTodoListCommand implements ICreateTodoListCommand {
    title?: string | undefined;

    constructor(data?: ICreateTodoListCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): CreateTodoListCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTodoListCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        return data;
    }
}

export interface ICreateTodoListCommand {
    title?: string | undefined;
}

export class UpdateTodoListCommand implements IUpdateTodoListCommand {
    id?: number;
    title?: string | undefined;

    constructor(data?: IUpdateTodoListCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): UpdateTodoListCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTodoListCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        return data;
    }
}

export interface IUpdateTodoListCommand {
    id?: number;
    title?: string | undefined;
}

export class WeatherForecast implements IWeatherForecast {
    date?: Date;
    temperatureC?: number;
    temperatureF?: number;
    summary?: string | undefined;

    constructor(data?: IWeatherForecast) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.temperatureC = _data["temperatureC"];
            this.temperatureF = _data["temperatureF"];
            this.summary = _data["summary"];
        }
    }

    static fromJS(data: any): WeatherForecast {
        data = typeof data === 'object' ? data : {};
        let result = new WeatherForecast();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["temperatureC"] = this.temperatureC;
        data["temperatureF"] = this.temperatureF;
        data["summary"] = this.summary;
        return data;
    }
}

export interface IWeatherForecast {
    date?: Date;
    temperatureC?: number;
    temperatureF?: number;
    summary?: string | undefined;
}

export class PaginatedListOfEquipmentDTO implements IPaginatedListOfEquipmentDTO {
    items?: EquipmentDTO[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfEquipmentDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(EquipmentDTO.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfEquipmentDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfEquipmentDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfEquipmentDTO {
    items?: EquipmentDTO[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class EquipmentDTO implements IEquipmentDTO {
    equipmentId?: number;
    equipmentName?: string | undefined;

    constructor(data?: IEquipmentDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.equipmentId = _data["equipmentId"];
            this.equipmentName = _data["equipmentName"];
        }
    }

    static fromJS(data: any): EquipmentDTO {
        data = typeof data === 'object' ? data : {};
        let result = new EquipmentDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["equipmentId"] = this.equipmentId;
        data["equipmentName"] = this.equipmentName;
        return data;
    }
}

export interface IEquipmentDTO {
    equipmentId?: number;
    equipmentName?: string | undefined;
}

export class Result implements IResult {
    success?: boolean;
    errors?: string[];

    constructor(data?: IResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): Result {
        data = typeof data === 'object' ? data : {};
        let result = new Result();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResult {
    success?: boolean;
    errors?: string[];
}

export class CreateEquipmentCommand implements ICreateEquipmentCommand {
    equipmentName?: string | undefined;
    imageUrl?: string | undefined;

    constructor(data?: ICreateEquipmentCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.equipmentName = _data["equipmentName"];
            this.imageUrl = _data["imageUrl"];
        }
    }

    static fromJS(data: any): CreateEquipmentCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateEquipmentCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["equipmentName"] = this.equipmentName;
        data["imageUrl"] = this.imageUrl;
        return data;
    }
}

export interface ICreateEquipmentCommand {
    equipmentName?: string | undefined;
    imageUrl?: string | undefined;
}

export class UpdateEquipmentCommand implements IUpdateEquipmentCommand {
    equipmentId?: number;
    equipmentName?: string | undefined;
    imageUrl?: string | undefined;

    constructor(data?: IUpdateEquipmentCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.equipmentId = _data["equipmentId"];
            this.equipmentName = _data["equipmentName"];
            this.imageUrl = _data["imageUrl"];
        }
    }

    static fromJS(data: any): UpdateEquipmentCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateEquipmentCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["equipmentId"] = this.equipmentId;
        data["equipmentName"] = this.equipmentName;
        data["imageUrl"] = this.imageUrl;
        return data;
    }
}

export interface IUpdateEquipmentCommand {
    equipmentId?: number;
    equipmentName?: string | undefined;
    imageUrl?: string | undefined;
}

export class DeleteEquipmentCommand implements IDeleteEquipmentCommand {
    equipmentId?: number;

    constructor(data?: IDeleteEquipmentCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.equipmentId = _data["equipmentId"];
        }
    }

    static fromJS(data: any): DeleteEquipmentCommand {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteEquipmentCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["equipmentId"] = this.equipmentId;
        return data;
    }
}

export interface IDeleteEquipmentCommand {
    equipmentId?: number;
}

export class PaginatedListOfExerciseDTO implements IPaginatedListOfExerciseDTO {
    items?: ExerciseDTO[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfExerciseDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ExerciseDTO.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfExerciseDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfExerciseDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfExerciseDTO {
    items?: ExerciseDTO[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class ExerciseDTO implements IExerciseDTO {
    exerciseId?: number;
    exerciseName?: string | undefined;
    type?: string;

    constructor(data?: IExerciseDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.exerciseId = _data["exerciseId"];
            this.exerciseName = _data["exerciseName"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): ExerciseDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ExerciseDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exerciseId"] = this.exerciseId;
        data["exerciseName"] = this.exerciseName;
        data["type"] = this.type;
        return data;
    }
}

export interface IExerciseDTO {
    exerciseId?: number;
    exerciseName?: string | undefined;
    type?: string;
}

export class CreateExerciseCommand implements ICreateExerciseCommand {
    createdBy?: string | undefined;
    muscleGroupIds?: number[];
    equipmentId?: number | undefined;
    exerciseName?: string | undefined;
    demoUrl?: string | undefined;
    type?: string;
    description?: string | undefined;
    publicVisibility?: boolean | undefined;

    constructor(data?: ICreateExerciseCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            if (Array.isArray(_data["muscleGroupIds"])) {
                this.muscleGroupIds = [] as any;
                for (let item of _data["muscleGroupIds"])
                    this.muscleGroupIds!.push(item);
            }
            this.equipmentId = _data["equipmentId"];
            this.exerciseName = _data["exerciseName"];
            this.demoUrl = _data["demoUrl"];
            this.type = _data["type"];
            this.description = _data["description"];
            this.publicVisibility = _data["publicVisibility"];
        }
    }

    static fromJS(data: any): CreateExerciseCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateExerciseCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        if (Array.isArray(this.muscleGroupIds)) {
            data["muscleGroupIds"] = [];
            for (let item of this.muscleGroupIds)
                data["muscleGroupIds"].push(item);
        }
        data["equipmentId"] = this.equipmentId;
        data["exerciseName"] = this.exerciseName;
        data["demoUrl"] = this.demoUrl;
        data["type"] = this.type;
        data["description"] = this.description;
        data["publicVisibility"] = this.publicVisibility;
        return data;
    }
}

export interface ICreateExerciseCommand {
    createdBy?: string | undefined;
    muscleGroupIds?: number[];
    equipmentId?: number | undefined;
    exerciseName?: string | undefined;
    demoUrl?: string | undefined;
    type?: string;
    description?: string | undefined;
    publicVisibility?: boolean | undefined;
}

export class ImportExercisesCommand implements IImportExercisesCommand {
    exercises?: ExerciseImport[];

    constructor(data?: IImportExercisesCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["exercises"])) {
                this.exercises = [] as any;
                for (let item of _data["exercises"])
                    this.exercises!.push(ExerciseImport.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ImportExercisesCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ImportExercisesCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.exercises)) {
            data["exercises"] = [];
            for (let item of this.exercises)
                data["exercises"].push(item.toJSON());
        }
        return data;
    }
}

export interface IImportExercisesCommand {
    exercises?: ExerciseImport[];
}

export class ExerciseImport implements IExerciseImport {
    muscleGroupNames?: string[];
    equipmentName?: string | undefined;
    exerciseName?: string | undefined;
    demoUrl?: string | undefined;
    type?: string;
    description?: string | undefined;
    publicVisibility?: boolean | undefined;

    constructor(data?: IExerciseImport) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["muscleGroupNames"])) {
                this.muscleGroupNames = [] as any;
                for (let item of _data["muscleGroupNames"])
                    this.muscleGroupNames!.push(item);
            }
            this.equipmentName = _data["equipmentName"];
            this.exerciseName = _data["exerciseName"];
            this.demoUrl = _data["demoUrl"];
            this.type = _data["type"];
            this.description = _data["description"];
            this.publicVisibility = _data["publicVisibility"];
        }
    }

    static fromJS(data: any): ExerciseImport {
        data = typeof data === 'object' ? data : {};
        let result = new ExerciseImport();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.muscleGroupNames)) {
            data["muscleGroupNames"] = [];
            for (let item of this.muscleGroupNames)
                data["muscleGroupNames"].push(item);
        }
        data["equipmentName"] = this.equipmentName;
        data["exerciseName"] = this.exerciseName;
        data["demoUrl"] = this.demoUrl;
        data["type"] = this.type;
        data["description"] = this.description;
        data["publicVisibility"] = this.publicVisibility;
        return data;
    }
}

export interface IExerciseImport {
    muscleGroupNames?: string[];
    equipmentName?: string | undefined;
    exerciseName?: string | undefined;
    demoUrl?: string | undefined;
    type?: string;
    description?: string | undefined;
    publicVisibility?: boolean | undefined;
}

export class UpdateExerciseCommand implements IUpdateExerciseCommand {
    exerciseId?: number;
    createdBy?: string | undefined;
    muscleGroupIds?: number[];
    equipmentId?: number | undefined;
    exerciseName?: string | undefined;
    demoUrl?: string | undefined;
    type?: string;
    description?: string | undefined;
    publicVisibility?: boolean | undefined;

    constructor(data?: IUpdateExerciseCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.exerciseId = _data["exerciseId"];
            this.createdBy = _data["createdBy"];
            if (Array.isArray(_data["muscleGroupIds"])) {
                this.muscleGroupIds = [] as any;
                for (let item of _data["muscleGroupIds"])
                    this.muscleGroupIds!.push(item);
            }
            this.equipmentId = _data["equipmentId"];
            this.exerciseName = _data["exerciseName"];
            this.demoUrl = _data["demoUrl"];
            this.type = _data["type"];
            this.description = _data["description"];
            this.publicVisibility = _data["publicVisibility"];
        }
    }

    static fromJS(data: any): UpdateExerciseCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateExerciseCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exerciseId"] = this.exerciseId;
        data["createdBy"] = this.createdBy;
        if (Array.isArray(this.muscleGroupIds)) {
            data["muscleGroupIds"] = [];
            for (let item of this.muscleGroupIds)
                data["muscleGroupIds"].push(item);
        }
        data["equipmentId"] = this.equipmentId;
        data["exerciseName"] = this.exerciseName;
        data["demoUrl"] = this.demoUrl;
        data["type"] = this.type;
        data["description"] = this.description;
        data["publicVisibility"] = this.publicVisibility;
        return data;
    }
}

export interface IUpdateExerciseCommand {
    exerciseId?: number;
    createdBy?: string | undefined;
    muscleGroupIds?: number[];
    equipmentId?: number | undefined;
    exerciseName?: string | undefined;
    demoUrl?: string | undefined;
    type?: string;
    description?: string | undefined;
    publicVisibility?: boolean | undefined;
}

export class DeleteExerciseCommand implements IDeleteExerciseCommand {
    exerciseId?: number;

    constructor(data?: IDeleteExerciseCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.exerciseId = _data["exerciseId"];
        }
    }

    static fromJS(data: any): DeleteExerciseCommand {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteExerciseCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exerciseId"] = this.exerciseId;
        return data;
    }
}

export interface IDeleteExerciseCommand {
    exerciseId?: number;
}

export class CreateMuscleGroupCommand implements ICreateMuscleGroupCommand {
    muscleGroupName?: string | undefined;
    imageUrl?: string | undefined;

    constructor(data?: ICreateMuscleGroupCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.muscleGroupName = _data["muscleGroupName"];
            this.imageUrl = _data["imageUrl"];
        }
    }

    static fromJS(data: any): CreateMuscleGroupCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateMuscleGroupCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["muscleGroupName"] = this.muscleGroupName;
        data["imageUrl"] = this.imageUrl;
        return data;
    }
}

export interface ICreateMuscleGroupCommand {
    muscleGroupName?: string | undefined;
    imageUrl?: string | undefined;
}

export class PaginatedListOfMuscleGroupDTO implements IPaginatedListOfMuscleGroupDTO {
    items?: MuscleGroupDTO[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfMuscleGroupDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(MuscleGroupDTO.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfMuscleGroupDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfMuscleGroupDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfMuscleGroupDTO {
    items?: MuscleGroupDTO[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class MuscleGroupDTO implements IMuscleGroupDTO {
    muscleGroupId?: number;
    muscleGroupName?: string | undefined;
    imageUrl?: string | undefined;

    constructor(data?: IMuscleGroupDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.muscleGroupId = _data["muscleGroupId"];
            this.muscleGroupName = _data["muscleGroupName"];
            this.imageUrl = _data["imageUrl"];
        }
    }

    static fromJS(data: any): MuscleGroupDTO {
        data = typeof data === 'object' ? data : {};
        let result = new MuscleGroupDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["muscleGroupId"] = this.muscleGroupId;
        data["muscleGroupName"] = this.muscleGroupName;
        data["imageUrl"] = this.imageUrl;
        return data;
    }
}

export interface IMuscleGroupDTO {
    muscleGroupId?: number;
    muscleGroupName?: string | undefined;
    imageUrl?: string | undefined;
}

export class MuscleGroupDTO2 implements IMuscleGroupDTO2 {
    muscleGroupId?: number;
    muscleGroupName?: string | undefined;
    imageUrl?: string | undefined;

    constructor(data?: IMuscleGroupDTO2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.muscleGroupId = _data["muscleGroupId"];
            this.muscleGroupName = _data["muscleGroupName"];
            this.imageUrl = _data["imageUrl"];
        }
    }

    static fromJS(data: any): MuscleGroupDTO2 {
        data = typeof data === 'object' ? data : {};
        let result = new MuscleGroupDTO2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["muscleGroupId"] = this.muscleGroupId;
        data["muscleGroupName"] = this.muscleGroupName;
        data["imageUrl"] = this.imageUrl;
        return data;
    }
}

export interface IMuscleGroupDTO2 {
    muscleGroupId?: number;
    muscleGroupName?: string | undefined;
    imageUrl?: string | undefined;
}

export class UpdateMuscleGroupCommand implements IUpdateMuscleGroupCommand {
    id?: number;
    muscleGroupName?: string | undefined;
    imageUrl?: string | undefined;

    constructor(data?: IUpdateMuscleGroupCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.muscleGroupName = _data["muscleGroupName"];
            this.imageUrl = _data["imageUrl"];
        }
    }

    static fromJS(data: any): UpdateMuscleGroupCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateMuscleGroupCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["muscleGroupName"] = this.muscleGroupName;
        data["imageUrl"] = this.imageUrl;
        return data;
    }
}

export interface IUpdateMuscleGroupCommand {
    id?: number;
    muscleGroupName?: string | undefined;
    imageUrl?: string | undefined;
}

export class DeleteMuscleGroupCommand implements IDeleteMuscleGroupCommand {
    id?: number;

    constructor(data?: IDeleteMuscleGroupCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DeleteMuscleGroupCommand {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteMuscleGroupCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface IDeleteMuscleGroupCommand {
    id?: number;
}

export class SummaryWorkoutLogStatsDTO implements ISummaryWorkoutLogStatsDTO {
    numberOfWorkouts?: number;
    hoursAtTheGym?: number;
    weightLifted?: number;
    weekStreak?: number;

    constructor(data?: ISummaryWorkoutLogStatsDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.numberOfWorkouts = _data["numberOfWorkouts"];
            this.hoursAtTheGym = _data["hoursAtTheGym"];
            this.weightLifted = _data["weightLifted"];
            this.weekStreak = _data["weekStreak"];
        }
    }

    static fromJS(data: any): SummaryWorkoutLogStatsDTO {
        data = typeof data === 'object' ? data : {};
        let result = new SummaryWorkoutLogStatsDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["numberOfWorkouts"] = this.numberOfWorkouts;
        data["hoursAtTheGym"] = this.hoursAtTheGym;
        data["weightLifted"] = this.weightLifted;
        data["weekStreak"] = this.weekStreak;
        return data;
    }
}

export interface ISummaryWorkoutLogStatsDTO {
    numberOfWorkouts?: number;
    hoursAtTheGym?: number;
    weightLifted?: number;
    weekStreak?: number;
}

export class CreateSurveyAnswerCommand implements ICreateSurveyAnswerCommand {
    userId?: string | undefined;
    goal?: string | undefined;
    daysPerWeek?: number | undefined;
    experienceLevel?: string | undefined;
    gymType?: string | undefined;
    musclesPriority?: string | undefined;
    age?: number | undefined;
    lastModified?: Date;

    constructor(data?: ICreateSurveyAnswerCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.goal = _data["goal"];
            this.daysPerWeek = _data["daysPerWeek"];
            this.experienceLevel = _data["experienceLevel"];
            this.gymType = _data["gymType"];
            this.musclesPriority = _data["musclesPriority"];
            this.age = _data["age"];
            this.lastModified = _data["lastModified"] ? new Date(_data["lastModified"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateSurveyAnswerCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSurveyAnswerCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["goal"] = this.goal;
        data["daysPerWeek"] = this.daysPerWeek;
        data["experienceLevel"] = this.experienceLevel;
        data["gymType"] = this.gymType;
        data["musclesPriority"] = this.musclesPriority;
        data["age"] = this.age;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>undefined;
        return data;
    }
}

export interface ICreateSurveyAnswerCommand {
    userId?: string | undefined;
    goal?: string | undefined;
    daysPerWeek?: number | undefined;
    experienceLevel?: string | undefined;
    gymType?: string | undefined;
    musclesPriority?: string | undefined;
    age?: number | undefined;
    lastModified?: Date;
}

export class UpdateTrainingSurveyAnswersCommand implements IUpdateTrainingSurveyAnswersCommand {
    surveyAnswerId?: number;
    userId?: string | undefined;
    goal?: string | undefined;
    daysPerWeek?: number | undefined;
    experienceLevel?: string | undefined;
    gymType?: string | undefined;
    musclesPriority?: string | undefined;
    age?: number | undefined;
    lastModified?: Date;

    constructor(data?: IUpdateTrainingSurveyAnswersCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.surveyAnswerId = _data["surveyAnswerId"];
            this.userId = _data["userId"];
            this.goal = _data["goal"];
            this.daysPerWeek = _data["daysPerWeek"];
            this.experienceLevel = _data["experienceLevel"];
            this.gymType = _data["gymType"];
            this.musclesPriority = _data["musclesPriority"];
            this.age = _data["age"];
            this.lastModified = _data["lastModified"] ? new Date(_data["lastModified"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateTrainingSurveyAnswersCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTrainingSurveyAnswersCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["surveyAnswerId"] = this.surveyAnswerId;
        data["userId"] = this.userId;
        data["goal"] = this.goal;
        data["daysPerWeek"] = this.daysPerWeek;
        data["experienceLevel"] = this.experienceLevel;
        data["gymType"] = this.gymType;
        data["musclesPriority"] = this.musclesPriority;
        data["age"] = this.age;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>undefined;
        return data;
    }
}

export interface IUpdateTrainingSurveyAnswersCommand {
    surveyAnswerId?: number;
    userId?: string | undefined;
    goal?: string | undefined;
    daysPerWeek?: number | undefined;
    experienceLevel?: string | undefined;
    gymType?: string | undefined;
    musclesPriority?: string | undefined;
    age?: number | undefined;
    lastModified?: Date;
}

export class PaginatedListOfWorkoutLogDTO implements IPaginatedListOfWorkoutLogDTO {
    items?: WorkoutLogDTO[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfWorkoutLogDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(WorkoutLogDTO.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfWorkoutLogDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfWorkoutLogDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfWorkoutLogDTO {
    items?: WorkoutLogDTO[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class WorkoutLogDTO implements IWorkoutLogDTO {
    createdBy?: string | undefined;
    note?: string | undefined;
    duration?: string | undefined;
    created?: Date;
    lastModified?: Date | undefined;
    exerciseLogs?: ExerciseLogDTO[];

    constructor(data?: IWorkoutLogDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.note = _data["note"];
            this.duration = _data["duration"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.lastModified = _data["lastModified"] ? new Date(_data["lastModified"].toString()) : <any>undefined;
            if (Array.isArray(_data["exerciseLogs"])) {
                this.exerciseLogs = [] as any;
                for (let item of _data["exerciseLogs"])
                    this.exerciseLogs!.push(ExerciseLogDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WorkoutLogDTO {
        data = typeof data === 'object' ? data : {};
        let result = new WorkoutLogDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["note"] = this.note;
        data["duration"] = this.duration;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>undefined;
        if (Array.isArray(this.exerciseLogs)) {
            data["exerciseLogs"] = [];
            for (let item of this.exerciseLogs)
                data["exerciseLogs"].push(item.toJSON());
        }
        return data;
    }
}

export interface IWorkoutLogDTO {
    createdBy?: string | undefined;
    note?: string | undefined;
    duration?: string | undefined;
    created?: Date;
    lastModified?: Date | undefined;
    exerciseLogs?: ExerciseLogDTO[];
}

export class ExerciseLogDTO implements IExerciseLogDTO {
    exerciseLogId?: number;
    workoutLogId?: number | undefined;
    exerciseId?: number | undefined;
    dateCreated?: Date;
    lastModified?: Date;
    orderInSession?: number | undefined;
    orderInSuperset?: number | undefined;
    note?: string | undefined;
    numberOfSets?: number | undefined;
    weightsUsed?: string | undefined;
    numberOfReps?: string | undefined;
    footageUrls?: string | undefined;
    exerciseName?: string | undefined;

    constructor(data?: IExerciseLogDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.exerciseLogId = _data["exerciseLogId"];
            this.workoutLogId = _data["workoutLogId"];
            this.exerciseId = _data["exerciseId"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.lastModified = _data["lastModified"] ? new Date(_data["lastModified"].toString()) : <any>undefined;
            this.orderInSession = _data["orderInSession"];
            this.orderInSuperset = _data["orderInSuperset"];
            this.note = _data["note"];
            this.numberOfSets = _data["numberOfSets"];
            this.weightsUsed = _data["weightsUsed"];
            this.numberOfReps = _data["numberOfReps"];
            this.footageUrls = _data["footageUrls"];
            this.exerciseName = _data["exerciseName"];
        }
    }

    static fromJS(data: any): ExerciseLogDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ExerciseLogDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exerciseLogId"] = this.exerciseLogId;
        data["workoutLogId"] = this.workoutLogId;
        data["exerciseId"] = this.exerciseId;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>undefined;
        data["orderInSession"] = this.orderInSession;
        data["orderInSuperset"] = this.orderInSuperset;
        data["note"] = this.note;
        data["numberOfSets"] = this.numberOfSets;
        data["weightsUsed"] = this.weightsUsed;
        data["numberOfReps"] = this.numberOfReps;
        data["footageUrls"] = this.footageUrls;
        data["exerciseName"] = this.exerciseName;
        return data;
    }
}

export interface IExerciseLogDTO {
    exerciseLogId?: number;
    workoutLogId?: number | undefined;
    exerciseId?: number | undefined;
    dateCreated?: Date;
    lastModified?: Date;
    orderInSession?: number | undefined;
    orderInSuperset?: number | undefined;
    note?: string | undefined;
    numberOfSets?: number | undefined;
    weightsUsed?: string | undefined;
    numberOfReps?: string | undefined;
    footageUrls?: string | undefined;
    exerciseName?: string | undefined;
}

export class CreateWorkoutLogCommand implements ICreateWorkoutLogCommand {
    createdBy?: string | undefined;
    note?: string | undefined;
    duration?: string | undefined;
    exerciseLogs?: CreateExerciseLogCommand[] | undefined;

    constructor(data?: ICreateWorkoutLogCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.note = _data["note"];
            this.duration = _data["duration"];
            if (Array.isArray(_data["exerciseLogs"])) {
                this.exerciseLogs = [] as any;
                for (let item of _data["exerciseLogs"])
                    this.exerciseLogs!.push(CreateExerciseLogCommand.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateWorkoutLogCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateWorkoutLogCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["note"] = this.note;
        data["duration"] = this.duration;
        if (Array.isArray(this.exerciseLogs)) {
            data["exerciseLogs"] = [];
            for (let item of this.exerciseLogs)
                data["exerciseLogs"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICreateWorkoutLogCommand {
    createdBy?: string | undefined;
    note?: string | undefined;
    duration?: string | undefined;
    exerciseLogs?: CreateExerciseLogCommand[] | undefined;
}

export class CreateExerciseLogCommand implements ICreateExerciseLogCommand {
    exerciseId?: number | undefined;
    orderInSession?: number | undefined;
    orderInSuperset?: number | undefined;
    note?: string | undefined;
    numberOfSets?: number | undefined;
    weightsUsedValue?: number[] | undefined;
    numberOfRepsValue?: number[] | undefined;
    weightsUsed?: string | undefined;
    numberOfReps?: string | undefined;
    footageUrls?: string | undefined;

    constructor(data?: ICreateExerciseLogCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.exerciseId = _data["exerciseId"];
            this.orderInSession = _data["orderInSession"];
            this.orderInSuperset = _data["orderInSuperset"];
            this.note = _data["note"];
            this.numberOfSets = _data["numberOfSets"];
            if (Array.isArray(_data["weightsUsedValue"])) {
                this.weightsUsedValue = [] as any;
                for (let item of _data["weightsUsedValue"])
                    this.weightsUsedValue!.push(item);
            }
            if (Array.isArray(_data["numberOfRepsValue"])) {
                this.numberOfRepsValue = [] as any;
                for (let item of _data["numberOfRepsValue"])
                    this.numberOfRepsValue!.push(item);
            }
            this.weightsUsed = _data["weightsUsed"];
            this.numberOfReps = _data["numberOfReps"];
            this.footageUrls = _data["footageUrls"];
        }
    }

    static fromJS(data: any): CreateExerciseLogCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateExerciseLogCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exerciseId"] = this.exerciseId;
        data["orderInSession"] = this.orderInSession;
        data["orderInSuperset"] = this.orderInSuperset;
        data["note"] = this.note;
        data["numberOfSets"] = this.numberOfSets;
        if (Array.isArray(this.weightsUsedValue)) {
            data["weightsUsedValue"] = [];
            for (let item of this.weightsUsedValue)
                data["weightsUsedValue"].push(item);
        }
        if (Array.isArray(this.numberOfRepsValue)) {
            data["numberOfRepsValue"] = [];
            for (let item of this.numberOfRepsValue)
                data["numberOfRepsValue"].push(item);
        }
        data["weightsUsed"] = this.weightsUsed;
        data["numberOfReps"] = this.numberOfReps;
        data["footageUrls"] = this.footageUrls;
        return data;
    }
}

export interface ICreateExerciseLogCommand {
    exerciseId?: number | undefined;
    orderInSession?: number | undefined;
    orderInSuperset?: number | undefined;
    note?: string | undefined;
    numberOfSets?: number | undefined;
    weightsUsedValue?: number[] | undefined;
    numberOfRepsValue?: number[] | undefined;
    weightsUsed?: string | undefined;
    numberOfReps?: string | undefined;
    footageUrls?: string | undefined;
}

export class UpdateWorkoutLogCommand implements IUpdateWorkoutLogCommand {
    workoutLogId?: number;
    note?: string | undefined;
    duration?: string | undefined;
    exerciseLogs?: UpdateExerciseLogCommand[] | undefined;

    constructor(data?: IUpdateWorkoutLogCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.workoutLogId = _data["workoutLogId"];
            this.note = _data["note"];
            this.duration = _data["duration"];
            if (Array.isArray(_data["exerciseLogs"])) {
                this.exerciseLogs = [] as any;
                for (let item of _data["exerciseLogs"])
                    this.exerciseLogs!.push(UpdateExerciseLogCommand.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateWorkoutLogCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateWorkoutLogCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["workoutLogId"] = this.workoutLogId;
        data["note"] = this.note;
        data["duration"] = this.duration;
        if (Array.isArray(this.exerciseLogs)) {
            data["exerciseLogs"] = [];
            for (let item of this.exerciseLogs)
                data["exerciseLogs"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUpdateWorkoutLogCommand {
    workoutLogId?: number;
    note?: string | undefined;
    duration?: string | undefined;
    exerciseLogs?: UpdateExerciseLogCommand[] | undefined;
}

export class UpdateExerciseLogCommand implements IUpdateExerciseLogCommand {
    exerciseLogId?: number | undefined;
    exerciseId?: number | undefined;
    orderInSession?: number | undefined;
    orderInSuperset?: number | undefined;
    note?: string | undefined;
    numberOfSets?: number | undefined;
    weightsUsedValue?: number[] | undefined;
    numberOfRepsValue?: number[] | undefined;
    weightsUsed?: string | undefined;
    numberOfReps?: string | undefined;
    footageUrls?: string | undefined;
    isDeleted?: boolean;

    constructor(data?: IUpdateExerciseLogCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.exerciseLogId = _data["exerciseLogId"];
            this.exerciseId = _data["exerciseId"];
            this.orderInSession = _data["orderInSession"];
            this.orderInSuperset = _data["orderInSuperset"];
            this.note = _data["note"];
            this.numberOfSets = _data["numberOfSets"];
            if (Array.isArray(_data["weightsUsedValue"])) {
                this.weightsUsedValue = [] as any;
                for (let item of _data["weightsUsedValue"])
                    this.weightsUsedValue!.push(item);
            }
            if (Array.isArray(_data["numberOfRepsValue"])) {
                this.numberOfRepsValue = [] as any;
                for (let item of _data["numberOfRepsValue"])
                    this.numberOfRepsValue!.push(item);
            }
            this.weightsUsed = _data["weightsUsed"];
            this.numberOfReps = _data["numberOfReps"];
            this.footageUrls = _data["footageUrls"];
            this.isDeleted = _data["isDeleted"];
        }
    }

    static fromJS(data: any): UpdateExerciseLogCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateExerciseLogCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exerciseLogId"] = this.exerciseLogId;
        data["exerciseId"] = this.exerciseId;
        data["orderInSession"] = this.orderInSession;
        data["orderInSuperset"] = this.orderInSuperset;
        data["note"] = this.note;
        data["numberOfSets"] = this.numberOfSets;
        if (Array.isArray(this.weightsUsedValue)) {
            data["weightsUsedValue"] = [];
            for (let item of this.weightsUsedValue)
                data["weightsUsedValue"].push(item);
        }
        if (Array.isArray(this.numberOfRepsValue)) {
            data["numberOfRepsValue"] = [];
            for (let item of this.numberOfRepsValue)
                data["numberOfRepsValue"].push(item);
        }
        data["weightsUsed"] = this.weightsUsed;
        data["numberOfReps"] = this.numberOfReps;
        data["footageUrls"] = this.footageUrls;
        data["isDeleted"] = this.isDeleted;
        return data;
    }
}

export interface IUpdateExerciseLogCommand {
    exerciseLogId?: number | undefined;
    exerciseId?: number | undefined;
    orderInSession?: number | undefined;
    orderInSuperset?: number | undefined;
    note?: string | undefined;
    numberOfSets?: number | undefined;
    weightsUsedValue?: number[] | undefined;
    numberOfRepsValue?: number[] | undefined;
    weightsUsed?: string | undefined;
    numberOfReps?: string | undefined;
    footageUrls?: string | undefined;
    isDeleted?: boolean;
}

export class DeleteWorkoutLogCommand implements IDeleteWorkoutLogCommand {
    workoutLogId?: number;

    constructor(data?: IDeleteWorkoutLogCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.workoutLogId = _data["workoutLogId"];
        }
    }

    static fromJS(data: any): DeleteWorkoutLogCommand {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteWorkoutLogCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["workoutLogId"] = this.workoutLogId;
        return data;
    }
}

export interface IDeleteWorkoutLogCommand {
    workoutLogId?: number;
}

export class WorkoutProgramListDTO implements IWorkoutProgramListDTO {
    programId?: number;
    programName?: string;
    programThumbnail?: string | undefined;
    numberOfWeeks?: number | undefined;
    daysPerWeek?: number | undefined;
    goal?: string | undefined;
    experienceLevel?: string | undefined;
    gymType?: string | undefined;
    musclesPriority?: string | undefined;
    ageGroup?: string | undefined;
    publicProgram?: boolean | undefined;
    userId?: string | undefined;
    userName?: string | undefined;

    constructor(data?: IWorkoutProgramListDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.programId = _data["programId"];
            this.programName = _data["programName"];
            this.programThumbnail = _data["programThumbnail"];
            this.numberOfWeeks = _data["numberOfWeeks"];
            this.daysPerWeek = _data["daysPerWeek"];
            this.goal = _data["goal"];
            this.experienceLevel = _data["experienceLevel"];
            this.gymType = _data["gymType"];
            this.musclesPriority = _data["musclesPriority"];
            this.ageGroup = _data["ageGroup"];
            this.publicProgram = _data["publicProgram"];
            this.userId = _data["userId"];
            this.userName = _data["userName"];
        }
    }

    static fromJS(data: any): WorkoutProgramListDTO {
        data = typeof data === 'object' ? data : {};
        let result = new WorkoutProgramListDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["programId"] = this.programId;
        data["programName"] = this.programName;
        data["programThumbnail"] = this.programThumbnail;
        data["numberOfWeeks"] = this.numberOfWeeks;
        data["daysPerWeek"] = this.daysPerWeek;
        data["goal"] = this.goal;
        data["experienceLevel"] = this.experienceLevel;
        data["gymType"] = this.gymType;
        data["musclesPriority"] = this.musclesPriority;
        data["ageGroup"] = this.ageGroup;
        data["publicProgram"] = this.publicProgram;
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        return data;
    }
}

export interface IWorkoutProgramListDTO {
    programId?: number;
    programName?: string;
    programThumbnail?: string | undefined;
    numberOfWeeks?: number | undefined;
    daysPerWeek?: number | undefined;
    goal?: string | undefined;
    experienceLevel?: string | undefined;
    gymType?: string | undefined;
    musclesPriority?: string | undefined;
    ageGroup?: string | undefined;
    publicProgram?: boolean | undefined;
    userId?: string | undefined;
    userName?: string | undefined;
}

export class CreateWorkoutProgramCommand implements ICreateWorkoutProgramCommand {
    userId?: string | undefined;
    programName?: string;
    programThumbnail?: string | undefined;
    numberOfWeeks?: number | undefined;
    daysPerWeek?: number | undefined;
    goal?: string | undefined;
    experienceLevel?: string | undefined;
    gymType?: string | undefined;
    musclesPriority?: string | undefined;
    ageGroup?: string | undefined;
    publicProgram?: boolean | undefined;
    programWorkouts?: CreateProgramWorkoutCommand[];

    constructor(data?: ICreateWorkoutProgramCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.programName = _data["programName"];
            this.programThumbnail = _data["programThumbnail"];
            this.numberOfWeeks = _data["numberOfWeeks"];
            this.daysPerWeek = _data["daysPerWeek"];
            this.goal = _data["goal"];
            this.experienceLevel = _data["experienceLevel"];
            this.gymType = _data["gymType"];
            this.musclesPriority = _data["musclesPriority"];
            this.ageGroup = _data["ageGroup"];
            this.publicProgram = _data["publicProgram"];
            if (Array.isArray(_data["programWorkouts"])) {
                this.programWorkouts = [] as any;
                for (let item of _data["programWorkouts"])
                    this.programWorkouts!.push(CreateProgramWorkoutCommand.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateWorkoutProgramCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateWorkoutProgramCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["programName"] = this.programName;
        data["programThumbnail"] = this.programThumbnail;
        data["numberOfWeeks"] = this.numberOfWeeks;
        data["daysPerWeek"] = this.daysPerWeek;
        data["goal"] = this.goal;
        data["experienceLevel"] = this.experienceLevel;
        data["gymType"] = this.gymType;
        data["musclesPriority"] = this.musclesPriority;
        data["ageGroup"] = this.ageGroup;
        data["publicProgram"] = this.publicProgram;
        if (Array.isArray(this.programWorkouts)) {
            data["programWorkouts"] = [];
            for (let item of this.programWorkouts)
                data["programWorkouts"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICreateWorkoutProgramCommand {
    userId?: string | undefined;
    programName?: string;
    programThumbnail?: string | undefined;
    numberOfWeeks?: number | undefined;
    daysPerWeek?: number | undefined;
    goal?: string | undefined;
    experienceLevel?: string | undefined;
    gymType?: string | undefined;
    musclesPriority?: string | undefined;
    ageGroup?: string | undefined;
    publicProgram?: boolean | undefined;
    programWorkouts?: CreateProgramWorkoutCommand[];
}

export class CreateProgramWorkoutCommand implements ICreateProgramWorkoutCommand {
    weekNumber?: number | undefined;
    orderInWeek?: number | undefined;
    workoutTemplate?: CreateWorkoutTemplateCommand | undefined;

    constructor(data?: ICreateProgramWorkoutCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.weekNumber = _data["weekNumber"];
            this.orderInWeek = _data["orderInWeek"];
            this.workoutTemplate = _data["workoutTemplate"] ? CreateWorkoutTemplateCommand.fromJS(_data["workoutTemplate"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateProgramWorkoutCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProgramWorkoutCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["weekNumber"] = this.weekNumber;
        data["orderInWeek"] = this.orderInWeek;
        data["workoutTemplate"] = this.workoutTemplate ? this.workoutTemplate.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICreateProgramWorkoutCommand {
    weekNumber?: number | undefined;
    orderInWeek?: number | undefined;
    workoutTemplate?: CreateWorkoutTemplateCommand | undefined;
}

export class CreateWorkoutTemplateCommand implements ICreateWorkoutTemplateCommand {
    templateName?: string | undefined;
    duration?: string | undefined;
    isPublic?: boolean;
    workoutTemplateExercises?: WorkoutTemplateExerciseDto[];

    constructor(data?: ICreateWorkoutTemplateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.templateName = _data["templateName"];
            this.duration = _data["duration"];
            this.isPublic = _data["isPublic"];
            if (Array.isArray(_data["workoutTemplateExercises"])) {
                this.workoutTemplateExercises = [] as any;
                for (let item of _data["workoutTemplateExercises"])
                    this.workoutTemplateExercises!.push(WorkoutTemplateExerciseDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateWorkoutTemplateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateWorkoutTemplateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["templateName"] = this.templateName;
        data["duration"] = this.duration;
        data["isPublic"] = this.isPublic;
        if (Array.isArray(this.workoutTemplateExercises)) {
            data["workoutTemplateExercises"] = [];
            for (let item of this.workoutTemplateExercises)
                data["workoutTemplateExercises"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICreateWorkoutTemplateCommand {
    templateName?: string | undefined;
    duration?: string | undefined;
    isPublic?: boolean;
    workoutTemplateExercises?: WorkoutTemplateExerciseDto[];
}

export class WorkoutTemplateExerciseDto implements IWorkoutTemplateExerciseDto {
    exerciseId?: number | undefined;
    orderInSession?: number | undefined;
    orderInSuperset?: number | undefined;
    note?: string | undefined;
    setsRecommendation?: number | undefined;
    intensityPercentage?: number | undefined;
    rpeRecommendation?: number | undefined;
    weightsUsed?: string | undefined;
    numbersOfReps?: string | undefined;

    constructor(data?: IWorkoutTemplateExerciseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.exerciseId = _data["exerciseId"];
            this.orderInSession = _data["orderInSession"];
            this.orderInSuperset = _data["orderInSuperset"];
            this.note = _data["note"];
            this.setsRecommendation = _data["setsRecommendation"];
            this.intensityPercentage = _data["intensityPercentage"];
            this.rpeRecommendation = _data["rpeRecommendation"];
            this.weightsUsed = _data["weightsUsed"];
            this.numbersOfReps = _data["numbersOfReps"];
        }
    }

    static fromJS(data: any): WorkoutTemplateExerciseDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkoutTemplateExerciseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exerciseId"] = this.exerciseId;
        data["orderInSession"] = this.orderInSession;
        data["orderInSuperset"] = this.orderInSuperset;
        data["note"] = this.note;
        data["setsRecommendation"] = this.setsRecommendation;
        data["intensityPercentage"] = this.intensityPercentage;
        data["rpeRecommendation"] = this.rpeRecommendation;
        data["weightsUsed"] = this.weightsUsed;
        data["numbersOfReps"] = this.numbersOfReps;
        return data;
    }
}

export interface IWorkoutTemplateExerciseDto {
    exerciseId?: number | undefined;
    orderInSession?: number | undefined;
    orderInSuperset?: number | undefined;
    note?: string | undefined;
    setsRecommendation?: number | undefined;
    intensityPercentage?: number | undefined;
    rpeRecommendation?: number | undefined;
    weightsUsed?: string | undefined;
    numbersOfReps?: string | undefined;
}

export class UpdateWorkoutProgramCommand implements IUpdateWorkoutProgramCommand {
    id?: number;
    programName?: string;
    programThumbnail?: string | undefined;
    numberOfWeeks?: number | undefined;
    daysPerWeek?: number | undefined;
    goal?: string | undefined;
    experienceLevel?: string | undefined;
    gymType?: string | undefined;
    musclesPriority?: string | undefined;
    ageGroup?: string | undefined;
    publicProgram?: boolean | undefined;

    constructor(data?: IUpdateWorkoutProgramCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.programName = _data["programName"];
            this.programThumbnail = _data["programThumbnail"];
            this.numberOfWeeks = _data["numberOfWeeks"];
            this.daysPerWeek = _data["daysPerWeek"];
            this.goal = _data["goal"];
            this.experienceLevel = _data["experienceLevel"];
            this.gymType = _data["gymType"];
            this.musclesPriority = _data["musclesPriority"];
            this.ageGroup = _data["ageGroup"];
            this.publicProgram = _data["publicProgram"];
        }
    }

    static fromJS(data: any): UpdateWorkoutProgramCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateWorkoutProgramCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["programName"] = this.programName;
        data["programThumbnail"] = this.programThumbnail;
        data["numberOfWeeks"] = this.numberOfWeeks;
        data["daysPerWeek"] = this.daysPerWeek;
        data["goal"] = this.goal;
        data["experienceLevel"] = this.experienceLevel;
        data["gymType"] = this.gymType;
        data["musclesPriority"] = this.musclesPriority;
        data["ageGroup"] = this.ageGroup;
        data["publicProgram"] = this.publicProgram;
        return data;
    }
}

export interface IUpdateWorkoutProgramCommand {
    id?: number;
    programName?: string;
    programThumbnail?: string | undefined;
    numberOfWeeks?: number | undefined;
    daysPerWeek?: number | undefined;
    goal?: string | undefined;
    experienceLevel?: string | undefined;
    gymType?: string | undefined;
    musclesPriority?: string | undefined;
    ageGroup?: string | undefined;
    publicProgram?: boolean | undefined;
}

export class ProgramEnrollmentDTO implements IProgramEnrollmentDTO {
    enrollmentId?: number;
    userId?: string;
    programId?: number;
    enrolledDate?: Date;
    endDate?: Date | undefined;
    status?: string;
    currentWeekNo?: number | undefined;
    currentWorkoutOrder?: number | undefined;
    programName?: string;
    userName?: string;

    constructor(data?: IProgramEnrollmentDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.enrollmentId = _data["enrollmentId"];
            this.userId = _data["userId"];
            this.programId = _data["programId"];
            this.enrolledDate = _data["enrolledDate"] ? new Date(_data["enrolledDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.currentWeekNo = _data["currentWeekNo"];
            this.currentWorkoutOrder = _data["currentWorkoutOrder"];
            this.programName = _data["programName"];
            this.userName = _data["userName"];
        }
    }

    static fromJS(data: any): ProgramEnrollmentDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ProgramEnrollmentDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["enrollmentId"] = this.enrollmentId;
        data["userId"] = this.userId;
        data["programId"] = this.programId;
        data["enrolledDate"] = this.enrolledDate ? this.enrolledDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["currentWeekNo"] = this.currentWeekNo;
        data["currentWorkoutOrder"] = this.currentWorkoutOrder;
        data["programName"] = this.programName;
        data["userName"] = this.userName;
        return data;
    }
}

export interface IProgramEnrollmentDTO {
    enrollmentId?: number;
    userId?: string;
    programId?: number;
    enrolledDate?: Date;
    endDate?: Date | undefined;
    status?: string;
    currentWeekNo?: number | undefined;
    currentWorkoutOrder?: number | undefined;
    programName?: string;
    userName?: string;
}

export class EnrollProgramCommand implements IEnrollProgramCommand {
    userId?: string;
    programId?: number;

    constructor(data?: IEnrollProgramCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.programId = _data["programId"];
        }
    }

    static fromJS(data: any): EnrollProgramCommand {
        data = typeof data === 'object' ? data : {};
        let result = new EnrollProgramCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["programId"] = this.programId;
        return data;
    }
}

export interface IEnrollProgramCommand {
    userId?: string;
    programId?: number;
}

export class CreatePersonalTemplateCommand implements ICreatePersonalTemplateCommand {
    userToken?: string;
    templateName?: string | undefined;
    duration?: string | undefined;
    workoutTemplateExercises?: PersonalTemplateExerciseDto[];

    constructor(data?: ICreatePersonalTemplateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userToken = _data["userToken"];
            this.templateName = _data["templateName"];
            this.duration = _data["duration"];
            if (Array.isArray(_data["workoutTemplateExercises"])) {
                this.workoutTemplateExercises = [] as any;
                for (let item of _data["workoutTemplateExercises"])
                    this.workoutTemplateExercises!.push(PersonalTemplateExerciseDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreatePersonalTemplateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePersonalTemplateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userToken"] = this.userToken;
        data["templateName"] = this.templateName;
        data["duration"] = this.duration;
        if (Array.isArray(this.workoutTemplateExercises)) {
            data["workoutTemplateExercises"] = [];
            for (let item of this.workoutTemplateExercises)
                data["workoutTemplateExercises"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICreatePersonalTemplateCommand {
    userToken?: string;
    templateName?: string | undefined;
    duration?: string | undefined;
    workoutTemplateExercises?: PersonalTemplateExerciseDto[];
}

export class PersonalTemplateExerciseDto implements IPersonalTemplateExerciseDto {
    exerciseId?: number | undefined;
    orderInSession?: number | undefined;
    orderInSuperset?: number | undefined;
    note?: string | undefined;
    setsRecommendation?: number | undefined;
    intensityPercentage?: number | undefined;
    rpeRecommendation?: number | undefined;
    weightsUsed?: string | undefined;
    numbersOfReps?: string | undefined;

    constructor(data?: IPersonalTemplateExerciseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.exerciseId = _data["exerciseId"];
            this.orderInSession = _data["orderInSession"];
            this.orderInSuperset = _data["orderInSuperset"];
            this.note = _data["note"];
            this.setsRecommendation = _data["setsRecommendation"];
            this.intensityPercentage = _data["intensityPercentage"];
            this.rpeRecommendation = _data["rpeRecommendation"];
            this.weightsUsed = _data["weightsUsed"];
            this.numbersOfReps = _data["numbersOfReps"];
        }
    }

    static fromJS(data: any): PersonalTemplateExerciseDto {
        data = typeof data === 'object' ? data : {};
        let result = new PersonalTemplateExerciseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exerciseId"] = this.exerciseId;
        data["orderInSession"] = this.orderInSession;
        data["orderInSuperset"] = this.orderInSuperset;
        data["note"] = this.note;
        data["setsRecommendation"] = this.setsRecommendation;
        data["intensityPercentage"] = this.intensityPercentage;
        data["rpeRecommendation"] = this.rpeRecommendation;
        data["weightsUsed"] = this.weightsUsed;
        data["numbersOfReps"] = this.numbersOfReps;
        return data;
    }
}

export interface IPersonalTemplateExerciseDto {
    exerciseId?: number | undefined;
    orderInSession?: number | undefined;
    orderInSuperset?: number | undefined;
    note?: string | undefined;
    setsRecommendation?: number | undefined;
    intensityPercentage?: number | undefined;
    rpeRecommendation?: number | undefined;
    weightsUsed?: string | undefined;
    numbersOfReps?: string | undefined;
}

export class UpdateWorkoutTemplateCommand implements IUpdateWorkoutTemplateCommand {
    id?: number;
    templateName?: string | undefined;
    duration?: string | undefined;
    isPublic?: boolean;
    workoutTemplateExercises?: WorkoutTemplateExerciseDto2[];

    constructor(data?: IUpdateWorkoutTemplateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.templateName = _data["templateName"];
            this.duration = _data["duration"];
            this.isPublic = _data["isPublic"];
            if (Array.isArray(_data["workoutTemplateExercises"])) {
                this.workoutTemplateExercises = [] as any;
                for (let item of _data["workoutTemplateExercises"])
                    this.workoutTemplateExercises!.push(WorkoutTemplateExerciseDto2.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateWorkoutTemplateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateWorkoutTemplateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["templateName"] = this.templateName;
        data["duration"] = this.duration;
        data["isPublic"] = this.isPublic;
        if (Array.isArray(this.workoutTemplateExercises)) {
            data["workoutTemplateExercises"] = [];
            for (let item of this.workoutTemplateExercises)
                data["workoutTemplateExercises"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUpdateWorkoutTemplateCommand {
    id?: number;
    templateName?: string | undefined;
    duration?: string | undefined;
    isPublic?: boolean;
    workoutTemplateExercises?: WorkoutTemplateExerciseDto2[];
}

export class WorkoutTemplateExerciseDto2 implements IWorkoutTemplateExerciseDto2 {
    exerciseId?: number | undefined;
    orderInSession?: number | undefined;
    orderInSuperset?: number | undefined;
    note?: string | undefined;
    setsRecommendation?: number | undefined;
    intensityPercentage?: number | undefined;
    rpeRecommendation?: number | undefined;
    weightsUsed?: string | undefined;
    numbersOfReps?: string | undefined;

    constructor(data?: IWorkoutTemplateExerciseDto2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.exerciseId = _data["exerciseId"];
            this.orderInSession = _data["orderInSession"];
            this.orderInSuperset = _data["orderInSuperset"];
            this.note = _data["note"];
            this.setsRecommendation = _data["setsRecommendation"];
            this.intensityPercentage = _data["intensityPercentage"];
            this.rpeRecommendation = _data["rpeRecommendation"];
            this.weightsUsed = _data["weightsUsed"];
            this.numbersOfReps = _data["numbersOfReps"];
        }
    }

    static fromJS(data: any): WorkoutTemplateExerciseDto2 {
        data = typeof data === 'object' ? data : {};
        let result = new WorkoutTemplateExerciseDto2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exerciseId"] = this.exerciseId;
        data["orderInSession"] = this.orderInSession;
        data["orderInSuperset"] = this.orderInSuperset;
        data["note"] = this.note;
        data["setsRecommendation"] = this.setsRecommendation;
        data["intensityPercentage"] = this.intensityPercentage;
        data["rpeRecommendation"] = this.rpeRecommendation;
        data["weightsUsed"] = this.weightsUsed;
        data["numbersOfReps"] = this.numbersOfReps;
        return data;
    }
}

export interface IWorkoutTemplateExerciseDto2 {
    exerciseId?: number | undefined;
    orderInSession?: number | undefined;
    orderInSuperset?: number | undefined;
    note?: string | undefined;
    setsRecommendation?: number | undefined;
    intensityPercentage?: number | undefined;
    rpeRecommendation?: number | undefined;
    weightsUsed?: string | undefined;
    numbersOfReps?: string | undefined;
}

export class PaginatedListOfWorkoutTemplateListDto implements IPaginatedListOfWorkoutTemplateListDto {
    items?: WorkoutTemplateListDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfWorkoutTemplateListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(WorkoutTemplateListDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfWorkoutTemplateListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfWorkoutTemplateListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfWorkoutTemplateListDto {
    items?: WorkoutTemplateListDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class WorkoutTemplateListDto implements IWorkoutTemplateListDto {
    id?: number;
    templateName?: string | undefined;
    duration?: string | undefined;
    creatorName?: string;

    constructor(data?: IWorkoutTemplateListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.templateName = _data["templateName"];
            this.duration = _data["duration"];
            this.creatorName = _data["creatorName"];
        }
    }

    static fromJS(data: any): WorkoutTemplateListDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkoutTemplateListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["templateName"] = this.templateName;
        data["duration"] = this.duration;
        data["creatorName"] = this.creatorName;
        return data;
    }
}

export interface IWorkoutTemplateListDto {
    id?: number;
    templateName?: string | undefined;
    duration?: string | undefined;
    creatorName?: string;
}

export class LoginResultDTO implements ILoginResultDTO {
    success?: boolean;
    token?: string;

    constructor(data?: ILoginResultDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): LoginResultDTO {
        data = typeof data === 'object' ? data : {};
        let result = new LoginResultDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["token"] = this.token;
        return data;
    }
}

export interface ILoginResultDTO {
    success?: boolean;
    token?: string;
}

export class LoginQuery implements ILoginQuery {
    username?: string;
    password?: string;

    constructor(data?: ILoginQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.username = _data["username"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): LoginQuery {
        data = typeof data === 'object' ? data : {};
        let result = new LoginQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username;
        data["password"] = this.password;
        return data;
    }
}

export interface ILoginQuery {
    username?: string;
    password?: string;
}

export class GoogleLoginRequest implements IGoogleLoginRequest {
    token?: string;

    constructor(data?: IGoogleLoginRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): GoogleLoginRequest {
        data = typeof data === 'object' ? data : {};
        let result = new GoogleLoginRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        return data;
    }
}

export interface IGoogleLoginRequest {
    token?: string;
}

export class FacebookLoginRequest implements IFacebookLoginRequest {
    userId?: string;
    name?: string;
    email?: string;

    constructor(data?: IFacebookLoginRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.name = _data["name"];
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): FacebookLoginRequest {
        data = typeof data === 'object' ? data : {};
        let result = new FacebookLoginRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["name"] = this.name;
        data["email"] = this.email;
        return data;
    }
}

export interface IFacebookLoginRequest {
    userId?: string;
    name?: string;
    email?: string;
}

export class RoleDto implements IRoleDto {
    id?: string;
    name?: string;

    constructor(data?: IRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): RoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IRoleDto {
    id?: string;
    name?: string;
}

export class AddRoleCommand implements IAddRoleCommand {
    roleName?: string;
    roleDesc?: string;

    constructor(data?: IAddRoleCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.roleName = _data["roleName"];
            this.roleDesc = _data["roleDesc"];
        }
    }

    static fromJS(data: any): AddRoleCommand {
        data = typeof data === 'object' ? data : {};
        let result = new AddRoleCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleName"] = this.roleName;
        data["roleDesc"] = this.roleDesc;
        return data;
    }
}

export interface IAddRoleCommand {
    roleName?: string;
    roleDesc?: string;
}

export class UpdateRoleCommand implements IUpdateRoleCommand {
    roleId?: number;
    roleName?: string;
    roleDescription?: string;

    constructor(data?: IUpdateRoleCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.roleId = _data["roleId"];
            this.roleName = _data["roleName"];
            this.roleDescription = _data["roleDescription"];
        }
    }

    static fromJS(data: any): UpdateRoleCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateRoleCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        data["roleName"] = this.roleName;
        data["roleDescription"] = this.roleDescription;
        return data;
    }
}

export interface IUpdateRoleCommand {
    roleId?: number;
    roleName?: string;
    roleDescription?: string;
}

export class DeleteRoleCommand implements IDeleteRoleCommand {
    roleId?: number;

    constructor(data?: IDeleteRoleCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.roleId = _data["roleId"];
        }
    }

    static fromJS(data: any): DeleteRoleCommand {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteRoleCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        return data;
    }
}

export interface IDeleteRoleCommand {
    roleId?: number;
}

export class RegisterCommand implements IRegisterCommand {
    email?: string;
    password?: string;
    userName?: string;

    constructor(data?: IRegisterCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
            this.userName = _data["userName"];
        }
    }

    static fromJS(data: any): RegisterCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        data["userName"] = this.userName;
        return data;
    }
}

export interface IRegisterCommand {
    email?: string;
    password?: string;
    userName?: string;
}

export class PaginatedListOfAspNetUserListDTO implements IPaginatedListOfAspNetUserListDTO {
    items?: AspNetUserListDTO[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfAspNetUserListDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AspNetUserListDTO.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfAspNetUserListDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfAspNetUserListDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfAspNetUserListDTO {
    items?: AspNetUserListDTO[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class AspNetUserListDTO implements IAspNetUserListDTO {
    id!: string;
    userName?: string | undefined;
    email?: string | undefined;
    emailConfirmed?: boolean;
    phoneNumber?: string | undefined;
    phoneNumberConfirmed?: boolean;
    lockoutEnd?: Date | undefined;
    lockoutEnabled?: boolean;
    accessFailedCount?: number;

    constructor(data?: IAspNetUserListDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.email = _data["email"];
            this.emailConfirmed = _data["emailConfirmed"];
            this.phoneNumber = _data["phoneNumber"];
            this.phoneNumberConfirmed = _data["phoneNumberConfirmed"];
            this.lockoutEnd = _data["lockoutEnd"] ? new Date(_data["lockoutEnd"].toString()) : <any>undefined;
            this.lockoutEnabled = _data["lockoutEnabled"];
            this.accessFailedCount = _data["accessFailedCount"];
        }
    }

    static fromJS(data: any): AspNetUserListDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AspNetUserListDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["email"] = this.email;
        data["emailConfirmed"] = this.emailConfirmed;
        data["phoneNumber"] = this.phoneNumber;
        data["phoneNumberConfirmed"] = this.phoneNumberConfirmed;
        data["lockoutEnd"] = this.lockoutEnd ? this.lockoutEnd.toISOString() : <any>undefined;
        data["lockoutEnabled"] = this.lockoutEnabled;
        data["accessFailedCount"] = this.accessFailedCount;
        return data;
    }
}

export interface IAspNetUserListDTO {
    id: string;
    userName?: string | undefined;
    email?: string | undefined;
    emailConfirmed?: boolean;
    phoneNumber?: string | undefined;
    phoneNumberConfirmed?: boolean;
    lockoutEnd?: Date | undefined;
    lockoutEnabled?: boolean;
    accessFailedCount?: number;
}

export class UserProfileDTO implements IUserProfileDTO {
    id?: string | undefined;
    userName?: string | undefined;
    email?: string | undefined;
    phoneNumber?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    dateOfBirth?: Date | undefined;
    gender?: string | undefined;
    programs?: ProgramDTO[];
    certifications?: CertificationDTO[];
    coachingServices?: CoachingServiceDTO[];

    constructor(data?: IUserProfileDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.dateOfBirth = _data["dateOfBirth"] ? new Date(_data["dateOfBirth"].toString()) : <any>undefined;
            this.gender = _data["gender"];
            if (Array.isArray(_data["programs"])) {
                this.programs = [] as any;
                for (let item of _data["programs"])
                    this.programs!.push(ProgramDTO.fromJS(item));
            }
            if (Array.isArray(_data["certifications"])) {
                this.certifications = [] as any;
                for (let item of _data["certifications"])
                    this.certifications!.push(CertificationDTO.fromJS(item));
            }
            if (Array.isArray(_data["coachingServices"])) {
                this.coachingServices = [] as any;
                for (let item of _data["coachingServices"])
                    this.coachingServices!.push(CoachingServiceDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserProfileDTO {
        data = typeof data === 'object' ? data : {};
        let result = new UserProfileDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["gender"] = this.gender;
        if (Array.isArray(this.programs)) {
            data["programs"] = [];
            for (let item of this.programs)
                data["programs"].push(item.toJSON());
        }
        if (Array.isArray(this.certifications)) {
            data["certifications"] = [];
            for (let item of this.certifications)
                data["certifications"].push(item.toJSON());
        }
        if (Array.isArray(this.coachingServices)) {
            data["coachingServices"] = [];
            for (let item of this.coachingServices)
                data["coachingServices"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUserProfileDTO {
    id?: string | undefined;
    userName?: string | undefined;
    email?: string | undefined;
    phoneNumber?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    dateOfBirth?: Date | undefined;
    gender?: string | undefined;
    programs?: ProgramDTO[];
    certifications?: CertificationDTO[];
    coachingServices?: CoachingServiceDTO[];
}

export class ProgramDTO implements IProgramDTO {
    programId?: number;
    programName?: string | undefined;
    numberOfWeeks?: number | undefined;
    daysPerWeek?: number | undefined;
    dateCreated?: Date;
    lastModified?: Date;
    goal?: string | undefined;
    experienceLevel?: string | undefined;
    gymType?: string | undefined;
    musclesPriority?: string | undefined;
    ageGroup?: string | undefined;
    publicProgram?: boolean | undefined;

    constructor(data?: IProgramDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.programId = _data["programId"];
            this.programName = _data["programName"];
            this.numberOfWeeks = _data["numberOfWeeks"];
            this.daysPerWeek = _data["daysPerWeek"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.lastModified = _data["lastModified"] ? new Date(_data["lastModified"].toString()) : <any>undefined;
            this.goal = _data["goal"];
            this.experienceLevel = _data["experienceLevel"];
            this.gymType = _data["gymType"];
            this.musclesPriority = _data["musclesPriority"];
            this.ageGroup = _data["ageGroup"];
            this.publicProgram = _data["publicProgram"];
        }
    }

    static fromJS(data: any): ProgramDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ProgramDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["programId"] = this.programId;
        data["programName"] = this.programName;
        data["numberOfWeeks"] = this.numberOfWeeks;
        data["daysPerWeek"] = this.daysPerWeek;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>undefined;
        data["goal"] = this.goal;
        data["experienceLevel"] = this.experienceLevel;
        data["gymType"] = this.gymType;
        data["musclesPriority"] = this.musclesPriority;
        data["ageGroup"] = this.ageGroup;
        data["publicProgram"] = this.publicProgram;
        return data;
    }
}

export interface IProgramDTO {
    programId?: number;
    programName?: string | undefined;
    numberOfWeeks?: number | undefined;
    daysPerWeek?: number | undefined;
    dateCreated?: Date;
    lastModified?: Date;
    goal?: string | undefined;
    experienceLevel?: string | undefined;
    gymType?: string | undefined;
    musclesPriority?: string | undefined;
    ageGroup?: string | undefined;
    publicProgram?: boolean | undefined;
}

export class CertificationDTO implements ICertificationDTO {
    certificationId?: number;
    certificationName?: string | undefined;
    certificationDateIssued?: Date | undefined;
    certificationExpirationData?: Date | undefined;

    constructor(data?: ICertificationDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.certificationId = _data["certificationId"];
            this.certificationName = _data["certificationName"];
            this.certificationDateIssued = _data["certificationDateIssued"] ? new Date(_data["certificationDateIssued"].toString()) : <any>undefined;
            this.certificationExpirationData = _data["certificationExpirationData"] ? new Date(_data["certificationExpirationData"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CertificationDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CertificationDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["certificationId"] = this.certificationId;
        data["certificationName"] = this.certificationName;
        data["certificationDateIssued"] = this.certificationDateIssued ? formatDate(this.certificationDateIssued) : <any>undefined;
        data["certificationExpirationData"] = this.certificationExpirationData ? formatDate(this.certificationExpirationData) : <any>undefined;
        return data;
    }
}

export interface ICertificationDTO {
    certificationId?: number;
    certificationName?: string | undefined;
    certificationDateIssued?: Date | undefined;
    certificationExpirationData?: Date | undefined;
}

export class CoachingServiceDTO implements ICoachingServiceDTO {
    id?: number;
    serviceName?: string | undefined;
    description?: string | undefined;
    duration?: number | undefined;
    price?: number | undefined;
    serviceAvailability?: boolean | undefined;
    availabilityAnnouncement?: string | undefined;

    constructor(data?: ICoachingServiceDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.serviceName = _data["serviceName"];
            this.description = _data["description"];
            this.duration = _data["duration"];
            this.price = _data["price"];
            this.serviceAvailability = _data["serviceAvailability"];
            this.availabilityAnnouncement = _data["availabilityAnnouncement"];
        }
    }

    static fromJS(data: any): CoachingServiceDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CoachingServiceDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["serviceName"] = this.serviceName;
        data["description"] = this.description;
        data["duration"] = this.duration;
        data["price"] = this.price;
        data["serviceAvailability"] = this.serviceAvailability;
        data["availabilityAnnouncement"] = this.availabilityAnnouncement;
        return data;
    }
}

export interface ICoachingServiceDTO {
    id?: number;
    serviceName?: string | undefined;
    description?: string | undefined;
    duration?: number | undefined;
    price?: number | undefined;
    serviceAvailability?: boolean | undefined;
    availabilityAnnouncement?: string | undefined;
}

export class CreateUserCommand implements ICreateUserCommand {
    email?: string;
    password?: string;
    userName?: string;
    role?: string;

    constructor(data?: ICreateUserCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
            this.userName = _data["userName"];
            this.role = _data["role"];
        }
    }

    static fromJS(data: any): CreateUserCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        data["userName"] = this.userName;
        data["role"] = this.role;
        return data;
    }
}

export interface ICreateUserCommand {
    email?: string;
    password?: string;
    userName?: string;
    role?: string;
}

export class RecoverAccountCommand implements IRecoverAccountCommand {
    email?: string;

    constructor(data?: IRecoverAccountCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): RecoverAccountCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RecoverAccountCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        return data;
    }
}

export interface IRecoverAccountCommand {
    email?: string;
}

export class CoachingServiceDetailsDto implements ICoachingServiceDetailsDto {
    id?: number;
    serviceName?: string;
    description?: string | undefined;
    duration?: number | undefined;
    price?: number | undefined;
    serviceAvailability?: boolean | undefined;
    availabilityAnnouncement?: string | undefined;
    created?: Date;
    createdBy?: string | undefined;
    lastModified?: Date;
    lastModifiedBy?: string | undefined;
    createdByUserName?: string | undefined;
    lastModifiedByUserName?: string | undefined;

    constructor(data?: ICoachingServiceDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.serviceName = _data["serviceName"];
            this.description = _data["description"];
            this.duration = _data["duration"];
            this.price = _data["price"];
            this.serviceAvailability = _data["serviceAvailability"];
            this.availabilityAnnouncement = _data["availabilityAnnouncement"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.lastModified = _data["lastModified"] ? new Date(_data["lastModified"].toString()) : <any>undefined;
            this.lastModifiedBy = _data["lastModifiedBy"];
            this.createdByUserName = _data["createdByUserName"];
            this.lastModifiedByUserName = _data["lastModifiedByUserName"];
        }
    }

    static fromJS(data: any): CoachingServiceDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new CoachingServiceDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["serviceName"] = this.serviceName;
        data["description"] = this.description;
        data["duration"] = this.duration;
        data["price"] = this.price;
        data["serviceAvailability"] = this.serviceAvailability;
        data["availabilityAnnouncement"] = this.availabilityAnnouncement;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>undefined;
        data["lastModifiedBy"] = this.lastModifiedBy;
        data["createdByUserName"] = this.createdByUserName;
        data["lastModifiedByUserName"] = this.lastModifiedByUserName;
        return data;
    }
}

export interface ICoachingServiceDetailsDto {
    id?: number;
    serviceName?: string;
    description?: string | undefined;
    duration?: number | undefined;
    price?: number | undefined;
    serviceAvailability?: boolean | undefined;
    availabilityAnnouncement?: string | undefined;
    created?: Date;
    createdBy?: string | undefined;
    lastModified?: Date;
    lastModifiedBy?: string | undefined;
    createdByUserName?: string | undefined;
    lastModifiedByUserName?: string | undefined;
}

export class PaginatedListOfCoachingServiceDTO implements IPaginatedListOfCoachingServiceDTO {
    items?: CoachingServiceDTO[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfCoachingServiceDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CoachingServiceDTO.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfCoachingServiceDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfCoachingServiceDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfCoachingServiceDTO {
    items?: CoachingServiceDTO[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class CreateCoachingServiceCommand implements ICreateCoachingServiceCommand {
    serviceName?: string;
    description?: string | undefined;
    duration?: number | undefined;
    price?: number | undefined;
    serviceAvailability?: boolean | undefined;
    availabilityAnnouncement?: string | undefined;

    constructor(data?: ICreateCoachingServiceCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.serviceName = _data["serviceName"];
            this.description = _data["description"];
            this.duration = _data["duration"];
            this.price = _data["price"];
            this.serviceAvailability = _data["serviceAvailability"];
            this.availabilityAnnouncement = _data["availabilityAnnouncement"];
        }
    }

    static fromJS(data: any): CreateCoachingServiceCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCoachingServiceCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["serviceName"] = this.serviceName;
        data["description"] = this.description;
        data["duration"] = this.duration;
        data["price"] = this.price;
        data["serviceAvailability"] = this.serviceAvailability;
        data["availabilityAnnouncement"] = this.availabilityAnnouncement;
        return data;
    }
}

export interface ICreateCoachingServiceCommand {
    serviceName?: string;
    description?: string | undefined;
    duration?: number | undefined;
    price?: number | undefined;
    serviceAvailability?: boolean | undefined;
    availabilityAnnouncement?: string | undefined;
}

export class UpdateCoachingServiceCommand implements IUpdateCoachingServiceCommand {
    id?: number;
    serviceName?: string;
    description?: string | undefined;
    duration?: number | undefined;
    price?: number | undefined;
    serviceAvailability?: boolean | undefined;
    availabilityAnnouncement?: string | undefined;

    constructor(data?: IUpdateCoachingServiceCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.serviceName = _data["serviceName"];
            this.description = _data["description"];
            this.duration = _data["duration"];
            this.price = _data["price"];
            this.serviceAvailability = _data["serviceAvailability"];
            this.availabilityAnnouncement = _data["availabilityAnnouncement"];
        }
    }

    static fromJS(data: any): UpdateCoachingServiceCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCoachingServiceCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["serviceName"] = this.serviceName;
        data["description"] = this.description;
        data["duration"] = this.duration;
        data["price"] = this.price;
        data["serviceAvailability"] = this.serviceAvailability;
        data["availabilityAnnouncement"] = this.availabilityAnnouncement;
        return data;
    }
}

export interface IUpdateCoachingServiceCommand {
    id?: number;
    serviceName?: string;
    description?: string | undefined;
    duration?: number | undefined;
    price?: number | undefined;
    serviceAvailability?: boolean | undefined;
    availabilityAnnouncement?: string | undefined;
}

export class UpdateCoachProfileCommand implements IUpdateCoachProfileCommand {
    userId?: string;
    bio?: string | undefined;
    profilePicture?: string | undefined;
    majorAchievements?: string[] | undefined;
    galleryImageLinks?: string[] | undefined;

    constructor(data?: IUpdateCoachProfileCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.bio = _data["bio"];
            this.profilePicture = _data["profilePicture"];
            if (Array.isArray(_data["majorAchievements"])) {
                this.majorAchievements = [] as any;
                for (let item of _data["majorAchievements"])
                    this.majorAchievements!.push(item);
            }
            if (Array.isArray(_data["galleryImageLinks"])) {
                this.galleryImageLinks = [] as any;
                for (let item of _data["galleryImageLinks"])
                    this.galleryImageLinks!.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateCoachProfileCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCoachProfileCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["bio"] = this.bio;
        data["profilePicture"] = this.profilePicture;
        if (Array.isArray(this.majorAchievements)) {
            data["majorAchievements"] = [];
            for (let item of this.majorAchievements)
                data["majorAchievements"].push(item);
        }
        if (Array.isArray(this.galleryImageLinks)) {
            data["galleryImageLinks"] = [];
            for (let item of this.galleryImageLinks)
                data["galleryImageLinks"].push(item);
        }
        return data;
    }
}

export interface IUpdateCoachProfileCommand {
    userId?: string;
    bio?: string | undefined;
    profilePicture?: string | undefined;
    majorAchievements?: string[] | undefined;
    galleryImageLinks?: string[] | undefined;
}

export class CreateCoachApplicationQuery implements ICreateCoachApplicationQuery {
    token?: string | undefined;

    constructor(data?: ICreateCoachApplicationQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): CreateCoachApplicationQuery {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCoachApplicationQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        return data;
    }
}

export interface ICreateCoachApplicationQuery {
    token?: string | undefined;
}

export class UpdateCoachApplicationStatusCommand implements IUpdateCoachApplicationStatusCommand {
    applicationId?: number;
    status?: string;
    statusReason?: string | undefined;
    updatedById?: string;

    constructor(data?: IUpdateCoachApplicationStatusCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.applicationId = _data["applicationId"];
            this.status = _data["status"];
            this.statusReason = _data["statusReason"];
            this.updatedById = _data["updatedById"];
        }
    }

    static fromJS(data: any): UpdateCoachApplicationStatusCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCoachApplicationStatusCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["applicationId"] = this.applicationId;
        data["status"] = this.status;
        data["statusReason"] = this.statusReason;
        data["updatedById"] = this.updatedById;
        return data;
    }
}

export interface IUpdateCoachApplicationStatusCommand {
    applicationId?: number;
    status?: string;
    statusReason?: string | undefined;
    updatedById?: string;
}

export class PaginatedListOfCoachApplicationDto implements IPaginatedListOfCoachApplicationDto {
    items?: CoachApplicationDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfCoachApplicationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CoachApplicationDto.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfCoachApplicationDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfCoachApplicationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfCoachApplicationDto {
    items?: CoachApplicationDto[];
    pageNumber?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class CoachApplicationDto implements ICoachApplicationDto {
    id?: number;
    applicantId?: string;
    status?: string;
    statusReason?: string | undefined;
    created?: Date;
    lastModified?: Date;
    applicantName?: string;
    applicantEmail?: string;

    constructor(data?: ICoachApplicationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.applicantId = _data["applicantId"];
            this.status = _data["status"];
            this.statusReason = _data["statusReason"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.lastModified = _data["lastModified"] ? new Date(_data["lastModified"].toString()) : <any>undefined;
            this.applicantName = _data["applicantName"];
            this.applicantEmail = _data["applicantEmail"];
        }
    }

    static fromJS(data: any): CoachApplicationDto {
        data = typeof data === 'object' ? data : {};
        let result = new CoachApplicationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["applicantId"] = this.applicantId;
        data["status"] = this.status;
        data["statusReason"] = this.statusReason;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>undefined;
        data["applicantName"] = this.applicantName;
        data["applicantEmail"] = this.applicantEmail;
        return data;
    }
}

export interface ICoachApplicationDto {
    id?: number;
    applicantId?: string;
    status?: string;
    statusReason?: string | undefined;
    created?: Date;
    lastModified?: Date;
    applicantName?: string;
    applicantEmail?: string;
}

function formatDate(d: Date) {
    return d.getFullYear() + '-' + 
        (d.getMonth() < 9 ? ('0' + (d.getMonth()+1)) : (d.getMonth()+1)) + '-' +
        (d.getDate() < 10 ? ('0' + d.getDate()) : d.getDate());
}

export class SwaggerException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new SwaggerException(message, status, response, headers, null);
}